{
  "version": 3,
  "sources": ["../../@fluentui/react/lib/components/Icon/components/Icon/Icon.types.ts", "../../@fluentui/react/lib/components/Image/components/Image/Image.types.ts", "../../@fluentui/react/lib/components/Image/components/Image/Image.base.tsx", "../../@fluentui/react/lib/components/Image/components/Image/Image.styles.ts", "../../@fluentui/react/lib/components/Image/components/Image/Image.tsx", "../../@fluentui/react/lib/components/Icon/components/Icon/FontIcon.tsx", "../../@fluentui/react/lib/components/Icon/components/Icon/Icon.styles.ts", "../../@fluentui/react/lib/components/Icon/components/Icon/Icon.base.tsx", "../../@fluentui/react/lib/components/Icon/components/Icon/Icon.tsx", "../../@fluentui/react/lib/components/Icon/components/Icon/ImageIcon.tsx", "../../@fluentui/react-focus/lib/components/FocusZone/components/FocusZone/FocusZone.types.ts", "../../@fluentui/react-focus/lib/components/FocusZone/components/FocusZone/FocusZone.tsx", "../../@fluentui/react-focus/lib/version.ts", "../../@fluentui/react/lib/utilities/decorators/utilities/decorators/BaseDecorator.ts"],
  "sourcesContent": ["import * as React from 'react';\nimport type { IImageProps } from '../Image/Image.types';\nimport type { IStyle, ITheme } from '../../Styling';\nimport type { IBaseProps, IStyleFunctionOrObject } from '../../Utilities';\n\n/**\n * @deprecated Icon type is inferred based on presence of `IIconProps.imageProps`\n * {@docCategory Icon}\n */\nexport enum IconType {\n  /**\n   * Render using the fabric icon font.\n   * @deprecated Icon type is inferred based on presence of `IIconProps.imageProps`\n   */\n  default = 0,\n\n  /**\n   * Render using an image, where imageProps would be used.\n   * @deprecated Icon type is inferred based on presence of `IIconProps.imageProps`\n   */\n  image = 1,\n\n  /**\n   * @deprecated Icon type is inferred based on presence of `IIconProps.imageProps`\n   */\n  Default = 100000,\n\n  /**\n   * @deprecated Icon type is inferred based on presence of `IIconProps.imageProps`\n   */\n  Image = 100001,\n}\n\n/**\n * {@docCategory Icon}\n */\nexport interface IIconProps extends IBaseProps, React.HTMLAttributes<HTMLElement> {\n  /**\n   * The name of the icon to use from the icon font.\n   * If string is empty, a placeholder icon will be rendered the same width as an icon.\n   */\n  iconName?: string;\n\n  /**\n   * The aria label of the icon for the benefit of screen readers.\n   * @deprecated Use the native prop `aria-label`\n   */\n  ariaLabel?: string;\n\n  /**\n   * The type of icon to render (image or icon font).\n   * @deprecated Inferred based on the presence of `imageProps`\n   */\n  // eslint-disable-next-line deprecation/deprecation\n  iconType?: IconType;\n\n  /**\n   * If rendering an image icon, these props will be passed to the Image component.\n   */\n  imageProps?: IImageProps;\n\n  /**\n   * If rendering an image icon, this component will be rendered in the event that loading the image fails.\n   */\n  imageErrorAs?: React.ComponentType<IImageProps>;\n\n  /**\n   * Gets the styles for an Icon.\n   */\n  styles?: IStyleFunctionOrObject<IIconStyleProps, IIconStyles>;\n  theme?: ITheme;\n}\n\n/**\n * {@docCategory Icon}\n */\nexport interface IIconStyleProps {\n  className?: string;\n  iconClassName?: string;\n  isPlaceholder: boolean;\n  isImage: boolean;\n  styles?: Partial<IIconStyles>;\n  theme?: ITheme;\n}\n\n/**\n * {@docCategory Icon}\n */\nexport interface IIconStyles {\n  root?: IStyle;\n\n  /**\n   * @deprecated Use `root`.\n   */\n  imageContainer?: IStyle;\n}\n\n/**\n * Props for a basic icon component which only supports font glyphs and can't be targeted by customizations.\n * {@docCategory Icon}\n */\nexport interface IFontIconProps extends React.HTMLAttributes<HTMLElement> {\n  /**\n   * The name of the icon to use from the icon font.\n   * If string is empty, a placeholder icon will be rendered the same width as an icon.\n   */\n  iconName?: string;\n\n  /**\n   * Custom class to style the icon.\n   */\n  className?: string;\n}\n\n/**\n * Props for a basic image icon component which doesn't directly provide image load error handling\n * and can't be targeted by customizations.\n * {@docCategory Icon}\n */\nexport interface IImageIconProps extends React.HTMLAttributes<HTMLElement> {\n  /**\n   * Props passed to the Image component.\n   */\n  imageProps: IImageProps;\n\n  /**\n   * Custom class to style the icon.\n   */\n  className?: string;\n}\n", "import * as React from 'react';\nimport type { IStyle, ITheme } from '../../Styling';\nimport type { IStyleFunctionOrObject } from '../../Utilities';\n\n/**\n * {@docCategory Image}\n */\nexport interface IImage {}\n\n/**\n * {@docCategory Image}\n */\nexport interface IImageProps extends React.ImgHTMLAttributes<HTMLImageElement>, React.RefAttributes<HTMLImageElement> {\n  /**\n   * Call to provide customized styling that will layer on top of the variant rules\n   */\n  styles?: IStyleFunctionOrObject<IImageStyleProps, IImageStyles>;\n\n  /**\n   * Theme provided by HOC.\n   */\n  theme?: ITheme;\n\n  /**\n   * Additional css class to apply to the Component\n   * @defaultvalue undefined\n   */\n  className?: string;\n\n  /**\n   * If true, fades the image in when loaded.\n   * @defaultvalue true\n   */\n  shouldFadeIn?: boolean;\n\n  /**\n   * If true, the image starts as visible and is hidden on error. Otherwise, the image is hidden until\n   * it is successfully loaded. This disables shouldFadeIn.\n   * @defaultvalue false;\n   */\n  shouldStartVisible?: boolean;\n\n  /**\n   * Used to determine how the image is scaled and cropped to fit the frame.\n   *\n   * @defaultvalue If both dimensions are provided, then the image is fit using `ImageFit.scale`.\n   * Otherwise, the image won't be scaled or cropped.\n   */\n  imageFit?: ImageFit;\n\n  /**\n   * @deprecated Not used. Use `onLoadingStateChange` and re-render the Image with a different src.\n   */\n  errorSrc?: string;\n\n  /**\n   * If true, the image frame will expand to fill its parent container.\n   */\n  maximizeFrame?: boolean;\n\n  /**\n   * Optional callback method for when the image load state has changed.\n   * The 'loadState' parameter indicates the current state of the Image.\n   */\n  onLoadingStateChange?: (loadState: ImageLoadState) => void;\n\n  /**\n   * Specifies the cover style to be used for this image. If not\n   * specified, this will be dynamically calculated based on the\n   * aspect ratio for the image.\n   */\n  coverStyle?: ImageCoverStyle;\n\n  /**\n   * Allows for browser-level image lazy-loading.\n   */\n  loading?: 'lazy' | 'eager';\n}\n\n/**\n * The possible methods that can be used to fit the image.\n * {@docCategory Image}\n */\nexport enum ImageFit {\n  /**\n   * The image is not scaled. The image is centered and cropped within the content box.\n   */\n  center = 0,\n\n  /**\n   * The image is scaled to maintain its aspect ratio while being fully contained within the frame. The image will\n   * be centered horizontally and vertically within the frame. The space in the top and bottom or in the sides of\n   * the frame will be empty depending on the difference in aspect ratio between the image and the frame.\n   */\n  contain = 1,\n\n  /**\n   * The image is scaled to maintain its aspect ratio while filling the frame. Portions of the image will be cropped\n   * from the top and bottom, or the sides, depending on the difference in aspect ratio between the image and the frame.\n   */\n  cover = 2,\n\n  /**\n   * Neither the image nor the frame are scaled. If their sizes do not match, the image will either be cropped or the\n   * frame will have empty space.\n   */\n  none = 3,\n\n  /**\n   * The image will be centered horizontally and vertically within the frame and maintains its aspect ratio. It will\n   * behave as ImageFit.center if the image's natural height or width is less than the Image frame's height or width,\n   * but if both natural height and width are larger than the frame it will behave as ImageFit.cover.\n   */\n  centerCover = 4,\n\n  /**\n   * The image will be centered horizontally and vertically within the frame and maintains its aspect ratio. It will\n   * behave as ImageFit.center if the image's natural height and width is less than the Image frame's height and width,\n   * but if either natural height or width are larger than the frame it will behave as ImageFit.contain.\n   */\n  centerContain = 5,\n}\n\n/**\n * The cover style to be used on the image\n * {@docCategory Image}\n */\nexport enum ImageCoverStyle {\n  /**\n   * The image will be shown at 100% height of container and the width will be scaled accordingly\n   */\n  landscape = 0,\n\n  /**\n   * The image will be shown at 100% width of container and the height will be scaled accordingly\n   */\n  portrait = 1,\n}\n\n/**\n * {@docCategory Image}\n */\nexport enum ImageLoadState {\n  /**\n   * The image has not yet been loaded, and there is no error yet.\n   */\n  notLoaded = 0,\n\n  /**\n   * The image has been loaded successfully.\n   */\n  loaded = 1,\n\n  /**\n   * An error has been encountered while loading the image.\n   */\n  error = 2,\n\n  /**\n   * @deprecated Not used. Use `onLoadingStateChange` and re-render the Image with a different src.\n   */\n  errorLoaded = 3,\n}\n\n/**\n * {@docCategory Image}\n */\nexport interface IImageStyleProps {\n  /**\n   * Accept theme prop.\n   */\n  theme: ITheme;\n\n  /**\n   * Accept custom classNames\n   */\n  className?: string;\n\n  /**\n   * If true, the image frame will expand to fill its parent container.\n   */\n  maximizeFrame?: boolean;\n\n  /**\n   * If true, the image is loaded\n   */\n  isLoaded?: boolean;\n\n  /**\n   * If true, fades the image in when loaded.\n   * @defaultvalue true\n   */\n  shouldFadeIn?: boolean;\n\n  /**\n   * If true, the image starts as visible and is hidden on error. Otherwise, the image is hidden until\n   * it is successfully loaded. This disables shouldFadeIn.\n   * @defaultvalue false;\n   */\n  shouldStartVisible?: boolean;\n\n  /**\n   * If true the image is coverStyle landscape instead of portrait\n   */\n  isLandscape?: boolean;\n\n  /**\n   * ImageFit booleans for center, cover, contain, centerContain, centerCover, none\n   */\n  isCenter?: boolean;\n  isContain?: boolean;\n  isCover?: boolean;\n  isCenterContain?: boolean;\n  isCenterCover?: boolean;\n  isNone?: boolean;\n\n  /**\n   * if true image load is in error\n   */\n  isError?: boolean;\n\n  /**\n   * if true, imageFit is undefined\n   */\n  isNotImageFit?: boolean;\n\n  /**\n   * Image width value\n   */\n  width?: number | string;\n\n  /**\n   * Image height value\n   */\n  height?: number | string;\n}\n\n/**\n * {@docCategory Image}\n */\nexport interface IImageStyles {\n  /**\n   * Style set for the root div element.\n   */\n  root: IStyle;\n  /**\n   * Style set for the img element.\n   */\n  image: IStyle;\n}\n", "import * as React from 'react';\nimport { classNamesFunction, getNativeProps, imgProperties } from '../../Utilities';\nimport { ImageCoverStyle, ImageFit, ImageLoadState } from './Image.types';\nimport { useIsomorphicLayoutEffect, useMergedRefs } from '@fluentui/react-hooks';\nimport type { IImageProps, IImageStyleProps, IImageStyles } from './Image.types';\n\nconst getClassNames = classNamesFunction<IImageStyleProps, IImageStyles>();\n\nexport interface IImageState {\n  loadState?: ImageLoadState;\n}\n\nconst SVG_REGEX = /\\.svg$/i;\nconst KEY_PREFIX = 'fabricImage';\n\nfunction useLoadState(\n  props: IImageProps,\n  imageElement: React.RefObject<HTMLImageElement>,\n): readonly [\n  ImageLoadState,\n  /* onImageLoad */ (ev: React.SyntheticEvent<HTMLImageElement>) => void,\n  /* onImageError */ (ev: React.SyntheticEvent<HTMLImageElement>) => void,\n] {\n  const { onLoadingStateChange, onLoad, onError, src } = props;\n\n  const [loadState, setLoadState] = React.useState<ImageLoadState>(ImageLoadState.notLoaded);\n\n  useIsomorphicLayoutEffect(() => {\n    // If the src property changes, reset the load state\n    // (does nothing if the load state is already notLoaded)\n    setLoadState(ImageLoadState.notLoaded);\n  }, [src]);\n\n  // eslint-disable-next-line react-hooks/exhaustive-deps -- intended to run every render\n  React.useEffect(() => {\n    if (loadState === ImageLoadState.notLoaded) {\n      // testing if naturalWidth and naturalHeight are greater than zero is better than checking\n      // .complete, because .complete will also be set to true if the image breaks. However,\n      // for some browsers, SVG images do not have a naturalWidth or naturalHeight, so fall back\n      // to checking .complete for these images.\n      const isLoaded: boolean = imageElement.current\n        ? (src && imageElement.current.naturalWidth > 0 && imageElement.current.naturalHeight > 0) ||\n          (imageElement.current.complete && SVG_REGEX.test(src!))\n        : false;\n\n      if (isLoaded) {\n        setLoadState(ImageLoadState.loaded);\n      }\n    }\n  });\n\n  React.useEffect(() => {\n    onLoadingStateChange?.(loadState);\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- should only run when loadState changes\n  }, [loadState]);\n\n  const onImageLoaded = React.useCallback(\n    (ev: React.SyntheticEvent<HTMLImageElement>) => {\n      onLoad?.(ev);\n      if (src) {\n        setLoadState(ImageLoadState.loaded);\n      }\n    },\n    [src, onLoad],\n  );\n\n  const onImageError = React.useCallback(\n    (ev: React.SyntheticEvent<HTMLImageElement>) => {\n      onError?.(ev);\n      setLoadState(ImageLoadState.error);\n    },\n    [onError],\n  );\n\n  return [loadState, onImageLoaded, onImageError] as const;\n}\n\nexport const ImageBase: React.FunctionComponent<IImageProps> = React.forwardRef<HTMLImageElement, IImageProps>(\n  (props, forwardedRef) => {\n    const frameElement = React.useRef<HTMLDivElement>() as React.RefObject<HTMLDivElement>;\n    const imageElement = React.useRef<HTMLImageElement>() as React.RefObject<HTMLImageElement>;\n    const [loadState, onImageLoaded, onImageError] = useLoadState(props, imageElement);\n\n    const imageProps = getNativeProps<React.ImgHTMLAttributes<HTMLImageElement>>(props, imgProperties, [\n      'width',\n      'height',\n    ]);\n    const {\n      src,\n      alt,\n      width,\n      height,\n      shouldFadeIn = true,\n      shouldStartVisible,\n      className,\n      imageFit,\n      role,\n      maximizeFrame,\n      styles,\n      theme,\n      loading,\n    } = props;\n    const coverStyle = useCoverStyle(props, loadState, imageElement, frameElement);\n    const classNames = getClassNames(styles!, {\n      theme: theme!,\n      className,\n      width,\n      height,\n      maximizeFrame,\n      shouldFadeIn,\n      shouldStartVisible,\n      isLoaded:\n        loadState === ImageLoadState.loaded || (loadState === ImageLoadState.notLoaded && props.shouldStartVisible),\n      isLandscape: coverStyle === ImageCoverStyle.landscape,\n      isCenter: imageFit === ImageFit.center,\n      isCenterContain: imageFit === ImageFit.centerContain,\n      isCenterCover: imageFit === ImageFit.centerCover,\n      isContain: imageFit === ImageFit.contain,\n      isCover: imageFit === ImageFit.cover,\n      isNone: imageFit === ImageFit.none,\n      isError: loadState === ImageLoadState.error,\n      isNotImageFit: imageFit === undefined,\n    });\n\n    // If image dimensions aren't specified, the natural size of the image is used.\n    return (\n      <div className={classNames.root} style={{ width: width, height: height }} ref={frameElement}>\n        <img\n          {...imageProps}\n          onLoad={onImageLoaded}\n          onError={onImageError}\n          key={KEY_PREFIX + props.src || ''}\n          className={classNames.image}\n          ref={useMergedRefs(imageElement, forwardedRef)}\n          src={src}\n          alt={alt}\n          role={role}\n          loading={loading}\n        />\n      </div>\n    );\n  },\n);\nImageBase.displayName = 'ImageBase';\n\nfunction useCoverStyle(\n  props: IImageProps,\n  loadState: ImageLoadState,\n  imageElement: React.RefObject<HTMLImageElement>,\n  frameElement: React.RefObject<HTMLDivElement>,\n) {\n  const previousLoadState = React.useRef(loadState);\n  const coverStyle = React.useRef<ImageCoverStyle | undefined>();\n\n  if (\n    coverStyle === undefined ||\n    (previousLoadState.current === ImageLoadState.notLoaded && loadState === ImageLoadState.loaded)\n  ) {\n    coverStyle.current = computeCoverStyle(props, loadState, imageElement, frameElement);\n  }\n\n  previousLoadState.current = loadState;\n\n  return coverStyle.current!;\n}\n\nfunction computeCoverStyle(\n  props: IImageProps,\n  loadState: ImageLoadState,\n  imageElement: React.RefObject<HTMLImageElement>,\n  frameElement: React.RefObject<HTMLDivElement>,\n): ImageCoverStyle {\n  const { imageFit, width, height } = props;\n\n  // Do not compute cover style if it was already specified in props\n  if (props.coverStyle !== undefined) {\n    return props.coverStyle;\n  } else if (\n    loadState === ImageLoadState.loaded &&\n    (imageFit === ImageFit.cover ||\n      imageFit === ImageFit.contain ||\n      imageFit === ImageFit.centerContain ||\n      imageFit === ImageFit.centerCover) &&\n    imageElement.current &&\n    frameElement.current\n  ) {\n    // Determine the desired ratio using the width and height props.\n    // If those props aren't available, measure measure the frame.\n    let desiredRatio;\n    if (\n      typeof width === 'number' &&\n      typeof height === 'number' &&\n      imageFit !== ImageFit.centerContain &&\n      imageFit !== ImageFit.centerCover\n    ) {\n      desiredRatio = width / height;\n    } else {\n      desiredRatio = frameElement.current.clientWidth / frameElement.current.clientHeight;\n    }\n\n    // Examine the source image to determine its original ratio.\n    const naturalRatio = imageElement.current.naturalWidth / imageElement.current.naturalHeight;\n\n    // Should we crop from the top or the sides?\n    if (naturalRatio > desiredRatio) {\n      return ImageCoverStyle.landscape;\n    }\n  }\n  return ImageCoverStyle.portrait;\n}\n", "import { AnimationClassNames, getGlobalClassNames } from '../../Styling';\nimport { getWindow } from '../../Utilities';\nimport type { IStyle } from '../../Styling';\nimport type { IImageStyleProps, IImageStyles } from './Image.types';\n\nconst GlobalClassNames = {\n  root: 'ms-Image',\n  rootMaximizeFrame: 'ms-Image--maximizeFrame',\n  image: 'ms-Image-image',\n  imageCenter: 'ms-Image-image--center',\n  imageContain: 'ms-Image-image--contain',\n  imageCover: 'ms-Image-image--cover',\n  imageCenterContain: 'ms-Image-image--centerContain',\n  imageCenterCover: 'ms-Image-image--centerCover',\n  imageNone: 'ms-Image-image--none',\n  imageLandscape: 'ms-Image-image--landscape',\n  imagePortrait: 'ms-Image-image--portrait',\n};\n\nexport const getStyles = (props: IImageStyleProps): IImageStyles => {\n  const {\n    className,\n    width,\n    height,\n    maximizeFrame,\n    isLoaded,\n    shouldFadeIn,\n    shouldStartVisible,\n    isLandscape,\n    isCenter,\n    isContain,\n    isCover,\n    isCenterContain,\n    isCenterCover,\n    isNone,\n    isError,\n    isNotImageFit,\n    theme,\n  } = props;\n\n  const classNames = getGlobalClassNames(GlobalClassNames, theme);\n\n  const ImageFitStyles: IStyle = {\n    position: 'absolute',\n    left: '50% /* @noflip */',\n    top: '50%',\n    transform: 'translate(-50%,-50%)', // @todo test RTL renders transform: translate(50%,-50%);\n  };\n\n  // Cut the mustard using msMaxTouchPoints to detect IE11 which does not support CSS object-fit\n  const window: Window | undefined = getWindow();\n  const supportsObjectFit: boolean = window !== undefined && window.navigator.msMaxTouchPoints === undefined;\n  const fallbackObjectFitStyles =\n    (isContain && isLandscape) || (isCover && !isLandscape)\n      ? { width: '100%', height: 'auto' }\n      : { width: 'auto', height: '100%' };\n\n  return {\n    root: [\n      classNames.root,\n      theme.fonts.medium,\n      {\n        overflow: 'hidden',\n      },\n      maximizeFrame && [\n        classNames.rootMaximizeFrame,\n        {\n          height: '100%',\n          width: '100%',\n        },\n      ],\n      isLoaded && shouldFadeIn && !shouldStartVisible && AnimationClassNames.fadeIn400,\n      (isCenter || isContain || isCover || isCenterContain || isCenterCover) && {\n        position: 'relative',\n      },\n      className,\n    ],\n    image: [\n      classNames.image,\n      {\n        display: 'block',\n        opacity: 0,\n      },\n      isLoaded && [\n        'is-loaded',\n        {\n          opacity: 1,\n        },\n      ],\n      isCenter && [classNames.imageCenter, ImageFitStyles],\n      isContain && [\n        classNames.imageContain,\n        supportsObjectFit && {\n          width: '100%',\n          height: '100%',\n          objectFit: 'contain',\n        },\n        !supportsObjectFit && fallbackObjectFitStyles,\n        !supportsObjectFit && ImageFitStyles,\n      ],\n      isCover && [\n        classNames.imageCover,\n        supportsObjectFit && {\n          width: '100%',\n          height: '100%',\n          objectFit: 'cover',\n        },\n        !supportsObjectFit && fallbackObjectFitStyles,\n        !supportsObjectFit && ImageFitStyles,\n      ],\n      isCenterContain && [\n        classNames.imageCenterContain,\n        isLandscape && {\n          maxWidth: '100%',\n        },\n        !isLandscape && {\n          maxHeight: '100%',\n        },\n        ImageFitStyles,\n      ],\n      isCenterCover && [\n        classNames.imageCenterCover,\n        isLandscape && {\n          maxHeight: '100%',\n        },\n        !isLandscape && {\n          maxWidth: '100%',\n        },\n        ImageFitStyles,\n      ],\n      isNone && [\n        classNames.imageNone,\n        {\n          width: 'auto',\n          height: 'auto',\n        },\n      ],\n      isNotImageFit && [\n        !!width &&\n          !height && {\n            height: 'auto',\n            width: '100%',\n          },\n        !width &&\n          !!height && {\n            height: '100%',\n            width: 'auto',\n          },\n        !!width &&\n          !!height && {\n            height: '100%',\n            width: '100%',\n          },\n      ],\n      isLandscape && classNames.imageLandscape,\n      !isLandscape && classNames.imagePortrait,\n      !isLoaded && 'is-notLoaded',\n      shouldFadeIn && 'is-fadeIn',\n      isError && 'is-error',\n    ],\n  };\n};\n", "import * as React from 'react';\nimport { styled } from '../../Utilities';\nimport { ImageBase } from './Image.base';\nimport { getStyles } from './Image.styles';\nimport type { IImageProps, IImageStyleProps, IImageStyles } from './Image.types';\n\nexport const Image: React.FunctionComponent<IImageProps> = styled<IImageProps, IImageStyleProps, IImageStyles>(\n  ImageBase,\n  getStyles,\n  undefined,\n  {\n    scope: 'Image',\n  },\n  true,\n);\nImage.displayName = 'Image';\n", "import * as React from 'react';\nimport { classNames, MS_ICON } from './Icon.styles';\nimport { css, getNativeProps, htmlElementProperties, memoizeFunction } from '../../Utilities';\nimport { getIcon } from '../../Styling';\nimport type { IFontIconProps } from './Icon.types';\nimport type { IIconRecord, IIconSubsetRecord } from '../../Styling';\n\nexport interface IIconContent {\n  children?: string | JSX.Element;\n  iconClassName?: string;\n  fontFamily?: string;\n  mergeImageProps?: boolean;\n}\n\nexport const getIconContent = memoizeFunction(\n  (iconName?: string): IIconContent | null => {\n    const { code, subset }: Pick<IIconRecord, 'code'> & { subset: Partial<IIconSubsetRecord> } = getIcon(iconName) || {\n      subset: {},\n      code: undefined,\n    };\n\n    if (!code) {\n      return null;\n    }\n\n    return {\n      children: code,\n      iconClassName: subset.className,\n      fontFamily: subset.fontFace && subset.fontFace.fontFamily,\n      mergeImageProps: subset.mergeImageProps,\n    };\n  },\n  undefined,\n  true /*ignoreNullOrUndefinedResult */,\n);\n\n/**\n * Fast icon component which only supports font glyphs (not images) and can't be targeted by customizations.\n * To style the icon, use `className` or reference `ms-Icon` in CSS.\n * {@docCategory Icon}\n */\nexport const FontIcon: React.FunctionComponent<IFontIconProps> = props => {\n  const { iconName, className, style = {} } = props;\n  const iconContent = getIconContent(iconName) || {};\n  const { iconClassName, children, fontFamily, mergeImageProps } = iconContent;\n\n  const nativeProps = getNativeProps<React.HTMLAttributes<HTMLElement>>(props, htmlElementProperties);\n  const accessibleName = props['aria-label'] || props.title;\n  const containerProps =\n    props['aria-label'] || props['aria-labelledby'] || props.title\n      ? {\n          role: mergeImageProps ? undefined : 'img',\n        }\n      : {\n          'aria-hidden': true,\n        };\n\n  let finalChildren = children;\n\n  if (mergeImageProps) {\n    if (typeof children === 'object' && typeof children.props === 'object' && accessibleName) {\n      finalChildren = React.cloneElement(children, { alt: accessibleName });\n    }\n  }\n\n  return (\n    <i\n      data-icon-name={iconName}\n      {...containerProps}\n      {...nativeProps}\n      {...(mergeImageProps\n        ? {\n            title: undefined,\n            'aria-label': undefined,\n          }\n        : {})}\n      className={css(MS_ICON, classNames.root, iconClassName, !iconName && classNames.placeholder, className)}\n      // Apply the font family this way to ensure it doesn't get overridden by Fabric Core ms-Icon styles\n      // https://github.com/microsoft/fluentui/issues/10449\n      style={{ fontFamily, ...style }}\n    >\n      {finalChildren}\n    </i>\n  );\n};\n\n/**\n * Memoized helper for rendering a FontIcon.\n * @param iconName - The name of the icon to use from the icon font.\n * @param className - Class name for styling the icon.\n * @param ariaLabel - Label for the icon for the benefit of screen readers.\n * {@docCategory Icon}\n */\nexport const getFontIcon = memoizeFunction((iconName: string, className?: string, ariaLabel?: string) => {\n  return FontIcon({ iconName, className, 'aria-label': ariaLabel });\n});\n", "import { mergeStyleSets } from '../../Styling';\nimport type { IIconStyleProps, IIconStyles } from './Icon.types';\n\n/** Class names used in themeable and non-themeable Icon components */\nexport const classNames = mergeStyleSets({\n  root: {\n    display: 'inline-block',\n  },\n  placeholder: [\n    'ms-Icon-placeHolder',\n    {\n      width: '1em',\n    },\n  ],\n  image: [\n    'ms-Icon-imageContainer',\n    {\n      overflow: 'hidden',\n    },\n  ],\n});\n/** Class name used only in non-themeable Icon components */\nexport const MS_ICON = 'ms-Icon';\n\nexport const getStyles = (props: IIconStyleProps): IIconStyles => {\n  const { className, iconClassName, isPlaceholder, isImage, styles } = props;\n\n  return {\n    root: [\n      isPlaceholder && classNames.placeholder,\n      classNames.root,\n      isImage && classNames.image,\n      iconClassName,\n      className,\n      styles && styles.root,\n      // eslint-disable-next-line deprecation/deprecation\n      styles && styles.imageContainer,\n    ],\n  };\n};\n", "import * as React from 'react';\n\nimport { IconType } from './Icon.types';\nimport { Image } from '../Image/Image';\nimport { ImageLoadState } from '../Image/Image.types';\nimport { getNativeProps, htmlElementProperties, classNamesFunction } from '../../Utilities';\nimport { getIconContent } from './FontIcon';\nimport type { IIconProps, IIconStyleProps, IIconStyles } from './Icon.types';\nimport type { IImageProps } from '../Image/Image.types';\n\nexport interface IIconState {\n  imageLoadError: boolean;\n}\n\nconst getClassNames = classNamesFunction<IIconStyleProps, IIconStyles>({\n  // Icon is used a lot by other components.\n  // It's likely to see expected cases which pass different className to the Icon.\n  // Therefore setting a larger cache size.\n  cacheSize: 100,\n});\n\nexport class IconBase extends React.Component<IIconProps, IIconState> {\n  constructor(props: IIconProps) {\n    super(props);\n    this.state = {\n      imageLoadError: false,\n    };\n  }\n\n  public render() {\n    const { children, className, styles, iconName, imageErrorAs, theme } = this.props;\n    const isPlaceholder = typeof iconName === 'string' && iconName.length === 0;\n    const isImage =\n      // eslint-disable-next-line deprecation/deprecation\n      !!this.props.imageProps || this.props.iconType === IconType.image || this.props.iconType === IconType.Image;\n    const iconContent = getIconContent(iconName) || {};\n    const { iconClassName, children: iconContentChildren, mergeImageProps } = iconContent;\n\n    const classNames = getClassNames(styles, {\n      theme: theme!,\n      className,\n      iconClassName,\n      isImage,\n      isPlaceholder,\n    });\n\n    const RootType = isImage ? 'span' : 'i';\n    const nativeProps = getNativeProps<React.HTMLAttributes<HTMLDivElement>>(this.props, htmlElementProperties, [\n      'aria-label',\n    ]);\n    const { imageLoadError } = this.state;\n    const imageProps: IImageProps = {\n      ...this.props.imageProps,\n      onLoadingStateChange: this._onImageLoadingStateChange,\n    };\n    const ImageType = (imageLoadError && imageErrorAs) || Image;\n\n    // eslint-disable-next-line deprecation/deprecation\n    const ariaLabel = this.props['aria-label'] || this.props.ariaLabel;\n    const accessibleName = imageProps.alt || ariaLabel || this.props.title;\n    const hasName = !!(\n      accessibleName ||\n      this.props['aria-labelledby'] ||\n      imageProps['aria-label'] ||\n      imageProps['aria-labelledby']\n    );\n    const containerProps = hasName\n      ? {\n          role: isImage || mergeImageProps ? undefined : 'img',\n          'aria-label': isImage || mergeImageProps ? undefined : accessibleName,\n        }\n      : {\n          'aria-hidden': true,\n        };\n\n    let finalIconContentChildren = iconContentChildren;\n\n    if (mergeImageProps && iconContentChildren && typeof iconContentChildren === 'object' && accessibleName) {\n      finalIconContentChildren = React.cloneElement(iconContentChildren, {\n        alt: accessibleName,\n      });\n    }\n\n    return (\n      <RootType\n        data-icon-name={iconName}\n        {...containerProps}\n        {...nativeProps}\n        {...(mergeImageProps\n          ? {\n              title: undefined,\n              'aria-label': undefined,\n            }\n          : {})}\n        className={classNames.root}\n      >\n        {isImage ? <ImageType {...imageProps} /> : children || finalIconContentChildren}\n      </RootType>\n    );\n  }\n\n  private _onImageLoadingStateChange = (state: ImageLoadState): void => {\n    if (this.props.imageProps && this.props.imageProps.onLoadingStateChange) {\n      this.props.imageProps.onLoadingStateChange(state);\n    }\n    if (state === ImageLoadState.error) {\n      this.setState({ imageLoadError: true });\n    }\n  };\n}\n", "import * as React from 'react';\nimport { styled } from '../../Utilities';\nimport { IconBase } from './Icon.base';\nimport { getStyles } from './Icon.styles';\nimport type { IIconProps, IIconStyleProps, IIconStyles } from './Icon.types';\n\n/**\n * Legacy Icon component which can be targeted by customization. It's recommended to use `FontIcon`\n * or `ImageIcon` instead, especially in scenarios where rendering performance is important.\n * {@docCategory Icon}\n */\nexport const Icon: React.FunctionComponent<IIconProps> = styled<IIconProps, IIconStyleProps, IIconStyles>(\n  IconBase,\n  getStyles,\n  undefined,\n  {\n    scope: 'Icon',\n  },\n  true,\n);\nIcon.displayName = 'Icon';\n", "import * as React from 'react';\nimport { Image } from '../Image/Image';\nimport { css, getNativeProps, htmlElementProperties } from '../../Utilities';\nimport { classNames, MS_ICON } from './Icon.styles';\nimport type { IImageIconProps } from './Icon.types';\n\n/**\n * Fast icon component which only supports images (not font glyphs) and can't be targeted by customizations.\n * To style the icon, use `className` or reference `ms-Icon` in CSS.\n * {@docCategory Icon}\n */\nexport const ImageIcon: React.FunctionComponent<IImageIconProps> = props => {\n  const { className, imageProps } = props;\n\n  const nativeProps = getNativeProps<React.HTMLAttributes<HTMLDivElement>>(props, htmlElementProperties, [\n    'aria-label',\n    'aria-labelledby',\n    'title',\n    'aria-describedby',\n  ]);\n  const altText = imageProps.alt || props['aria-label'];\n  const hasName =\n    altText ||\n    props['aria-labelledby'] ||\n    props.title ||\n    imageProps['aria-label'] ||\n    imageProps['aria-labelledby'] ||\n    imageProps.title;\n\n  // move naming or describing attributes from the container (where they are invalid) to the image\n  const imageNameProps = {\n    'aria-labelledby': props['aria-labelledby'],\n    'aria-describedby': props['aria-describedby'],\n    title: props.title,\n  };\n\n  const containerProps = hasName\n    ? {}\n    : {\n        'aria-hidden': true,\n      };\n\n  return (\n    <div {...containerProps} {...nativeProps} className={css(MS_ICON, classNames.root, classNames.image, className)}>\n      <Image {...imageNameProps} {...imageProps} alt={hasName ? altText : ''} />\n    </div>\n  );\n};\n", "import * as React from 'react';\nimport type { IRefObject, Point } from '@fluentui/utilities';\n\n/**\n * FocusZone component class interface.\n * {@docCategory FocusZone}\n */\nexport interface IFocusZone {\n  /**\n   * Sets focus to the first tabbable item in the zone.\n   * @param forceIntoFirstElement - If true, focus will be forced into the first element, even\n   * if focus is already in the focus zone.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  focus(forceIntoFirstElement?: boolean): boolean;\n\n  /**\n   * Sets focus to the last tabbable item in the zone.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  focusLast(): boolean;\n\n  /**\n   * Sets focus to a specific child element within the zone. This can be used in conjunction with\n   * shouldReceiveFocus to create delayed focus scenarios (like animate the scroll position to the correct\n   * location and then focus.)\n   * @param childElement - The child element within the zone to focus.\n   * @param forceAlignment - If true, focus alignment will be set according to the element provided.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  focusElement(childElement?: HTMLElement, forceAlignment?: boolean): boolean;\n\n  /**\n   * Forces horizontal alignment in the context of vertical arrowing to use specific point as the reference, rather\n   * than a center based on the last horizontal motion.\n   * @param point - the new reference point.\n   */\n  setFocusAlignment(point: Point): void;\n}\n\n/**\n * FocusZone component props.\n * {@docCategory FocusZone}\n */\nexport interface IFocusZoneProps extends React.HTMLAttributes<HTMLElement> {\n  /**\n   * Optional callback to access the IFocusZone interface. Use this instead of ref for accessing\n   * the public methods and properties of the component.\n   */\n  componentRef?: IRefObject<IFocusZone>;\n\n  /**\n   * Optional callback to access the root DOM element.\n   * @deprecated Temporary solution which will be replaced with ref in the V8 release.\n   */\n  elementRef?: React.Ref<HTMLElement>;\n\n  /**\n   * Additional class name to provide on the root element, in addition to the ms-FocusZone class.\n   */\n  className?: string;\n\n  /**\n   * Defines which arrows to react to.\n   * @defaultvalue FocusZoneDirection.bidirectional\n   */\n  direction?: FocusZoneDirection;\n\n  /**\n   * Optionally defines the initial tabbable element inside the FocusZone.\n   * If a string is passed then it is treated as a selector for identifying the initial tabbable element.\n   * If a function is passed then it uses the root element as a parameter to return the initial tabbable element.\n   */\n  defaultTabbableElement?: string | ((root: HTMLElement) => HTMLElement);\n\n  /**\n   * Optionally provide a selector for identifying the initial active element.\n   * @deprecated Use `defaultTabbableElement` instead.\n   */\n  defaultActiveElement?: string;\n\n  /**\n   * Determines if a default tabbable element should be force focused on FocusZone mount.\n   * @default false\n   */\n  shouldFocusOnMount?: boolean;\n\n  /**\n   * If set, the FocusZone will not be tabbable and keyboard navigation will be disabled.\n   * This does not affect disabled attribute of any child.\n   */\n  disabled?: boolean;\n\n  /**\n   * Element type the root element will use. Default is \"div\".\n   * @deprecated Use `as` instead.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  elementType?: any /* TODO should be `keyof React.ReactHTML`, tracking with https://github.com/Microsoft/TypeScript/issues/30050 */;\n\n  /**\n   * A component that should be used as the root element of the FocusZone component.\n   */\n  as?: React.ElementType;\n\n  /**\n   * If set, will cycle to the beginning of the targets once the user navigates to the\n   * next target while at the end, and to the end when navigate to the previous at the beginning.\n   */\n  isCircularNavigation?: boolean;\n\n  /**\n   * If provided, this callback will be executed on keypresses to determine if the user\n   * intends to navigate into the inner zone. Returning true will ask the first inner zone to\n   * set focus.\n   * @deprecated Use `shouldEnterInnerZone` instead.\n   */\n  isInnerZoneKeystroke?: (ev: React.KeyboardEvent<HTMLElement>) => boolean;\n\n  /**\n   * Callback function that will be executed on keypresses to determine if the user intends to navigate into\n   * the inner (nested) zone. Returning true will ask the first inner zone to set focus.\n   */\n  shouldEnterInnerZone?: (ev: React.KeyboardEvent<HTMLElement>) => boolean;\n\n  /**\n   * Sets the aria-labelledby attribute.\n   * @deprecated Directly use the `aria-labelledby` attribute instead\n   */\n  ariaLabelledBy?: string;\n\n  /**\n   * Sets the aria-describedby attribute.\n   * @deprecated Directly use the `aria-describedby` attribute instead\n   */\n  ariaDescribedBy?: string;\n\n  /**\n   * Callback for when one of immediate children elements gets active by getting focused\n   * or by having one of its respective children elements focused.\n   */\n  onActiveElementChanged?: (element?: HTMLElement, ev?: React.FocusEvent<HTMLElement>) => void;\n\n  /**\n   * @deprecated Div props provided to the FocusZone will be mixed into the root element.\n   * Deprecated at v1.12.1.\n   */\n  rootProps?: React.HTMLAttributes<HTMLDivElement>;\n\n  /**\n   * Callback method for determining if focus should indeed be set on the given element.\n   * @param element - The child element within the zone to focus.\n   * @returns True if focus should be set to the given element, false to avoid setting focus.\n   * @deprecated Use `shouldReceiveFocus` instead.\n   */\n  onBeforeFocus?: (childElement?: HTMLElement) => boolean;\n\n  /**\n   * Callback method for determining if focus should indeed be set on the given element.\n   * @param element - The child element within the zone to focus.\n   * @returns True if focus should be set to the given element, false to avoid setting focus.\n   */\n  shouldReceiveFocus?: (childElement?: HTMLElement) => boolean;\n\n  /** Allows focus to park on root when focus is in the `FocusZone` at render time. */\n  allowFocusRoot?: boolean;\n\n  /**\n   * Allows tab key to be handled to tab through a list of items in the focus zone,\n   * an unfortunate side effect is that users will not be able to tab out of the focus zone\n   * and have to hit escape or some other key.\n   * @deprecated Use `handleTabKey` instead.\n   *\n   */\n  allowTabKey?: boolean;\n\n  /**\n   * Allows tab key to be handled to tab through a list of items in the focus zone,\n   * an unfortunate side effect is that users will not be able to tab out of the focus zone\n   * and have to hit escape or some other key.\n   */\n  handleTabKey?: FocusZoneTabbableElements;\n\n  /**\n   * If true and FocusZone's root element (container) receives focus, the focus will land either on the\n   * defaultTabbableElement (if set) or on the first tabbable element of this FocusZone.\n   * Usually a case for nested focus zones, when the nested focus zone's container is a focusable element.\n   */\n  shouldFocusInnerElementWhenReceivedFocus?: boolean;\n\n  /**\n   * If true and TAB key is not handled by FocusZone, resets current active element to null value.\n   * For example, when roving index is not desirable and focus should always reset to the default tabbable element.\n   */\n  shouldResetActiveElementWhenTabFromZone?: boolean;\n\n  /**\n   * Determines whether the FocusZone will walk up the DOM trying to invoke click callbacks on focusable elements on\n   * Enter and Space keydowns to ensure accessibility for tags that don't guarantee this behavior.\n   * @defaultvalue true\n   */\n  shouldRaiseClicks?: boolean;\n\n  /**\n   * Relates to `shouldRaiseClicks`.\n   * Allows the click event raising for the \"Enter\" key to be set independently from `shouldRaiseClicks`.\n   * Inherits the value of `shouldRaiseClicks` if not set explicitly.\n   */\n  shouldRaiseClicksOnEnter?: boolean;\n\n  /**\n   * Relates to `shouldRaiseClicks`.\n   * Allows the click event raising for the \"Space\" key to be set independently from `shouldRaiseClicks`.\n   * Inherits the value of `shouldRaiseClicks` if not set explicitly.\n   */\n  shouldRaiseClicksOnSpace?: boolean;\n\n  /**\n   * A callback method to determine if an input or textarea element should lose focus on arrow keys\n   *  @param inputElement - The input or textarea element which is to lose focus.\n   *  @returns True if input element should loose focus or false otherwise.\n   */\n  shouldInputLoseFocusOnArrowKey?: (inputElement: HTMLInputElement | HTMLTextAreaElement) => boolean;\n\n  /**\n   * Determines whether to disable the paging support for Page Up and Page Down keyboard scenarios.\n   * @defaultvalue false\n   */\n  pagingSupportDisabled?: boolean;\n\n  /**\n   * Determines whether to check for data-no-horizontal-wrap or data-no-vertical-wrap attributes\n   * when determining how to move focus\n   * @defaultvalue false\n   */\n  checkForNoWrap?: boolean;\n\n  /**\n   * Whether the FocusZone should allow focus events to propagate past the FocusZone.\n   * @deprecated Use `stopFocusPropagation` instead.\n   */\n  doNotAllowFocusEventToPropagate?: boolean;\n\n  /**\n   * Whether the FocusZone should allow focus events to propagate past the FocusZone.\n   */\n  stopFocusPropagation?: boolean;\n\n  /**\n   * Callback to notify creators that focus has been set on the FocusZone\n   * @deprecated Use `onFocus` instead.\n   */\n  onFocusNotification?: () => void;\n\n  /**\n   * Callback called when \"focus\" event triggered in FocusZone.\n   * @param event - React's original FocusEvent.\n   */\n  onFocus?: (event: React.FocusEvent<HTMLElement>) => void;\n\n  /**\n   * If true, FocusZone prevents the default behavior of Keyboard events when changing focus between elements.\n   * @defaultvalue false\n   */\n  preventDefaultWhenHandled?: boolean;\n\n  /**\n   * If true, prevents the FocusZone from attempting to restore the focus to the inner element when the focus is on the\n   * root element after componentDidUpdate.\n   * @defaultvalue false\n   */\n  preventFocusRestoration?: boolean;\n}\n/**\n * {@docCategory FocusZone}\n */\nexport const FocusZoneTabbableElements = {\n  /** Tabbing is not allowed */\n  none: 0 as 0,\n\n  /** All tabbing action is allowed */\n  all: 1 as 1,\n\n  /** Tabbing is allowed only on input elements */\n  inputOnly: 2 as 2,\n};\n\n/**\n * {@docCategory FocusZone}\n */\nexport type FocusZoneTabbableElements = typeof FocusZoneTabbableElements[keyof typeof FocusZoneTabbableElements];\n\n/**\n * {@docCategory FocusZone}\n */\nexport enum FocusZoneDirection {\n  /** Only react to up/down arrows. */\n  vertical = 0,\n\n  /** Only react to left/right arrows. */\n  horizontal = 1,\n\n  /** React to all arrows. */\n  bidirectional = 2,\n\n  /**\n   * React to all arrows. Navigate next item in DOM on right/down arrow keys and previous - left/up arrow keys.\n   * Right and Left arrow keys are swapped in RTL mode.\n   */\n  domOrder = 3,\n}\n", "import * as React from 'react';\nimport { FocusZoneDirection, FocusZoneTabbableElements } from './FocusZone.types';\nimport {\n  KeyCodes,\n  css,\n  elementContains,\n  getDocument,\n  getElementIndexPath,\n  getFocusableByIndexPath,\n  getId,\n  getNativeProps,\n  getNextElement,\n  getParent,\n  getPreviousElement,\n  getRTL,\n  htmlElementProperties,\n  initializeComponentRef,\n  isElementFocusSubZone,\n  isElementFocusZone,\n  isElementTabbable,\n  shouldWrapFocus,\n  warnDeprecations,\n  portalContainsElement,\n  findScrollableParent,\n  createMergedRef,\n} from '@fluentui/utilities';\nimport { mergeStyles } from '@fluentui/merge-styles';\nimport { getTheme } from '@fluentui/style-utilities';\nimport type { IFocusZone, IFocusZoneProps } from './FocusZone.types';\nimport type { Point } from '@fluentui/utilities';\nimport type { ITheme } from '@fluentui/style-utilities';\n\nconst IS_FOCUSABLE_ATTRIBUTE = 'data-is-focusable';\nconst IS_ENTER_DISABLED_ATTRIBUTE = 'data-disable-click-on-enter';\nconst FOCUSZONE_ID_ATTRIBUTE = 'data-focuszone-id';\nconst TABINDEX = 'tabindex';\nconst NO_VERTICAL_WRAP = 'data-no-vertical-wrap';\nconst NO_HORIZONTAL_WRAP = 'data-no-horizontal-wrap';\nconst LARGE_DISTANCE_FROM_CENTER = 999999999;\nconst LARGE_NEGATIVE_DISTANCE_FROM_CENTER = -999999999;\n\nlet focusZoneStyles: string;\n\nconst focusZoneClass: string = 'ms-FocusZone';\n\n/**\n * Raises a click on a target element based on a keyboard event.\n */\nfunction raiseClickFromKeyboardEvent(target: Element, ev?: React.KeyboardEvent<HTMLElement>): void {\n  let event;\n  if (typeof MouseEvent === 'function') {\n    event = new MouseEvent('click', {\n      ctrlKey: ev?.ctrlKey,\n      metaKey: ev?.metaKey,\n      shiftKey: ev?.shiftKey,\n      altKey: ev?.altKey,\n      bubbles: ev?.bubbles,\n      cancelable: ev?.cancelable,\n    });\n  } else {\n    event = document.createEvent('MouseEvents');\n    event.initMouseEvent(\n      'click',\n      ev ? ev.bubbles : false,\n      ev ? ev.cancelable : false,\n      window, // not using getWindow() since this can only be run client side\n      0, // detail\n      0, // screen x\n      0, // screen y\n      0, // client x\n      0, // client y\n      ev ? ev.ctrlKey : false,\n      ev ? ev.altKey : false,\n      ev ? ev.shiftKey : false,\n      ev ? ev.metaKey : false,\n      0, // button\n      null, // relatedTarget\n    );\n  }\n\n  target.dispatchEvent(event);\n}\n\n// Helper function that will return a class for when the root is focused\nfunction getRootClass(): string {\n  if (!focusZoneStyles) {\n    focusZoneStyles = mergeStyles(\n      {\n        selectors: {\n          ':focus': {\n            outline: 'none',\n          },\n        },\n      },\n      focusZoneClass,\n    );\n  }\n  return focusZoneStyles;\n}\n\nconst _allInstances: {\n  [key: string]: FocusZone;\n} = {};\nconst _outerZones: Set<FocusZone> = new Set();\n\nconst ALLOWED_INPUT_TYPES = ['text', 'number', 'password', 'email', 'tel', 'url', 'search', 'textarea'];\n\nconst ALLOW_VIRTUAL_ELEMENTS = false;\n\nexport class FocusZone extends React.Component<IFocusZoneProps> implements IFocusZone {\n  public static defaultProps: IFocusZoneProps = {\n    isCircularNavigation: false,\n    direction: FocusZoneDirection.bidirectional,\n    shouldRaiseClicks: true,\n  };\n\n  private _root: React.RefObject<HTMLElement> = React.createRef();\n  private _mergedRef = createMergedRef<HTMLElement>();\n\n  private _id: string;\n\n  /** The most recently focused child element. */\n  private _activeElement: HTMLElement | null;\n\n  /**\n   * The index path to the last focused child element.\n   */\n  private _lastIndexPath: number[] | undefined;\n\n  /**\n   * Flag to define when we've intentionally parked focus on the root element to temporarily\n   * hold focus until items appear within the zone.\n   */\n  private _isParked: boolean;\n\n  /** The child element with tabindex=0. */\n  private _defaultFocusElement: HTMLElement | null;\n  private _focusAlignment: Point;\n  private _isInnerZone: boolean;\n  private _parkedTabIndex: string | null | undefined;\n\n  /** Used to allow moving to next focusable element even when we're focusing on a input element when pressing tab */\n  private _processingTabKey: boolean;\n\n  /** Provides granular control over `shouldRaiseClicks` and should be preferred over `props.shouldRaiseClicks`. */\n  private _shouldRaiseClicksOnEnter: boolean;\n  private _shouldRaiseClicksOnSpace: boolean;\n\n  /** Used for testing purposes only. */\n  public static getOuterZones(): number {\n    return _outerZones.size;\n  }\n\n  /**\n   * Handle global tab presses so that we can patch tabindexes on the fly.\n   * HEADS UP: This must not be an arrow function in order to be referentially equal among instances\n   * for ref counting to work correctly!\n   */\n  private static _onKeyDownCapture(ev: KeyboardEvent): void {\n    // eslint-disable-next-line deprecation/deprecation, @fluentui/deprecated-keyboard-event-props\n    if (ev.which === KeyCodes.tab) {\n      _outerZones.forEach((zone: FocusZone) => zone._updateTabIndexes());\n    }\n  }\n\n  constructor(props: IFocusZoneProps) {\n    super(props);\n    // Manage componentRef resolution.\n    initializeComponentRef(this);\n\n    if (process.env.NODE_ENV !== 'production') {\n      warnDeprecations('FocusZone', props, {\n        rootProps: undefined,\n        allowTabKey: 'handleTabKey',\n        elementType: 'as',\n        ariaDescribedBy: 'aria-describedby',\n        ariaLabelledBy: 'aria-labelledby',\n      });\n    }\n\n    this._id = getId('FocusZone');\n\n    this._focusAlignment = {\n      left: 0,\n      top: 0,\n    };\n\n    this._processingTabKey = false;\n\n    const shouldRaiseClicksFallback = props.shouldRaiseClicks ?? FocusZone.defaultProps.shouldRaiseClicks ?? true;\n    this._shouldRaiseClicksOnEnter = props.shouldRaiseClicksOnEnter ?? shouldRaiseClicksFallback;\n    this._shouldRaiseClicksOnSpace = props.shouldRaiseClicksOnSpace ?? shouldRaiseClicksFallback;\n  }\n\n  public componentDidMount(): void {\n    const { current: root } = this._root;\n\n    _allInstances[this._id] = this;\n\n    if (root) {\n      let parentElement = getParent(root, ALLOW_VIRTUAL_ELEMENTS);\n\n      while (parentElement && parentElement !== this._getDocument().body && parentElement.nodeType === 1) {\n        if (isElementFocusZone(parentElement)) {\n          this._isInnerZone = true;\n          break;\n        }\n        parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);\n      }\n\n      if (!this._isInnerZone) {\n        _outerZones.add(this);\n\n        this._root.current && this._root.current.addEventListener('keydown', FocusZone._onKeyDownCapture, true);\n      }\n\n      this._root.current && this._root.current.addEventListener('blur', this._onBlur, true);\n\n      // Assign initial tab indexes so that we can set initial focus as appropriate.\n      this._updateTabIndexes();\n\n      if (this.props.defaultTabbableElement && typeof this.props.defaultTabbableElement === 'string') {\n        this._activeElement = this._getDocument().querySelector(this.props.defaultTabbableElement) as HTMLElement;\n        // eslint-disable-next-line deprecation/deprecation\n      } else if (this.props.defaultActiveElement) {\n        // eslint-disable-next-line deprecation/deprecation\n        this._activeElement = this._getDocument().querySelector(this.props.defaultActiveElement) as HTMLElement;\n      }\n\n      if (this.props.shouldFocusOnMount) {\n        this.focus();\n      }\n    }\n  }\n\n  public componentDidUpdate(): void {\n    const { current: root } = this._root;\n    const doc = this._getDocument();\n\n    // If either _activeElement or _defaultFocusElement are no longer contained by _root,\n    // reset those variables (and update tab indexes) to avoid memory leaks\n    if (\n      (this._activeElement && !elementContains(this._root.current, this._activeElement, ALLOW_VIRTUAL_ELEMENTS)) ||\n      (this._defaultFocusElement &&\n        !elementContains(this._root.current, this._defaultFocusElement, ALLOW_VIRTUAL_ELEMENTS))\n    ) {\n      this._activeElement = null;\n      this._defaultFocusElement = null;\n      this._updateTabIndexes();\n    }\n\n    if (\n      !this.props.preventFocusRestoration &&\n      doc &&\n      this._lastIndexPath &&\n      (doc.activeElement === doc.body || doc.activeElement === null || doc.activeElement === root)\n    ) {\n      // The element has been removed after the render, attempt to restore focus.\n      const elementToFocus = getFocusableByIndexPath(root as HTMLElement, this._lastIndexPath);\n\n      if (elementToFocus) {\n        this._setActiveElement(elementToFocus, true);\n        elementToFocus.focus();\n        this._setParkedFocus(false);\n      } else {\n        // We had a focus path to restore, but now that path is unresolvable. Park focus\n        // on the container until we can try again.\n        this._setParkedFocus(true);\n      }\n    }\n  }\n\n  public componentWillUnmount(): void {\n    delete _allInstances[this._id];\n\n    if (!this._isInnerZone) {\n      _outerZones.delete(this);\n\n      this._root.current && this._root.current.removeEventListener('keydown', FocusZone._onKeyDownCapture, true);\n    }\n\n    if (this._root.current) {\n      this._root.current.removeEventListener('blur', this._onBlur, true);\n    }\n\n    this._activeElement = null;\n    this._defaultFocusElement = null;\n  }\n\n  public render(): React.ReactNode {\n    // eslint-disable-next-line deprecation/deprecation\n    const { as: tag, elementType, rootProps, ariaDescribedBy, ariaLabelledBy, className } = this.props;\n    const divProps = getNativeProps(this.props, htmlElementProperties);\n\n    const Tag = tag || elementType || 'div';\n\n    // Note, right before rendering/reconciling proceeds, we need to record if focus\n    // was in the zone before the update. This helper will track this and, if focus\n    // was actually in the zone, what the index path to the element is at this time.\n    // Then, later in componentDidUpdate, we can evaluate if we need to restore it in\n    // the case the element was removed.\n    this._evaluateFocusBeforeRender();\n\n    // Only support RTL defined in global theme, not contextual theme/RTL.\n    const theme: ITheme = getTheme();\n\n    return (\n      <Tag\n        aria-labelledby={ariaLabelledBy}\n        aria-describedby={ariaDescribedBy}\n        {...divProps}\n        {\n          // root props has been deprecated and should get removed.\n          // it needs to be marked as \"any\" since root props expects a div element, but really Tag can\n          // be any native element so typescript rightly flags this as a problem.\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          ...(rootProps as any)\n        }\n        // Once the getClassName correctly memoizes inputs this should\n        // be replaced so that className is passed to getRootClass and is included there so\n        // the class names will always be in the same order.\n        className={css(getRootClass(), className)}\n        // eslint-disable-next-line deprecation/deprecation\n        ref={this._mergedRef(this.props.elementRef, this._root)}\n        data-focuszone-id={this._id}\n        // eslint-disable-next-line react/jsx-no-bind\n        onKeyDown={(ev: React.KeyboardEvent<HTMLElement>) => this._onKeyDown(ev, theme)}\n        onFocus={this._onFocus}\n        onMouseDownCapture={this._onMouseDown}\n      >\n        {this.props.children}\n      </Tag>\n    );\n  }\n\n  /**\n   * Sets focus to the first tabbable item in the zone.\n   * @param forceIntoFirstElement - If true, focus will be forced into the first element, even\n   * if focus is already in the focus zone.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  public focus(forceIntoFirstElement: boolean = false): boolean {\n    if (this._root.current) {\n      if (\n        !forceIntoFirstElement &&\n        this._root.current.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true' &&\n        this._isInnerZone\n      ) {\n        const ownerZoneElement = this._getOwnerZone(this._root.current) as HTMLElement;\n\n        if (ownerZoneElement !== this._root.current) {\n          const ownerZone = _allInstances[ownerZoneElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE) as string];\n\n          return !!ownerZone && ownerZone.focusElement(this._root.current);\n        }\n\n        return false;\n      } else if (\n        !forceIntoFirstElement &&\n        this._activeElement &&\n        elementContains(this._root.current, this._activeElement) &&\n        isElementTabbable(this._activeElement)\n      ) {\n        this._activeElement.focus();\n        return true;\n      } else {\n        const firstChild = this._root.current.firstChild as HTMLElement;\n\n        return this.focusElement(getNextElement(this._root.current, firstChild, true) as HTMLElement);\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Sets focus to the last tabbable item in the zone.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  public focusLast(): boolean {\n    if (this._root.current) {\n      const lastChild = this._root.current && (this._root.current.lastChild as HTMLElement | null);\n\n      return this.focusElement(getPreviousElement(this._root.current, lastChild, true, true, true) as HTMLElement);\n    }\n\n    return false;\n  }\n\n  /**\n   * Sets focus to a specific child element within the zone. This can be used in conjunction with\n   * shouldReceiveFocus to create delayed focus scenarios (like animate the scroll position to the correct\n   * location and then focus.)\n   * @param element - The child element within the zone to focus.\n   * @param forceAlignment - If true, focus alignment will be set according to the element provided.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  public focusElement(element: HTMLElement, forceAlignment?: boolean): boolean {\n    // eslint-disable-next-line deprecation/deprecation\n    const { onBeforeFocus, shouldReceiveFocus } = this.props;\n\n    if ((shouldReceiveFocus && !shouldReceiveFocus(element)) || (onBeforeFocus && !onBeforeFocus(element))) {\n      return false;\n    }\n\n    if (element) {\n      // when we set focus to a specific child, we should recalculate the alignment depending on its position.\n      this._setActiveElement(element, forceAlignment);\n      if (this._activeElement) {\n        this._activeElement.focus();\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Forces horizontal alignment in the context of vertical arrowing to use specific point as the reference,\n   * rather than a center based on the last horizontal motion.\n   * @param point - the new reference point.\n   */\n  public setFocusAlignment(point: Point): void {\n    this._focusAlignment = point;\n  }\n\n  public get defaultFocusElement() {\n    return this._defaultFocusElement;\n  }\n\n  public get activeElement() {\n    return this._activeElement;\n  }\n\n  private _evaluateFocusBeforeRender(): void {\n    const { current: root } = this._root;\n\n    const doc = this._getDocument();\n    if (doc) {\n      const focusedElement = doc.activeElement as HTMLElement;\n\n      // Only update the index path if we are not parked on the root.\n      if (focusedElement !== root) {\n        const shouldRestoreFocus = elementContains(root, focusedElement, false);\n        this._lastIndexPath = shouldRestoreFocus ? getElementIndexPath(root as HTMLElement, focusedElement) : undefined;\n      }\n    }\n  }\n\n  private _onFocus = (ev: React.FocusEvent<HTMLElement>): void => {\n    if (this._portalContainsElement(ev.target as HTMLElement)) {\n      // If the event target is inside a portal do not process the event.\n      return;\n    }\n\n    const {\n      onActiveElementChanged,\n      // eslint-disable-next-line deprecation/deprecation\n      doNotAllowFocusEventToPropagate,\n      stopFocusPropagation,\n      // eslint-disable-next-line deprecation/deprecation\n      onFocusNotification,\n      onFocus,\n      shouldFocusInnerElementWhenReceivedFocus,\n      defaultTabbableElement,\n    } = this.props;\n    const isImmediateDescendant = this._isImmediateDescendantOfZone(ev.target as HTMLElement);\n    let newActiveElement: HTMLElement | null | undefined;\n\n    if (isImmediateDescendant) {\n      newActiveElement = ev.target as HTMLElement;\n    } else {\n      let parentElement = ev.target as HTMLElement;\n\n      while (parentElement && parentElement !== this._root.current) {\n        if (isElementTabbable(parentElement) && this._isImmediateDescendantOfZone(parentElement)) {\n          newActiveElement = parentElement;\n          break;\n        }\n        parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS) as HTMLElement;\n      }\n    }\n\n    // If an inner focusable element should be focused when FocusZone container receives focus\n    if (shouldFocusInnerElementWhenReceivedFocus && ev.target === this._root.current) {\n      const maybeElementToFocus =\n        defaultTabbableElement &&\n        typeof defaultTabbableElement === 'function' &&\n        this._root.current &&\n        defaultTabbableElement(this._root.current);\n\n      // try to focus defaultTabbable element\n      if (maybeElementToFocus && isElementTabbable(maybeElementToFocus)) {\n        newActiveElement = maybeElementToFocus;\n        maybeElementToFocus.focus();\n      } else {\n        // force focus on first focusable element\n        this.focus(true);\n        if (this._activeElement) {\n          // set to null as new active element was handled in method above\n          newActiveElement = null;\n        }\n      }\n    }\n\n    const initialElementFocused = !this._activeElement;\n\n    // If the new active element is a child of this zone and received focus,\n    // update alignment an immediate descendant\n    if (newActiveElement && newActiveElement !== this._activeElement) {\n      if (isImmediateDescendant || initialElementFocused) {\n        this._setFocusAlignment(newActiveElement, true, true);\n      }\n\n      this._activeElement = newActiveElement;\n\n      if (initialElementFocused) {\n        this._updateTabIndexes();\n      }\n    }\n\n    if (onActiveElementChanged) {\n      onActiveElementChanged(this._activeElement as HTMLElement, ev);\n    }\n\n    if (stopFocusPropagation || doNotAllowFocusEventToPropagate) {\n      ev.stopPropagation();\n    }\n\n    if (onFocus) {\n      onFocus(ev);\n    } else if (onFocusNotification) {\n      onFocusNotification();\n    }\n  };\n\n  /**\n   * When focus is in the zone at render time but then all focusable elements are removed,\n   * we \"park\" focus temporarily on the root. Once we update with focusable children, we restore\n   * focus to the closest path from previous. If the user tabs away from the parked container,\n   * we restore focusability to the pre-parked state.\n   */\n  private _setParkedFocus(isParked: boolean): void {\n    const { current: root } = this._root;\n\n    if (root && this._isParked !== isParked) {\n      this._isParked = isParked;\n\n      if (isParked) {\n        if (!this.props.allowFocusRoot) {\n          this._parkedTabIndex = root.getAttribute('tabindex');\n          root.setAttribute('tabindex', '-1');\n        }\n        root.focus();\n      } else if (!this.props.allowFocusRoot) {\n        if (this._parkedTabIndex) {\n          root.setAttribute('tabindex', this._parkedTabIndex);\n          this._parkedTabIndex = undefined;\n        } else {\n          root.removeAttribute('tabindex');\n        }\n      }\n    }\n  }\n\n  private _onBlur = (): void => {\n    this._setParkedFocus(false);\n  };\n\n  private _onMouseDown = (ev: React.MouseEvent<HTMLElement>): void => {\n    if (this._portalContainsElement(ev.target as HTMLElement)) {\n      // If the event target is inside a portal do not process the event.\n      return;\n    }\n\n    const { disabled } = this.props;\n\n    if (disabled) {\n      return;\n    }\n\n    let target = ev.target as HTMLElement;\n    const path = [];\n\n    while (target && target !== this._root.current) {\n      path.push(target);\n      target = getParent(target, ALLOW_VIRTUAL_ELEMENTS) as HTMLElement;\n    }\n\n    while (path.length) {\n      target = path.pop() as HTMLElement;\n\n      if (target && isElementTabbable(target)) {\n        this._setActiveElement(target, true);\n      }\n\n      if (isElementFocusZone(target)) {\n        // Stop here since the focus zone will take care of its own children.\n        break;\n      }\n    }\n  };\n\n  private _setActiveElement(element: HTMLElement, forceAlignment?: boolean): void {\n    const previousActiveElement = this._activeElement;\n\n    this._activeElement = element;\n\n    if (previousActiveElement) {\n      if (isElementFocusZone(previousActiveElement)) {\n        this._updateTabIndexes(previousActiveElement);\n      }\n\n      previousActiveElement.tabIndex = -1;\n    }\n\n    if (this._activeElement) {\n      if (!this._focusAlignment || forceAlignment) {\n        this._setFocusAlignment(element, true, true);\n      }\n\n      this._activeElement.tabIndex = 0;\n    }\n  }\n\n  private _preventDefaultWhenHandled(ev: React.KeyboardEvent<HTMLElement>): void {\n    this.props.preventDefaultWhenHandled && ev.preventDefault();\n  }\n\n  /**\n   * Handle the keystrokes.\n   */\n  private _onKeyDown = (ev: React.KeyboardEvent<HTMLElement>, theme: ITheme): boolean | undefined => {\n    if (this._portalContainsElement(ev.target as HTMLElement)) {\n      // If the event target is inside a portal do not process the event.\n      return;\n    }\n\n    // eslint-disable-next-line deprecation/deprecation\n    const { direction, disabled, isInnerZoneKeystroke, pagingSupportDisabled, shouldEnterInnerZone } = this.props;\n\n    if (disabled) {\n      return;\n    }\n\n    if (this.props.onKeyDown) {\n      this.props.onKeyDown(ev);\n    }\n\n    // If the default has been prevented, do not process keyboard events.\n    if (ev.isDefaultPrevented()) {\n      return;\n    }\n\n    if (this._getDocument().activeElement === this._root.current && this._isInnerZone) {\n      // If this element has focus, it is being controlled by a parent.\n      // Ignore the keystroke.\n      return;\n    }\n\n    if (\n      ((shouldEnterInnerZone && shouldEnterInnerZone(ev)) || (isInnerZoneKeystroke && isInnerZoneKeystroke(ev))) &&\n      this._isImmediateDescendantOfZone(ev.target as HTMLElement)\n    ) {\n      // Try to focus\n      const innerZone = this._getFirstInnerZone();\n\n      if (innerZone) {\n        if (!innerZone.focus(true)) {\n          return;\n        }\n      } else if (isElementFocusSubZone(ev.target as HTMLElement)) {\n        if (\n          !this.focusElement(\n            getNextElement(\n              ev.target as HTMLElement,\n              (ev.target as HTMLElement).firstChild as HTMLElement,\n              true,\n            ) as HTMLElement,\n          )\n        ) {\n          return;\n        }\n      } else {\n        return;\n      }\n    } else if (ev.altKey) {\n      return;\n    } else {\n      // eslint-disable-next-line @fluentui/deprecated-keyboard-event-props, deprecation/deprecation\n      switch (ev.which) {\n        case KeyCodes.space:\n          if (this._shouldRaiseClicksOnSpace && this._tryInvokeClickForFocusable(ev.target as HTMLElement, ev)) {\n            break;\n          }\n          return;\n\n        case KeyCodes.left:\n          if (direction !== FocusZoneDirection.vertical) {\n            this._preventDefaultWhenHandled(ev);\n            if (this._moveFocusLeft(theme)) {\n              break;\n            }\n          }\n          return;\n\n        case KeyCodes.right:\n          if (direction !== FocusZoneDirection.vertical) {\n            this._preventDefaultWhenHandled(ev);\n            if (this._moveFocusRight(theme)) {\n              break;\n            }\n          }\n          return;\n\n        case KeyCodes.up:\n          if (direction !== FocusZoneDirection.horizontal) {\n            this._preventDefaultWhenHandled(ev);\n            if (this._moveFocusUp()) {\n              break;\n            }\n          }\n          return;\n\n        case KeyCodes.down:\n          if (direction !== FocusZoneDirection.horizontal) {\n            this._preventDefaultWhenHandled(ev);\n            if (this._moveFocusDown()) {\n              break;\n            }\n          }\n          return;\n        case KeyCodes.pageDown:\n          if (!pagingSupportDisabled && this._moveFocusPaging(true)) {\n            break;\n          }\n          return;\n        case KeyCodes.pageUp:\n          if (!pagingSupportDisabled && this._moveFocusPaging(false)) {\n            break;\n          }\n          return;\n\n        case KeyCodes.tab:\n          if (\n            // eslint-disable-next-line deprecation/deprecation\n            this.props.allowTabKey ||\n            this.props.handleTabKey === FocusZoneTabbableElements.all ||\n            (this.props.handleTabKey === FocusZoneTabbableElements.inputOnly &&\n              this._isElementInput(ev.target as HTMLElement))\n          ) {\n            let focusChanged = false;\n            this._processingTabKey = true;\n            if (\n              direction === FocusZoneDirection.vertical ||\n              !this._shouldWrapFocus(this._activeElement as HTMLElement, NO_HORIZONTAL_WRAP)\n            ) {\n              focusChanged = ev.shiftKey ? this._moveFocusUp() : this._moveFocusDown();\n            } else {\n              const tabWithDirection = getRTL(theme) ? !ev.shiftKey : ev.shiftKey;\n              focusChanged = tabWithDirection ? this._moveFocusLeft(theme) : this._moveFocusRight(theme);\n            }\n            this._processingTabKey = false;\n            if (focusChanged) {\n              break;\n            } else if (this.props.shouldResetActiveElementWhenTabFromZone) {\n              this._activeElement = null;\n            }\n          }\n          return;\n\n        case KeyCodes.home:\n          if (\n            this._isContentEditableElement(ev.target as HTMLElement) ||\n            (this._isElementInput(ev.target as HTMLElement) &&\n              !this._shouldInputLoseFocus(ev.target as HTMLInputElement, false))\n          ) {\n            return false;\n          }\n          const firstChild = this._root.current && (this._root.current.firstChild as HTMLElement | null);\n          if (\n            this._root.current &&\n            firstChild &&\n            this.focusElement(getNextElement(this._root.current, firstChild, true) as HTMLElement)\n          ) {\n            break;\n          }\n          return;\n\n        case KeyCodes.end:\n          if (\n            this._isContentEditableElement(ev.target as HTMLElement) ||\n            (this._isElementInput(ev.target as HTMLElement) &&\n              !this._shouldInputLoseFocus(ev.target as HTMLInputElement, true))\n          ) {\n            return false;\n          }\n\n          const lastChild = this._root.current && (this._root.current.lastChild as HTMLElement | null);\n          if (\n            this._root.current &&\n            this.focusElement(getPreviousElement(this._root.current, lastChild, true, true, true) as HTMLElement)\n          ) {\n            break;\n          }\n          return;\n\n        case KeyCodes.enter:\n          if (this._shouldRaiseClicksOnEnter && this._tryInvokeClickForFocusable(ev.target as HTMLElement, ev)) {\n            break;\n          }\n          return;\n\n        default:\n          return;\n      }\n    }\n\n    ev.preventDefault();\n    ev.stopPropagation();\n  };\n\n  /**\n   * Walk up the dom try to find a focusable element.\n   */\n  private _tryInvokeClickForFocusable(targetElement: HTMLElement, ev?: React.KeyboardEvent<HTMLElement>): boolean {\n    let target = targetElement;\n    if (target === this._root.current) {\n      return false;\n    }\n\n    do {\n      if (\n        target.tagName === 'BUTTON' ||\n        target.tagName === 'A' ||\n        target.tagName === 'INPUT' ||\n        target.tagName === 'TEXTAREA'\n      ) {\n        return false;\n      }\n\n      if (\n        this._isImmediateDescendantOfZone(target) &&\n        target.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true' &&\n        target.getAttribute(IS_ENTER_DISABLED_ATTRIBUTE) !== 'true'\n      ) {\n        raiseClickFromKeyboardEvent(target, ev);\n        return true;\n      }\n\n      target = getParent(target, ALLOW_VIRTUAL_ELEMENTS) as HTMLElement;\n    } while (target !== this._root.current);\n\n    return false;\n  }\n\n  /**\n   * Traverse to find first child zone.\n   */\n  private _getFirstInnerZone(rootElement?: HTMLElement | null): FocusZone | null {\n    rootElement = rootElement || this._activeElement || this._root.current;\n\n    if (!rootElement) {\n      return null;\n    }\n\n    if (isElementFocusZone(rootElement)) {\n      return _allInstances[rootElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE) as string];\n    }\n\n    let child = rootElement.firstElementChild as HTMLElement | null;\n\n    while (child) {\n      if (isElementFocusZone(child)) {\n        return _allInstances[child.getAttribute(FOCUSZONE_ID_ATTRIBUTE) as string];\n      }\n      const match = this._getFirstInnerZone(child);\n\n      if (match) {\n        return match;\n      }\n\n      child = child.nextElementSibling as HTMLElement | null;\n    }\n\n    return null;\n  }\n\n  private _moveFocus(\n    isForward: boolean,\n    getDistanceFromCenter: (activeRect: ClientRect, targetRect: ClientRect) => number,\n    ev?: Event,\n    useDefaultWrap: boolean = true,\n  ): boolean {\n    let element = this._activeElement;\n    let candidateDistance = -1;\n    let candidateElement: HTMLElement | undefined = undefined;\n    let changedFocus = false;\n    const isBidirectional = this.props.direction === FocusZoneDirection.bidirectional;\n\n    if (!element || !this._root.current) {\n      return false;\n    }\n\n    if (this._isElementInput(element)) {\n      if (!this._shouldInputLoseFocus(element as HTMLInputElement, isForward)) {\n        return false;\n      }\n    }\n\n    const activeRect = isBidirectional ? element.getBoundingClientRect() : null;\n\n    do {\n      element = (isForward\n        ? getNextElement(this._root.current, element)\n        : getPreviousElement(this._root.current, element)) as HTMLElement;\n\n      if (isBidirectional) {\n        if (element) {\n          const targetRect = element.getBoundingClientRect();\n          const elementDistance = getDistanceFromCenter(activeRect as ClientRect, targetRect);\n\n          if (elementDistance === -1 && candidateDistance === -1) {\n            candidateElement = element;\n            break;\n          }\n\n          if (elementDistance > -1 && (candidateDistance === -1 || elementDistance < candidateDistance)) {\n            candidateDistance = elementDistance;\n            candidateElement = element;\n          }\n\n          if (candidateDistance >= 0 && elementDistance < 0) {\n            break;\n          }\n        }\n      } else {\n        candidateElement = element;\n        break;\n      }\n    } while (element);\n\n    // Focus the closest candidate\n    if (candidateElement && candidateElement !== this._activeElement) {\n      changedFocus = true;\n      this.focusElement(candidateElement);\n    } else if (this.props.isCircularNavigation && useDefaultWrap) {\n      if (isForward) {\n        return this.focusElement(\n          getNextElement(this._root.current, this._root.current.firstElementChild as HTMLElement, true) as HTMLElement,\n        );\n      } else {\n        return this.focusElement(\n          getPreviousElement(\n            this._root.current,\n            this._root.current.lastElementChild as HTMLElement,\n            true,\n            true,\n            true,\n          ) as HTMLElement,\n        );\n      }\n    }\n\n    return changedFocus;\n  }\n\n  private _moveFocusDown(): boolean {\n    let targetTop = -1;\n    // eslint-disable-next-line deprecation/deprecation\n    const leftAlignment = this._focusAlignment.left || this._focusAlignment.x || 0;\n\n    if (\n      this._moveFocus(true, (activeRect: ClientRect, targetRect: ClientRect) => {\n        let distance = -1;\n        // ClientRect values can be floats that differ by very small fractions of a decimal.\n        // If the difference between top and bottom are within a pixel then we should treat\n        // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,\n        // but without Math.Floor they will be handled incorrectly.\n        const targetRectTop = Math.floor(targetRect.top);\n        const activeRectBottom = Math.floor(activeRect.bottom);\n\n        if (targetRectTop < activeRectBottom) {\n          if (!this._shouldWrapFocus(this._activeElement as HTMLElement, NO_VERTICAL_WRAP)) {\n            return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n          }\n\n          return LARGE_DISTANCE_FROM_CENTER;\n        }\n\n        if ((targetTop === -1 && targetRectTop >= activeRectBottom) || targetRectTop === targetTop) {\n          targetTop = targetRectTop;\n          if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {\n            distance = 0;\n          } else {\n            distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);\n          }\n        }\n\n        return distance;\n      })\n    ) {\n      this._setFocusAlignment(this._activeElement as HTMLElement, false, true);\n      return true;\n    }\n\n    return false;\n  }\n\n  private _moveFocusUp(): boolean {\n    let targetTop = -1;\n    // eslint-disable-next-line deprecation/deprecation\n    const leftAlignment = this._focusAlignment.left || this._focusAlignment.x || 0;\n\n    if (\n      this._moveFocus(false, (activeRect: ClientRect, targetRect: ClientRect) => {\n        let distance = -1;\n        // ClientRect values can be floats that differ by very small fractions of a decimal.\n        // If the difference between top and bottom are within a pixel then we should treat\n        // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,\n        // but without Math.Floor they will be handled incorrectly.\n        const targetRectBottom = Math.floor(targetRect.bottom);\n        const targetRectTop = Math.floor(targetRect.top);\n        const activeRectTop = Math.floor(activeRect.top);\n\n        if (targetRectBottom > activeRectTop) {\n          if (!this._shouldWrapFocus(this._activeElement as HTMLElement, NO_VERTICAL_WRAP)) {\n            return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n          }\n          return LARGE_DISTANCE_FROM_CENTER;\n        }\n\n        if ((targetTop === -1 && targetRectBottom <= activeRectTop) || targetRectTop === targetTop) {\n          targetTop = targetRectTop;\n          if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {\n            distance = 0;\n          } else {\n            distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);\n          }\n        }\n\n        return distance;\n      })\n    ) {\n      this._setFocusAlignment(this._activeElement as HTMLElement, false, true);\n      return true;\n    }\n\n    return false;\n  }\n\n  private _moveFocusLeft(theme: ITheme): boolean {\n    const shouldWrap = this._shouldWrapFocus(this._activeElement as HTMLElement, NO_HORIZONTAL_WRAP);\n    if (\n      this._moveFocus(\n        getRTL(theme),\n        (activeRect: ClientRect, targetRect: ClientRect) => {\n          let distance = -1;\n          let topBottomComparison;\n\n          if (getRTL(theme)) {\n            // When in RTL, this comparison should be the same as the one in _moveFocusRight for LTR.\n            // Going left at a leftmost rectangle will go down a line instead of up a line like in LTR.\n            // This is important, because we want to be comparing the top of the target rect\n            // with the bottom of the active rect.\n            topBottomComparison = parseFloat(targetRect.top.toFixed(3)) < parseFloat(activeRect.bottom.toFixed(3));\n          } else {\n            topBottomComparison = parseFloat(targetRect.bottom.toFixed(3)) > parseFloat(activeRect.top.toFixed(3));\n          }\n\n          if (\n            topBottomComparison &&\n            targetRect.right <= activeRect.right &&\n            this.props.direction !== FocusZoneDirection.vertical\n          ) {\n            distance = activeRect.right - targetRect.right;\n          } else if (!shouldWrap) {\n            distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n          }\n\n          return distance;\n        },\n        undefined /*ev*/,\n        shouldWrap,\n      )\n    ) {\n      this._setFocusAlignment(this._activeElement as HTMLElement, true, false);\n      return true;\n    }\n\n    return false;\n  }\n\n  private _moveFocusRight(theme: ITheme): boolean {\n    const shouldWrap = this._shouldWrapFocus(this._activeElement as HTMLElement, NO_HORIZONTAL_WRAP);\n    if (\n      this._moveFocus(\n        !getRTL(theme),\n        (activeRect: ClientRect, targetRect: ClientRect) => {\n          let distance = -1;\n          let topBottomComparison;\n\n          if (getRTL(theme)) {\n            // When in RTL, this comparison should be the same as the one in _moveFocusLeft for LTR.\n            // Going right at a rightmost rectangle will go up a line instead of down a line like in LTR.\n            // This is important, because we want to be comparing the bottom of the target rect\n            // with the top of the active rect.\n            topBottomComparison = parseFloat(targetRect.bottom.toFixed(3)) > parseFloat(activeRect.top.toFixed(3));\n          } else {\n            topBottomComparison = parseFloat(targetRect.top.toFixed(3)) < parseFloat(activeRect.bottom.toFixed(3));\n          }\n\n          if (\n            topBottomComparison &&\n            targetRect.left >= activeRect.left &&\n            this.props.direction !== FocusZoneDirection.vertical\n          ) {\n            distance = targetRect.left - activeRect.left;\n          } else if (!shouldWrap) {\n            distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n          }\n\n          return distance;\n        },\n        undefined /*ev*/,\n        shouldWrap,\n      )\n    ) {\n      this._setFocusAlignment(this._activeElement as HTMLElement, true, false);\n      return true;\n    }\n\n    return false;\n  }\n\n  private _getHorizontalDistanceFromCenter = (\n    isForward: boolean,\n    activeRect: ClientRect,\n    targetRect: ClientRect,\n  ): number => {\n    // eslint-disable-next-line deprecation/deprecation\n    const leftAlignment = this._focusAlignment.left || this._focusAlignment.x || 0;\n    // ClientRect values can be floats that differ by very small fractions of a decimal.\n    // If the difference between top and bottom are within a pixel then we should treat\n    // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,\n    // but without Math.Floor they will be handled incorrectly.\n    const targetRectTop = Math.floor(targetRect.top);\n    const activeRectBottom = Math.floor(activeRect.bottom);\n    const targetRectBottom = Math.floor(targetRect.bottom);\n    const activeRectTop = Math.floor(activeRect.top);\n    const isValidCandidateOnpagingDown = isForward && targetRectTop > activeRectBottom;\n    const isValidCandidateOnpagingUp = !isForward && targetRectBottom < activeRectTop;\n\n    if (isValidCandidateOnpagingDown || isValidCandidateOnpagingUp) {\n      if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {\n        return 0;\n      }\n      return Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);\n    }\n\n    if (!this._shouldWrapFocus(this._activeElement as HTMLElement, NO_VERTICAL_WRAP)) {\n      return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n    }\n    return LARGE_DISTANCE_FROM_CENTER;\n  };\n\n  private _moveFocusPaging(isForward: boolean, useDefaultWrap: boolean = true): boolean {\n    let element = this._activeElement;\n    if (!element || !this._root.current) {\n      return false;\n    }\n    if (this._isElementInput(element)) {\n      if (!this._shouldInputLoseFocus(element as HTMLInputElement, isForward)) {\n        return false;\n      }\n    }\n    const scrollableParent = findScrollableParent(element);\n    if (!scrollableParent) {\n      return false;\n    }\n    let candidateDistance = -1;\n    let candidateElement = undefined;\n    let targetTop = -1;\n    let targetBottom = -1;\n    const pagesize = (scrollableParent as HTMLElement).clientHeight;\n    const activeRect = element.getBoundingClientRect();\n    do {\n      element = isForward\n        ? getNextElement(this._root.current, element)\n        : getPreviousElement(this._root.current, element);\n      if (element) {\n        const targetRect = element.getBoundingClientRect();\n        const targetRectTop = Math.floor(targetRect.top);\n        const activeRectBottom = Math.floor(activeRect.bottom);\n        const targetRectBottom = Math.floor(targetRect.bottom);\n        const activeRectTop = Math.floor(activeRect.top);\n        const elementDistance = this._getHorizontalDistanceFromCenter(isForward, activeRect, targetRect);\n        const isElementPassedPageSizeOnPagingDown = isForward && targetRectTop > activeRectBottom + pagesize;\n        const isElementPassedPageSizeOnPagingUp = !isForward && targetRectBottom < activeRectTop - pagesize;\n\n        if (isElementPassedPageSizeOnPagingDown || isElementPassedPageSizeOnPagingUp) {\n          break;\n        }\n        if (elementDistance > -1) {\n          // for paging down\n          if (isForward && targetRectTop > targetTop) {\n            targetTop = targetRectTop;\n            candidateDistance = elementDistance;\n            candidateElement = element;\n          } else if (!isForward && targetRectBottom < targetBottom) {\n            // for paging up\n            targetBottom = targetRectBottom;\n            candidateDistance = elementDistance;\n            candidateElement = element;\n          } else if (candidateDistance === -1 || elementDistance <= candidateDistance) {\n            candidateDistance = elementDistance;\n            candidateElement = element;\n          }\n        }\n      }\n    } while (element);\n\n    let changedFocus = false;\n    // Focus the closest candidate\n    if (candidateElement && candidateElement !== this._activeElement) {\n      changedFocus = true;\n      this.focusElement(candidateElement);\n      this._setFocusAlignment(candidateElement as HTMLElement, false, true);\n    } else if (this.props.isCircularNavigation && useDefaultWrap) {\n      if (isForward) {\n        return this.focusElement(\n          getNextElement(this._root.current, this._root.current.firstElementChild as HTMLElement, true) as HTMLElement,\n        );\n      }\n      return this.focusElement(\n        getPreviousElement(\n          this._root.current,\n          this._root.current.lastElementChild as HTMLElement,\n          true,\n          true,\n          true,\n        ) as HTMLElement,\n      );\n    }\n    return changedFocus;\n  }\n\n  private _setFocusAlignment(element: HTMLElement, isHorizontal?: boolean, isVertical?: boolean): void {\n    if (\n      this.props.direction === FocusZoneDirection.bidirectional &&\n      (!this._focusAlignment || isHorizontal || isVertical)\n    ) {\n      const rect = element.getBoundingClientRect();\n      const left = rect.left + rect.width / 2;\n      const top = rect.top + rect.height / 2;\n\n      if (!this._focusAlignment) {\n        this._focusAlignment = { left, top };\n      }\n\n      if (isHorizontal) {\n        this._focusAlignment.left = left;\n      }\n\n      if (isVertical) {\n        this._focusAlignment.top = top;\n      }\n    }\n  }\n\n  private _isImmediateDescendantOfZone(element?: HTMLElement): boolean {\n    return this._getOwnerZone(element) === this._root.current;\n  }\n\n  private _getOwnerZone(element?: HTMLElement): HTMLElement | null {\n    let parentElement = getParent(element as HTMLElement, ALLOW_VIRTUAL_ELEMENTS);\n\n    while (parentElement && parentElement !== this._root.current && parentElement !== this._getDocument().body) {\n      if (isElementFocusZone(parentElement)) {\n        return parentElement;\n      }\n\n      parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);\n    }\n\n    return parentElement;\n  }\n\n  private _updateTabIndexes(element?: HTMLElement): void {\n    if (\n      !this._activeElement &&\n      this.props.defaultTabbableElement &&\n      typeof this.props.defaultTabbableElement === 'function'\n    ) {\n      this._activeElement = this.props.defaultTabbableElement(this._root.current as HTMLElement);\n    }\n\n    if (!element && this._root.current) {\n      this._defaultFocusElement = null;\n      element = this._root.current;\n      if (this._activeElement && !elementContains(element, this._activeElement)) {\n        this._activeElement = null;\n      }\n    }\n\n    // If active element changes state to disabled, set it to null.\n    // Otherwise, we lose keyboard accessibility to other elements in focus zone.\n    if (this._activeElement && !isElementTabbable(this._activeElement)) {\n      this._activeElement = null;\n    }\n\n    const childNodes = element && element.children;\n\n    for (let childIndex = 0; childNodes && childIndex < childNodes.length; childIndex++) {\n      const child = childNodes[childIndex] as HTMLElement;\n\n      if (!isElementFocusZone(child)) {\n        // If the item is explicitly set to not be focusable then TABINDEX needs to be set to -1.\n        if (child.getAttribute && child.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'false') {\n          child.setAttribute(TABINDEX, '-1');\n        }\n\n        if (isElementTabbable(child)) {\n          if (this.props.disabled) {\n            child.setAttribute(TABINDEX, '-1');\n          } else if (\n            !this._isInnerZone &&\n            ((!this._activeElement && !this._defaultFocusElement) || this._activeElement === child)\n          ) {\n            this._defaultFocusElement = child;\n            if (child.getAttribute(TABINDEX) !== '0') {\n              child.setAttribute(TABINDEX, '0');\n            }\n          } else if (child.getAttribute(TABINDEX) !== '-1') {\n            child.setAttribute(TABINDEX, '-1');\n          }\n        } else if (child.tagName === 'svg' && child.getAttribute('focusable') !== 'false') {\n          // Disgusting IE hack. Sad face.\n          child.setAttribute('focusable', 'false');\n        }\n      } else if (child.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true') {\n        if (\n          !this._isInnerZone &&\n          ((!this._activeElement && !this._defaultFocusElement) || this._activeElement === child)\n        ) {\n          this._defaultFocusElement = child;\n          if (child.getAttribute(TABINDEX) !== '0') {\n            child.setAttribute(TABINDEX, '0');\n          }\n        } else if (child.getAttribute(TABINDEX) !== '-1') {\n          child.setAttribute(TABINDEX, '-1');\n        }\n      }\n\n      this._updateTabIndexes(child);\n    }\n  }\n\n  private _isContentEditableElement(element: HTMLElement): boolean {\n    return element && element.getAttribute('contenteditable') === 'true';\n  }\n\n  private _isElementInput(element: HTMLElement): boolean {\n    if (\n      element &&\n      element.tagName &&\n      (element.tagName.toLowerCase() === 'input' || element.tagName.toLowerCase() === 'textarea')\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  private _shouldInputLoseFocus(element: HTMLInputElement | HTMLTextAreaElement, isForward?: boolean): boolean {\n    // If a tab was used, we want to focus on the next element.\n    if (\n      !this._processingTabKey &&\n      element &&\n      element.type &&\n      ALLOWED_INPUT_TYPES.indexOf(element.type.toLowerCase()) > -1\n    ) {\n      const selectionStart = element.selectionStart;\n      const selectionEnd = element.selectionEnd;\n      const isRangeSelected = selectionStart !== selectionEnd;\n      const inputValue = element.value;\n      const isReadonly = element.readOnly;\n\n      // We shouldn't lose focus in the following cases:\n      // 1. There is range selected.\n      // 2. When selection start is larger than 0 and it is backward and not readOnly.\n      // 3. when selection start is not the end of length, it is forward and not readOnly.\n      // 4. We press any of the arrow keys when our handleTabKey isn't none or undefined (only losing focus if we hit\n      // tab) and if shouldInputLoseFocusOnArrowKey is defined, if scenario prefers to not loose the focus which is\n      // determined by calling the callback shouldInputLoseFocusOnArrowKey\n      if (\n        isRangeSelected ||\n        (selectionStart! > 0 && !isForward && !isReadonly) ||\n        (selectionStart !== inputValue.length && isForward && !isReadonly) ||\n        (!!this.props.handleTabKey &&\n          !(this.props.shouldInputLoseFocusOnArrowKey && this.props.shouldInputLoseFocusOnArrowKey(element)))\n      ) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  private _shouldWrapFocus(\n    element: HTMLElement,\n    noWrapDataAttribute: 'data-no-vertical-wrap' | 'data-no-horizontal-wrap',\n  ): boolean {\n    return this.props.checkForNoWrap ? shouldWrapFocus(element, noWrapDataAttribute) : true;\n  }\n\n  /**\n   * Returns true if the element is a descendant of the FocusZone through a React portal.\n   */\n  private _portalContainsElement(element: HTMLElement): boolean {\n    return element && !!this._root.current && portalContainsElement(element, this._root.current);\n  }\n\n  private _getDocument(): Document {\n    return getDocument(this._root.current)!;\n  }\n}\n", "// Do not modify this file; it is generated as part of publish.\n// The checked in version is a placeholder only and will not be updated.\nimport { setVersion } from '@fluentui/set-version';\nsetVersion('@fluentui/react-focus', '8.7.6');", "import * as React from 'react';\nimport { hoistMethods, unhoistMethods } from '../../Utilities';\n\nexport class BaseDecorator<TProps, TState> extends React.Component<TProps, TState> {\n  protected _composedComponentInstance: React.Component<TProps, TState>;\n\n  private _hoisted: string[];\n\n  constructor(props: TProps) {\n    super(props);\n    this._updateComposedComponentRef = this._updateComposedComponentRef.bind(this);\n  }\n\n  /**\n   * Updates the ref to the component composed by the decorator, which will also take care of hoisting\n   * (and unhoisting as appropriate) methods from said component.\n   *\n   * Pass this method as the argument to the 'ref' property of the composed component.\n   */\n  protected _updateComposedComponentRef(composedComponentInstance: React.Component<TProps, TState>): void {\n    this._composedComponentInstance = composedComponentInstance;\n    if (composedComponentInstance) {\n      this._hoisted = hoistMethods(this, composedComponentInstance);\n    } else if (this._hoisted) {\n      unhoistMethods(this, this._hoisted);\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["IconType", "ImageFit", "ImageCoverStyle", "ImageLoadState", "classNames", "classNames", "window", "React", "getStyles", "React", "getClassNames", "IconBase", "classNames", "getStyles", "React", "FocusZoneDirection", "React", "FocusZone", "_a", "React", "BaseDecorator"]
}
