import {
  Callout,
  DirectionalHint
} from "./chunk-MVMDNYRF.js";
import {
  AnimationClassNames,
  Async,
  KeyCodes,
  __assign,
  __extends,
  assign,
  classNamesFunction,
  divProperties,
  getGlobalClassNames,
  getId,
  getNativeProps,
  hasOverflow,
  hiddenContentStyle,
  initializeComponentRef,
  portalContainsElement,
  styled
} from "./chunk-KWCDGRXS.js";
import {
  __toESM,
  require_react
} from "./chunk-PC5MGJGW.js";

// node_modules/@fluentui/react/lib/components/Tooltip/Tooltip.base.js
var React = __toESM(require_react());
var getClassNames = classNamesFunction();
var TooltipBase = function(_super) {
  __extends(TooltipBase2, _super);
  function TooltipBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._onRenderContent = function(props) {
      if (typeof props.content === "string") {
        return React.createElement("p", { className: _this._classNames.subText }, props.content);
      } else {
        return React.createElement("div", { className: _this._classNames.subText }, props.content);
      }
    };
    return _this;
  }
  TooltipBase2.prototype.render = function() {
    var _a = this.props, className = _a.className, calloutProps = _a.calloutProps, directionalHint = _a.directionalHint, directionalHintForRTL = _a.directionalHintForRTL, styles = _a.styles, id = _a.id, maxWidth = _a.maxWidth, _b = _a.onRenderContent, onRenderContent = _b === void 0 ? this._onRenderContent : _b, targetElement = _a.targetElement, theme = _a.theme;
    this._classNames = getClassNames(styles, {
      theme,
      className: className || calloutProps && calloutProps.className,
      beakWidth: calloutProps && calloutProps.beakWidth,
      gapSpace: calloutProps && calloutProps.gapSpace,
      maxWidth
    });
    return React.createElement(
      Callout,
      __assign({ target: targetElement, directionalHint, directionalHintForRTL }, calloutProps, getNativeProps(this.props, divProperties, ["id"]), { className: this._classNames.root }),
      React.createElement("div", { className: this._classNames.content, id, onMouseEnter: this.props.onMouseEnter, onMouseLeave: this.props.onMouseLeave }, onRenderContent(this.props, this._onRenderContent))
    );
  };
  TooltipBase2.defaultProps = {
    directionalHint: DirectionalHint.topCenter,
    maxWidth: "364px",
    calloutProps: {
      isBeakVisible: true,
      beakWidth: 16,
      gapSpace: 0,
      setInitialFocus: true,
      doNotLayer: false
    }
  };
  return TooltipBase2;
}(React.Component);

// node_modules/@fluentui/react/lib/components/Tooltip/Tooltip.styles.js
var getStyles = function(props) {
  var className = props.className, _a = props.beakWidth, beakWidth = _a === void 0 ? 16 : _a, _b = props.gapSpace, gapSpace = _b === void 0 ? 0 : _b, maxWidth = props.maxWidth, theme = props.theme;
  var semanticColors = theme.semanticColors, fonts = theme.fonts, effects = theme.effects;
  var tooltipGapSpace = -(Math.sqrt(beakWidth * beakWidth / 2) + gapSpace) + 1 / window.devicePixelRatio;
  return {
    root: [
      "ms-Tooltip",
      theme.fonts.medium,
      AnimationClassNames.fadeIn200,
      {
        background: semanticColors.menuBackground,
        boxShadow: effects.elevation8,
        padding: "8px",
        maxWidth,
        selectors: {
          ":after": {
            content: "''",
            position: "absolute",
            bottom: tooltipGapSpace,
            left: tooltipGapSpace,
            right: tooltipGapSpace,
            top: tooltipGapSpace,
            zIndex: 0
          }
        }
      },
      className
    ],
    content: [
      "ms-Tooltip-content",
      fonts.small,
      {
        position: "relative",
        zIndex: 1,
        color: semanticColors.menuItemText,
        wordWrap: "break-word",
        overflowWrap: "break-word",
        overflow: "hidden"
      }
    ],
    subText: [
      "ms-Tooltip-subtext",
      {
        fontSize: "inherit",
        fontWeight: "inherit",
        color: "inherit",
        margin: 0
      }
    ]
  };
};

// node_modules/@fluentui/react/lib/components/Tooltip/Tooltip.js
var Tooltip = styled(TooltipBase, getStyles, void 0, {
  scope: "Tooltip"
});

// node_modules/@fluentui/react/lib/components/Tooltip/Tooltip.types.js
var TooltipDelay;
(function(TooltipDelay2) {
  TooltipDelay2[TooltipDelay2["zero"] = 0] = "zero";
  TooltipDelay2[TooltipDelay2["medium"] = 1] = "medium";
  TooltipDelay2[TooltipDelay2["long"] = 2] = "long";
})(TooltipDelay || (TooltipDelay = {}));

// node_modules/@fluentui/react/lib/components/Tooltip/TooltipHost.types.js
var TooltipOverflowMode;
(function(TooltipOverflowMode2) {
  TooltipOverflowMode2[TooltipOverflowMode2["Parent"] = 0] = "Parent";
  TooltipOverflowMode2[TooltipOverflowMode2["Self"] = 1] = "Self";
})(TooltipOverflowMode || (TooltipOverflowMode = {}));

// node_modules/@fluentui/react/lib/components/Tooltip/TooltipHost.base.js
var React2 = __toESM(require_react());
var getClassNames2 = classNamesFunction();
var TooltipHostBase = function(_super) {
  __extends(TooltipHostBase2, _super);
  function TooltipHostBase2(props) {
    var _this = _super.call(this, props) || this;
    _this._tooltipHost = React2.createRef();
    _this._defaultTooltipId = getId("tooltip");
    _this.show = function() {
      _this._toggleTooltip(true);
    };
    _this.dismiss = function() {
      _this._hideTooltip();
    };
    _this._getTargetElement = function() {
      if (!_this._tooltipHost.current) {
        return void 0;
      }
      var overflowMode = _this.props.overflowMode;
      if (overflowMode !== void 0) {
        switch (overflowMode) {
          case TooltipOverflowMode.Parent:
            return _this._tooltipHost.current.parentElement;
          case TooltipOverflowMode.Self:
            return _this._tooltipHost.current;
        }
      }
      return _this._tooltipHost.current;
    };
    _this._onTooltipFocus = function(ev) {
      if (_this._ignoreNextFocusEvent) {
        _this._ignoreNextFocusEvent = false;
        return;
      }
      _this._onTooltipMouseEnter(ev);
    };
    _this._onTooltipBlur = function(ev) {
      _this._ignoreNextFocusEvent = (document === null || document === void 0 ? void 0 : document.activeElement) === ev.target;
      _this._hideTooltip();
    };
    _this._onTooltipMouseEnter = function(ev) {
      var _a = _this.props, overflowMode = _a.overflowMode, delay = _a.delay;
      if (TooltipHostBase2._currentVisibleTooltip && TooltipHostBase2._currentVisibleTooltip !== _this) {
        TooltipHostBase2._currentVisibleTooltip.dismiss();
      }
      TooltipHostBase2._currentVisibleTooltip = _this;
      if (overflowMode !== void 0) {
        var overflowElement = _this._getTargetElement();
        if (overflowElement && !hasOverflow(overflowElement)) {
          return;
        }
      }
      if (ev.target && portalContainsElement(ev.target, _this._getTargetElement())) {
        return;
      }
      _this._clearDismissTimer();
      _this._clearOpenTimer();
      if (delay !== TooltipDelay.zero) {
        var delayTime = _this._getDelayTime(delay);
        _this._openTimerId = _this._async.setTimeout(function() {
          _this._toggleTooltip(true);
        }, delayTime);
      } else {
        _this._toggleTooltip(true);
      }
    };
    _this._onTooltipMouseLeave = function(ev) {
      var closeDelay = _this.props.closeDelay;
      _this._clearDismissTimer();
      _this._clearOpenTimer();
      if (closeDelay) {
        _this._dismissTimerId = _this._async.setTimeout(function() {
          _this._toggleTooltip(false);
        }, closeDelay);
      } else {
        _this._toggleTooltip(false);
      }
      if (TooltipHostBase2._currentVisibleTooltip === _this) {
        TooltipHostBase2._currentVisibleTooltip = void 0;
      }
    };
    _this._onTooltipKeyDown = function(ev) {
      if ((ev.which === KeyCodes.escape || ev.ctrlKey) && _this.state.isTooltipVisible) {
        _this._hideTooltip();
        ev.stopPropagation();
      }
    };
    _this._clearDismissTimer = function() {
      _this._async.clearTimeout(_this._dismissTimerId);
    };
    _this._clearOpenTimer = function() {
      _this._async.clearTimeout(_this._openTimerId);
    };
    _this._hideTooltip = function() {
      _this._clearOpenTimer();
      _this._clearDismissTimer();
      _this._toggleTooltip(false);
    };
    _this._toggleTooltip = function(isTooltipVisible) {
      if (_this.state.isTooltipVisible !== isTooltipVisible) {
        _this.setState({ isTooltipVisible }, function() {
          return _this.props.onTooltipToggle && _this.props.onTooltipToggle(isTooltipVisible);
        });
      }
    };
    _this._getDelayTime = function(delay) {
      switch (delay) {
        case TooltipDelay.medium:
          return 300;
        case TooltipDelay.long:
          return 500;
        default:
          return 0;
      }
    };
    initializeComponentRef(_this);
    _this.state = {
      isAriaPlaceholderRendered: false,
      isTooltipVisible: false
    };
    _this._async = new Async(_this);
    return _this;
  }
  TooltipHostBase2.prototype.render = function() {
    var _a = this.props, calloutProps = _a.calloutProps, children = _a.children, content = _a.content, directionalHint = _a.directionalHint, directionalHintForRTL = _a.directionalHintForRTL, className = _a.hostClassName, id = _a.id, _b = _a.setAriaDescribedBy, setAriaDescribedBy = _b === void 0 ? true : _b, tooltipProps = _a.tooltipProps, styles = _a.styles, theme = _a.theme;
    this._classNames = getClassNames2(styles, {
      theme,
      className
    });
    var isTooltipVisible = this.state.isTooltipVisible;
    var tooltipId = id || this._defaultTooltipId;
    var tooltipContent = (tooltipProps === null || tooltipProps === void 0 ? void 0 : tooltipProps.onRenderContent) ? tooltipProps.onRenderContent() : content;
    var showTooltip = isTooltipVisible && !!tooltipContent;
    var ariaDescribedBy = setAriaDescribedBy && isTooltipVisible && !!tooltipContent ? tooltipId : void 0;
    return React2.createElement(
      "div",
      __assign({ className: this._classNames.root, ref: this._tooltipHost }, { onFocusCapture: this._onTooltipFocus }, { onBlurCapture: this._onTooltipBlur }, { onMouseEnter: this._onTooltipMouseEnter, onMouseLeave: this._onTooltipMouseLeave, onKeyDown: this._onTooltipKeyDown, role: "none", "aria-describedby": ariaDescribedBy }),
      children,
      showTooltip && React2.createElement(Tooltip, __assign({ id: tooltipId + "--tooltip", content, targetElement: this._getTargetElement(), directionalHint, directionalHintForRTL, calloutProps: assign({}, calloutProps, {
        onDismiss: this._hideTooltip,
        onMouseEnter: this._onTooltipMouseEnter,
        onMouseLeave: this._onTooltipMouseLeave
      }), onMouseEnter: this._onTooltipMouseEnter, onMouseLeave: this._onTooltipMouseLeave }, getNativeProps(this.props, divProperties, ["id"]), tooltipProps)),
      React2.createElement("div", { hidden: true, id: tooltipId, style: hiddenContentStyle }, tooltipContent)
    );
  };
  TooltipHostBase2.prototype.componentWillUnmount = function() {
    if (TooltipHostBase2._currentVisibleTooltip && TooltipHostBase2._currentVisibleTooltip === this) {
      TooltipHostBase2._currentVisibleTooltip = void 0;
    }
    this._async.dispose();
  };
  TooltipHostBase2.defaultProps = {
    delay: TooltipDelay.medium
  };
  return TooltipHostBase2;
}(React2.Component);

// node_modules/@fluentui/react/lib/components/Tooltip/TooltipHost.styles.js
var GlobalClassNames = {
  root: "ms-TooltipHost",
  ariaPlaceholder: "ms-TooltipHost-aria-placeholder"
};
var getStyles2 = function(props) {
  var className = props.className, theme = props.theme;
  var classNames = getGlobalClassNames(GlobalClassNames, theme);
  return {
    root: [
      classNames.root,
      {
        display: "inline"
      },
      className
    ]
  };
};

// node_modules/@fluentui/react/lib/components/Tooltip/TooltipHost.js
var TooltipHost = styled(TooltipHostBase, getStyles2, void 0, {
  scope: "TooltipHost"
});

export {
  TooltipBase,
  Tooltip,
  TooltipDelay,
  TooltipOverflowMode,
  TooltipHostBase,
  TooltipHost
};
//# sourceMappingURL=chunk-JDG4W6Y4.js.map
