import {
  BaseDecorator,
  FocusZone,
  FocusZoneDirection,
  FocusZoneTabbableElements,
  FontIcon,
  Icon,
  ImageIcon
} from "./chunk-RDTBTV7D.js";
import {
  Callout,
  DirectionalHint,
  FocusTrapZone,
  Popup
} from "./chunk-MVMDNYRF.js";
import {
  Layer,
  WindowContext,
  useAsync,
  useConst,
  useId,
  useOnEvent,
  usePrevious,
  useTarget,
  useWarnings,
  useWindow
} from "./chunk-OFNEIFUY.js";
import {
  AnimationClassNames,
  AnimationVariables,
  Async,
  EventGroup,
  FocusRects,
  FontWeights,
  HighContrastSelector,
  IconFontSizes,
  IsFocusVisibleClassName,
  KeyCodes,
  ScreenWidthMaxMedium,
  ScreenWidthMinLarge,
  ScreenWidthMinMedium,
  ScreenWidthMinUhfMobile,
  ScreenWidthMinXLarge,
  ScreenWidthMinXXLarge,
  __assign,
  __decorate,
  __extends,
  __rest,
  __spreadArray,
  addElementAtIndex,
  allowOverscrollOnElement,
  allowScrollOnElement,
  anchorProperties,
  assign,
  buttonProperties,
  classNamesFunction,
  composeComponentAs,
  composeRenderFunction,
  concatStyleSets,
  concatStyleSetsWithProps,
  createMergedRef,
  css,
  customizable,
  disableBodyScroll,
  divProperties,
  elementContains,
  enableBodyScroll,
  find,
  getDocument,
  getFirstFocusable,
  getFocusStyle,
  getGlobalClassNames,
  getHighContrastNoAdjustStyle,
  getId,
  getLastFocusable,
  getNativeProps,
  getPropsWithDefaults,
  getRTL,
  getScreenSelector,
  getWindow,
  hiddenContentStyle,
  hoistStatics,
  initializeComponentRef,
  isIOS,
  isMac,
  memoizeFunction,
  mergeAriaAttributeValues,
  mergeStyleSets,
  mergeStyles,
  nullRender,
  portalContainsElement,
  setFocusVisibility,
  shallowCompare,
  shouldWrapFocus,
  styled,
  useIsomorphicLayoutEffect,
  warn,
  warnConditionallyRequiredProps,
  warnDeprecations
} from "./chunk-KWCDGRXS.js";
import {
  __toESM,
  require_react
} from "./chunk-PC5MGJGW.js";

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenu.types.js
var ContextualMenuItemType;
(function(ContextualMenuItemType2) {
  ContextualMenuItemType2[ContextualMenuItemType2["Normal"] = 0] = "Normal";
  ContextualMenuItemType2[ContextualMenuItemType2["Divider"] = 1] = "Divider";
  ContextualMenuItemType2[ContextualMenuItemType2["Header"] = 2] = "Header";
  ContextualMenuItemType2[ContextualMenuItemType2["Section"] = 3] = "Section";
})(ContextualMenuItemType || (ContextualMenuItemType = {}));

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenuItem.base.js
var React = __toESM(require_react());

// node_modules/@fluentui/react/lib/utilities/contextualMenu/contextualMenuUtility.js
function getIsChecked(item) {
  if (item.canCheck) {
    return !!(item.isChecked || item.checked);
  }
  if (typeof item.isChecked === "boolean") {
    return item.isChecked;
  }
  if (typeof item.checked === "boolean") {
    return item.checked;
  }
  return null;
}
function hasSubmenu(item) {
  return !!(item.subMenuProps || item.items);
}
function isItemDisabled(item) {
  return !!(item.isDisabled || item.disabled);
}
function getMenuItemAriaRole(item) {
  var isChecked = getIsChecked(item);
  var canCheck = isChecked !== null;
  return canCheck ? "menuitemcheckbox" : "menuitem";
}

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenuItem.base.js
var defaultIconRenderer = function(props) {
  var item = props.item, classNames = props.classNames;
  var iconProps = item.iconProps;
  return React.createElement(Icon, __assign({}, iconProps, { className: classNames.icon }));
};
var renderItemIcon = function(props) {
  var item = props.item, hasIcons = props.hasIcons;
  if (!hasIcons) {
    return null;
  }
  if (item.onRenderIcon) {
    return item.onRenderIcon(props, defaultIconRenderer);
  }
  return defaultIconRenderer(props);
};
var renderCheckMarkIcon = function(_a2) {
  var onCheckmarkClick = _a2.onCheckmarkClick, item = _a2.item, classNames = _a2.classNames;
  var isItemChecked = getIsChecked(item);
  if (onCheckmarkClick) {
    var onClick = function(e) {
      return onCheckmarkClick(item, e);
    };
    return React.createElement(Icon, {
      iconName: item.canCheck !== false && isItemChecked ? "CheckMark" : "",
      className: classNames.checkmarkIcon,
      onClick
    });
  }
  return null;
};
var renderItemName = function(_a2) {
  var item = _a2.item, classNames = _a2.classNames;
  if (item.text || item.name) {
    return React.createElement("span", { className: classNames.label }, item.text || item.name);
  }
  return null;
};
var renderSecondaryText = function(_a2) {
  var item = _a2.item, classNames = _a2.classNames;
  if (item.secondaryText) {
    return React.createElement("span", { className: classNames.secondaryText }, item.secondaryText);
  }
  return null;
};
var renderSubMenuIcon = function(_a2) {
  var item = _a2.item, classNames = _a2.classNames, theme = _a2.theme;
  if (hasSubmenu(item)) {
    return React.createElement(Icon, __assign({ iconName: getRTL(theme) ? "ChevronLeft" : "ChevronRight" }, item.submenuIconProps, { className: classNames.subMenuIcon }));
  }
  return null;
};
var ContextualMenuItemBase = function(_super) {
  __extends(ContextualMenuItemBase2, _super);
  function ContextualMenuItemBase2(props) {
    var _this = _super.call(this, props) || this;
    _this.openSubMenu = function() {
      var _a2 = _this.props, item = _a2.item, openSubMenu = _a2.openSubMenu, getSubmenuTarget = _a2.getSubmenuTarget;
      if (getSubmenuTarget) {
        var submenuTarget = getSubmenuTarget();
        if (hasSubmenu(item) && openSubMenu && submenuTarget) {
          openSubMenu(item, submenuTarget);
        }
      }
    };
    _this.dismissSubMenu = function() {
      var _a2 = _this.props, item = _a2.item, dismissSubMenu = _a2.dismissSubMenu;
      if (hasSubmenu(item) && dismissSubMenu) {
        dismissSubMenu();
      }
    };
    _this.dismissMenu = function(dismissAll) {
      var dismissMenu = _this.props.dismissMenu;
      if (dismissMenu) {
        dismissMenu(void 0, dismissAll);
      }
    };
    initializeComponentRef(_this);
    return _this;
  }
  ContextualMenuItemBase2.prototype.render = function() {
    var _a2 = this.props, item = _a2.item, classNames = _a2.classNames;
    var renderContent = item.onRenderContent || this._renderLayout;
    return React.createElement("div", { className: item.split ? classNames.linkContentMenu : classNames.linkContent }, renderContent(this.props, {
      renderCheckMarkIcon,
      renderItemIcon,
      renderItemName,
      renderSecondaryText,
      renderSubMenuIcon
    }));
  };
  ContextualMenuItemBase2.prototype._renderLayout = function(props, defaultRenders) {
    return React.createElement(
      React.Fragment,
      null,
      defaultRenders.renderCheckMarkIcon(props),
      defaultRenders.renderItemIcon(props),
      defaultRenders.renderItemName(props),
      defaultRenders.renderSecondaryText(props),
      defaultRenders.renderSubMenuIcon(props)
    );
  };
  return ContextualMenuItemBase2;
}(React.Component);

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenu.cnstyles.js
var CONTEXTUAL_MENU_ITEM_HEIGHT = 36;
var MediumScreenSelector = getScreenSelector(0, ScreenWidthMaxMedium);
var getMenuItemStyles = memoizeFunction(function(theme) {
  var _a2, _b2, _c2, _d2, _e2;
  var semanticColors = theme.semanticColors, fonts = theme.fonts, palette = theme.palette;
  var ContextualMenuItemBackgroundHoverColor = semanticColors.menuItemBackgroundHovered;
  var ContextualMenuItemTextHoverColor = semanticColors.menuItemTextHovered;
  var ContextualMenuItemBackgroundSelectedColor = semanticColors.menuItemBackgroundPressed;
  var ContextualMenuItemDividerColor = semanticColors.bodyDivider;
  var menuItemStyles = {
    item: [
      fonts.medium,
      {
        color: semanticColors.bodyText,
        position: "relative",
        boxSizing: "border-box"
      }
    ],
    divider: {
      display: "block",
      height: "1px",
      backgroundColor: ContextualMenuItemDividerColor,
      position: "relative"
    },
    root: [
      getFocusStyle(theme),
      fonts.medium,
      {
        color: semanticColors.bodyText,
        backgroundColor: "transparent",
        border: "none",
        width: "100%",
        height: CONTEXTUAL_MENU_ITEM_HEIGHT,
        lineHeight: CONTEXTUAL_MENU_ITEM_HEIGHT,
        display: "block",
        cursor: "pointer",
        padding: "0px 8px 0 4px",
        textAlign: "left"
      }
    ],
    rootDisabled: {
      color: semanticColors.disabledBodyText,
      cursor: "default",
      pointerEvents: "none",
      selectors: (_a2 = {}, _a2[HighContrastSelector] = {
        color: "GrayText",
        opacity: 1
      }, _a2)
    },
    rootHovered: {
      backgroundColor: ContextualMenuItemBackgroundHoverColor,
      color: ContextualMenuItemTextHoverColor,
      selectors: {
        ".ms-ContextualMenu-icon": {
          color: palette.themeDarkAlt
        },
        ".ms-ContextualMenu-submenuIcon": {
          color: palette.neutralPrimary
        }
      }
    },
    rootFocused: {
      backgroundColor: palette.white
    },
    rootChecked: {
      selectors: {
        ".ms-ContextualMenu-checkmarkIcon": {
          color: palette.neutralPrimary
        }
      }
    },
    rootPressed: {
      backgroundColor: ContextualMenuItemBackgroundSelectedColor,
      selectors: {
        ".ms-ContextualMenu-icon": {
          color: palette.themeDark
        },
        ".ms-ContextualMenu-submenuIcon": {
          color: palette.neutralPrimary
        }
      }
    },
    rootExpanded: {
      backgroundColor: ContextualMenuItemBackgroundSelectedColor,
      color: semanticColors.bodyTextChecked,
      selectors: (_b2 = {
        ".ms-ContextualMenu-submenuIcon": (_c2 = {}, _c2[HighContrastSelector] = {
          color: "inherit"
        }, _c2)
      }, _b2[HighContrastSelector] = __assign({}, getHighContrastNoAdjustStyle()), _b2)
    },
    linkContent: {
      whiteSpace: "nowrap",
      height: "inherit",
      display: "flex",
      alignItems: "center",
      maxWidth: "100%"
    },
    anchorLink: {
      padding: "0px 8px 0 4px",
      textRendering: "auto",
      color: "inherit",
      letterSpacing: "normal",
      wordSpacing: "normal",
      textTransform: "none",
      textIndent: "0px",
      textShadow: "none",
      textDecoration: "none",
      boxSizing: "border-box"
    },
    label: {
      margin: "0 4px",
      verticalAlign: "middle",
      display: "inline-block",
      flexGrow: "1",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap"
    },
    secondaryText: {
      color: theme.palette.neutralSecondary,
      paddingLeft: "20px",
      textAlign: "right"
    },
    icon: {
      display: "inline-block",
      minHeight: "1px",
      maxHeight: CONTEXTUAL_MENU_ITEM_HEIGHT,
      fontSize: IconFontSizes.medium,
      width: IconFontSizes.medium,
      margin: "0 4px",
      verticalAlign: "middle",
      flexShrink: "0",
      selectors: (_d2 = {}, _d2[MediumScreenSelector] = {
        fontSize: IconFontSizes.large,
        width: IconFontSizes.large
      }, _d2)
    },
    iconColor: {
      color: semanticColors.menuIcon
    },
    iconDisabled: {
      color: semanticColors.disabledBodyText
    },
    checkmarkIcon: {
      color: semanticColors.bodySubtext
    },
    subMenuIcon: {
      height: CONTEXTUAL_MENU_ITEM_HEIGHT,
      lineHeight: CONTEXTUAL_MENU_ITEM_HEIGHT,
      color: palette.neutralSecondary,
      textAlign: "center",
      display: "inline-block",
      verticalAlign: "middle",
      flexShrink: "0",
      fontSize: IconFontSizes.small,
      selectors: (_e2 = {
        ":hover": {
          color: palette.neutralPrimary
        },
        ":active": {
          color: palette.neutralPrimary
        }
      }, _e2[MediumScreenSelector] = {
        fontSize: IconFontSizes.medium
      }, _e2)
    },
    splitButtonFlexContainer: [
      getFocusStyle(theme),
      {
        display: "flex",
        height: CONTEXTUAL_MENU_ITEM_HEIGHT,
        flexWrap: "nowrap",
        justifyContent: "center",
        alignItems: "flex-start"
      }
    ]
  };
  return concatStyleSets(menuItemStyles);
});

// node_modules/@fluentui/react/lib/components/Divider/VerticalDivider.classNames.js
var getDividerClassNames = memoizeFunction(
  function(theme) {
    return mergeStyleSets({
      wrapper: {
        display: "inline-flex",
        height: "100%",
        alignItems: "center"
      },
      divider: {
        width: 1,
        height: "100%",
        backgroundColor: theme.palette.neutralTertiaryAlt
      }
    });
  }
);

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenu.classNames.js
var CONTEXTUAL_SPLIT_MENU_MINWIDTH = "28px";
var MediumScreenSelector2 = getScreenSelector(0, ScreenWidthMaxMedium);
var getSplitButtonVerticalDividerClassNames = memoizeFunction(
  function(theme) {
    var _a2;
    return mergeStyleSets(getDividerClassNames(theme), {
      wrapper: {
        position: "absolute",
        right: 28,
        selectors: (_a2 = {}, _a2[MediumScreenSelector2] = {
          right: 32
        }, _a2)
      },
      divider: {
        height: 16,
        width: 1
      }
    });
  }
);
var GlobalClassNames = {
  item: "ms-ContextualMenu-item",
  divider: "ms-ContextualMenu-divider",
  root: "ms-ContextualMenu-link",
  isChecked: "is-checked",
  isExpanded: "is-expanded",
  isDisabled: "is-disabled",
  linkContent: "ms-ContextualMenu-linkContent",
  linkContentMenu: "ms-ContextualMenu-linkContent",
  icon: "ms-ContextualMenu-icon",
  iconColor: "ms-ContextualMenu-iconColor",
  checkmarkIcon: "ms-ContextualMenu-checkmarkIcon",
  subMenuIcon: "ms-ContextualMenu-submenuIcon",
  label: "ms-ContextualMenu-itemText",
  secondaryText: "ms-ContextualMenu-secondaryText",
  splitMenu: "ms-ContextualMenu-splitMenu",
  screenReaderText: "ms-ContextualMenu-screenReaderText"
};
var getItemClassNames = memoizeFunction(function(theme, disabled, expanded, checked, isAnchorLink, knownIcon, itemClassName, dividerClassName, iconClassName, subMenuClassName, primaryDisabled, className) {
  var _a2, _b2, _c2, _d2;
  var styles = getMenuItemStyles(theme);
  var classNames = getGlobalClassNames(GlobalClassNames, theme);
  return mergeStyleSets({
    item: [classNames.item, styles.item, itemClassName],
    divider: [classNames.divider, styles.divider, dividerClassName],
    root: [
      classNames.root,
      styles.root,
      checked && [classNames.isChecked, styles.rootChecked],
      isAnchorLink && styles.anchorLink,
      expanded && [classNames.isExpanded, styles.rootExpanded],
      disabled && [classNames.isDisabled, styles.rootDisabled],
      !disabled && !expanded && [
        {
          selectors: (_a2 = {
            ":hover": styles.rootHovered,
            ":active": styles.rootPressed
          }, _a2["." + IsFocusVisibleClassName + " &:focus, ." + IsFocusVisibleClassName + " &:focus:hover"] = styles.rootFocused, _a2["." + IsFocusVisibleClassName + " &:hover"] = { background: "inherit;" }, _a2)
        }
      ],
      className
    ],
    splitPrimary: [
      styles.root,
      {
        width: "calc(100% - " + CONTEXTUAL_SPLIT_MENU_MINWIDTH + ")"
      },
      checked && ["is-checked", styles.rootChecked],
      (disabled || primaryDisabled) && ["is-disabled", styles.rootDisabled],
      !(disabled || primaryDisabled) && !checked && [
        {
          selectors: (_b2 = {
            ":hover": styles.rootHovered
          }, _b2[":hover ~ ." + classNames.splitMenu] = styles.rootHovered, _b2[":active"] = styles.rootPressed, _b2["." + IsFocusVisibleClassName + " &:focus, ." + IsFocusVisibleClassName + " &:focus:hover"] = styles.rootFocused, _b2["." + IsFocusVisibleClassName + " &:hover"] = { background: "inherit;" }, _b2)
        }
      ]
    ],
    splitMenu: [
      classNames.splitMenu,
      styles.root,
      {
        flexBasis: "0",
        padding: "0 8px",
        minWidth: CONTEXTUAL_SPLIT_MENU_MINWIDTH
      },
      expanded && ["is-expanded", styles.rootExpanded],
      disabled && ["is-disabled", styles.rootDisabled],
      !disabled && !expanded && [
        {
          selectors: (_c2 = {
            ":hover": styles.rootHovered,
            ":active": styles.rootPressed
          }, _c2["." + IsFocusVisibleClassName + " &:focus, ." + IsFocusVisibleClassName + " &:focus:hover"] = styles.rootFocused, _c2["." + IsFocusVisibleClassName + " &:hover"] = { background: "inherit;" }, _c2)
        }
      ]
    ],
    anchorLink: styles.anchorLink,
    linkContent: [classNames.linkContent, styles.linkContent],
    linkContentMenu: [
      classNames.linkContentMenu,
      styles.linkContent,
      {
        justifyContent: "center"
      }
    ],
    icon: [
      classNames.icon,
      knownIcon && styles.iconColor,
      styles.icon,
      iconClassName,
      disabled && [classNames.isDisabled, styles.iconDisabled]
    ],
    iconColor: styles.iconColor,
    checkmarkIcon: [classNames.checkmarkIcon, knownIcon && styles.checkmarkIcon, styles.icon, iconClassName],
    subMenuIcon: [
      classNames.subMenuIcon,
      styles.subMenuIcon,
      subMenuClassName,
      expanded && { color: theme.palette.neutralPrimary },
      disabled && [styles.iconDisabled]
    ],
    label: [classNames.label, styles.label],
    secondaryText: [classNames.secondaryText, styles.secondaryText],
    splitContainer: [
      styles.splitButtonFlexContainer,
      !disabled && !checked && [
        {
          selectors: (_d2 = {}, _d2["." + IsFocusVisibleClassName + " &:focus, ." + IsFocusVisibleClassName + " &:focus:hover"] = styles.rootFocused, _d2)
        }
      ]
    ],
    screenReaderText: [
      classNames.screenReaderText,
      styles.screenReaderText,
      hiddenContentStyle,
      { visibility: "hidden" }
    ]
  });
});
var getItemStyles = function(props) {
  var theme = props.theme, disabled = props.disabled, expanded = props.expanded, checked = props.checked, isAnchorLink = props.isAnchorLink, knownIcon = props.knownIcon, itemClassName = props.itemClassName, dividerClassName = props.dividerClassName, iconClassName = props.iconClassName, subMenuClassName = props.subMenuClassName, primaryDisabled = props.primaryDisabled, className = props.className;
  return getItemClassNames(theme, disabled, expanded, checked, isAnchorLink, knownIcon, itemClassName, dividerClassName, iconClassName, subMenuClassName, primaryDisabled, className);
};

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenuItem.js
var ContextualMenuItem = styled(ContextualMenuItemBase, getItemStyles, void 0, { scope: "ContextualMenuItem" });

// node_modules/@fluentui/react/lib/utilities/keytips/IKeytipTransitionKey.js
function transitionKeysAreEqual(key1, key2) {
  if (key1.key !== key2.key) {
    return false;
  }
  var mod1 = key1.modifierKeys;
  var mod2 = key2.modifierKeys;
  if (!mod1 && mod2 || mod1 && !mod2) {
    return false;
  }
  if (mod1 && mod2) {
    if (mod1.length !== mod2.length) {
      return false;
    }
    mod1 = mod1.sort();
    mod2 = mod2.sort();
    for (var i = 0; i < mod1.length; i++) {
      if (mod1[i] !== mod2[i]) {
        return false;
      }
    }
  }
  return true;
}
function transitionKeysContain(keys, key) {
  return !!find(keys, function(transitionKey) {
    return transitionKeysAreEqual(transitionKey, key);
  });
}

// node_modules/@fluentui/react/lib/utilities/keytips/KeytipConfig.js
function buildKeytipConfigMap(config) {
  var configMap = {};
  for (var _i = 0, _a2 = config.keytips; _i < _a2.length; _i++) {
    var keytip = _a2[_i];
    constructKeytip(configMap, [], keytip);
  }
  return configMap;
}
function constructKeytip(configMap, parentSequence, keytip) {
  var sequence = keytip.sequence ? keytip.sequence : keytip.content.toLocaleLowerCase();
  var keytipSequence = parentSequence.concat(sequence);
  var keytipProps = __assign(__assign({}, keytip.optionalProps), { keySequences: keytipSequence, content: keytip.content });
  configMap[keytip.id] = keytipProps;
  if (keytip.children) {
    for (var _i = 0, _a2 = keytip.children; _i < _a2.length; _i++) {
      var child = _a2[_i];
      constructKeytip(configMap, keytipSequence, child);
    }
  }
}

// node_modules/@fluentui/react/lib/utilities/keytips/KeytipConstants.js
var KTP_PREFIX = "ktp";
var KTP_SEPARATOR = "-";
var KTP_FULL_PREFIX = KTP_PREFIX + KTP_SEPARATOR;
var DATAKTP_TARGET = "data-ktp-target";
var DATAKTP_EXECUTE_TARGET = "data-ktp-execute-target";
var DATAKTP_ARIA_TARGET = "data-ktp-aria-target";
var KTP_LAYER_ID = "ktp-layer-id";
var KTP_ARIA_SEPARATOR = ", ";
var KeytipEvents;
(function(KeytipEvents2) {
  KeytipEvents2.KEYTIP_ADDED = "keytipAdded";
  KeytipEvents2.KEYTIP_REMOVED = "keytipRemoved";
  KeytipEvents2.KEYTIP_UPDATED = "keytipUpdated";
  KeytipEvents2.PERSISTED_KEYTIP_ADDED = "persistedKeytipAdded";
  KeytipEvents2.PERSISTED_KEYTIP_REMOVED = "persistedKeytipRemoved";
  KeytipEvents2.PERSISTED_KEYTIP_EXECUTE = "persistedKeytipExecute";
  KeytipEvents2.ENTER_KEYTIP_MODE = "enterKeytipMode";
  KeytipEvents2.EXIT_KEYTIP_MODE = "exitKeytipMode";
})(KeytipEvents || (KeytipEvents = {}));

// node_modules/@fluentui/react/lib/utilities/keytips/KeytipManager.js
var KeytipManager = function() {
  function KeytipManager2() {
    this.keytips = {};
    this.persistedKeytips = {};
    this.sequenceMapping = {};
    this.inKeytipMode = false;
    this.shouldEnterKeytipMode = true;
    this.delayUpdatingKeytipChange = false;
  }
  KeytipManager2.getInstance = function() {
    return this._instance;
  };
  KeytipManager2.prototype.init = function(delayUpdatingKeytipChange) {
    this.delayUpdatingKeytipChange = delayUpdatingKeytipChange;
  };
  KeytipManager2.prototype.register = function(keytipProps, persisted) {
    if (persisted === void 0) {
      persisted = false;
    }
    var props = keytipProps;
    if (!persisted) {
      props = this.addParentOverflow(keytipProps);
      this.sequenceMapping[props.keySequences.toString()] = props;
    }
    var uniqueKeytip = this._getUniqueKtp(props);
    persisted ? this.persistedKeytips[uniqueKeytip.uniqueID] = uniqueKeytip : this.keytips[uniqueKeytip.uniqueID] = uniqueKeytip;
    if (this.inKeytipMode || !this.delayUpdatingKeytipChange) {
      var event_1 = persisted ? KeytipEvents.PERSISTED_KEYTIP_ADDED : KeytipEvents.KEYTIP_ADDED;
      EventGroup.raise(this, event_1, {
        keytip: props,
        uniqueID: uniqueKeytip.uniqueID
      });
    }
    return uniqueKeytip.uniqueID;
  };
  KeytipManager2.prototype.update = function(keytipProps, uniqueID) {
    var newKeytipProps = this.addParentOverflow(keytipProps);
    var uniqueKeytip = this._getUniqueKtp(newKeytipProps, uniqueID);
    var oldKeyTip = this.keytips[uniqueID];
    if (oldKeyTip) {
      uniqueKeytip.keytip.visible = oldKeyTip.keytip.visible;
      this.keytips[uniqueID] = uniqueKeytip;
      delete this.sequenceMapping[oldKeyTip.keytip.keySequences.toString()];
      this.sequenceMapping[uniqueKeytip.keytip.keySequences.toString()] = uniqueKeytip.keytip;
      if (this.inKeytipMode || !this.delayUpdatingKeytipChange) {
        EventGroup.raise(this, KeytipEvents.KEYTIP_UPDATED, {
          keytip: uniqueKeytip.keytip,
          uniqueID: uniqueKeytip.uniqueID
        });
      }
    }
  };
  KeytipManager2.prototype.unregister = function(keytipToRemove, uniqueID, persisted) {
    if (persisted === void 0) {
      persisted = false;
    }
    persisted ? delete this.persistedKeytips[uniqueID] : delete this.keytips[uniqueID];
    !persisted && delete this.sequenceMapping[keytipToRemove.keySequences.toString()];
    var event = persisted ? KeytipEvents.PERSISTED_KEYTIP_REMOVED : KeytipEvents.KEYTIP_REMOVED;
    if (this.inKeytipMode || !this.delayUpdatingKeytipChange) {
      EventGroup.raise(this, event, {
        keytip: keytipToRemove,
        uniqueID
      });
    }
  };
  KeytipManager2.prototype.enterKeytipMode = function() {
    EventGroup.raise(this, KeytipEvents.ENTER_KEYTIP_MODE);
  };
  KeytipManager2.prototype.exitKeytipMode = function() {
    EventGroup.raise(this, KeytipEvents.EXIT_KEYTIP_MODE);
  };
  KeytipManager2.prototype.getKeytips = function() {
    var _this = this;
    return Object.keys(this.keytips).map(function(key) {
      return _this.keytips[key].keytip;
    });
  };
  KeytipManager2.prototype.addParentOverflow = function(keytipProps) {
    var fullSequence = __spreadArray([], keytipProps.keySequences);
    fullSequence.pop();
    if (fullSequence.length !== 0) {
      var parentKeytip = this.sequenceMapping[fullSequence.toString()];
      if (parentKeytip && parentKeytip.overflowSetSequence) {
        return __assign(__assign({}, keytipProps), { overflowSetSequence: parentKeytip.overflowSetSequence });
      }
    }
    return keytipProps;
  };
  KeytipManager2.prototype.menuExecute = function(overflowButtonSequences, keytipSequences) {
    EventGroup.raise(this, KeytipEvents.PERSISTED_KEYTIP_EXECUTE, {
      overflowButtonSequences,
      keytipSequences
    });
  };
  KeytipManager2.prototype._getUniqueKtp = function(keytipProps, uniqueID) {
    if (uniqueID === void 0) {
      uniqueID = getId();
    }
    return { keytip: __assign({}, keytipProps), uniqueID };
  };
  KeytipManager2._instance = new KeytipManager2();
  return KeytipManager2;
}();

// node_modules/@fluentui/react/lib/utilities/keytips/KeytipUtils.js
function sequencesToID(keySequences) {
  return keySequences.reduce(function(prevValue, keySequence) {
    return prevValue + KTP_SEPARATOR + keySequence.split("").join(KTP_SEPARATOR);
  }, KTP_PREFIX);
}
function mergeOverflows(keySequences, overflowKeySequences) {
  var overflowSequenceLen = overflowKeySequences.length;
  var overflowSequence = __spreadArray([], overflowKeySequences).pop();
  var newKeySequences = __spreadArray([], keySequences);
  return addElementAtIndex(newKeySequences, overflowSequenceLen - 1, overflowSequence);
}
function ktpTargetFromSequences(keySequences) {
  return "[" + DATAKTP_TARGET + '="' + sequencesToID(keySequences) + '"]';
}
function ktpTargetFromId(keytipId) {
  return "[" + DATAKTP_EXECUTE_TARGET + '="' + keytipId + '"]';
}
function getAriaDescribedBy(keySequences) {
  var describedby = " " + KTP_LAYER_ID;
  if (!keySequences.length) {
    return describedby;
  }
  return describedby + " " + sequencesToID(keySequences);
}

// node_modules/@fluentui/react/lib/components/KeytipData/useKeytipData.js
var React2 = __toESM(require_react());
function useKeytipData(options) {
  var uniqueId = React2.useRef();
  var keytipProps = options.keytipProps ? __assign({ disabled: options.disabled }, options.keytipProps) : void 0;
  var keytipManager = useConst(KeytipManager.getInstance());
  var prevOptions = usePrevious(options);
  useIsomorphicLayoutEffect(function() {
    if (uniqueId.current && keytipProps && ((prevOptions === null || prevOptions === void 0 ? void 0 : prevOptions.keytipProps) !== options.keytipProps || (prevOptions === null || prevOptions === void 0 ? void 0 : prevOptions.disabled) !== options.disabled)) {
      keytipManager.update(keytipProps, uniqueId.current);
    }
  });
  useIsomorphicLayoutEffect(function() {
    if (keytipProps) {
      uniqueId.current = keytipManager.register(keytipProps);
    }
    return function() {
      keytipProps && keytipManager.unregister(keytipProps, uniqueId.current);
    };
  }, []);
  var nativeKeytipProps = {
    ariaDescribedBy: void 0,
    keytipId: void 0
  };
  if (keytipProps) {
    nativeKeytipProps = getKeytipData(keytipManager, keytipProps, options.ariaDescribedBy);
  }
  return nativeKeytipProps;
}
function getKeytipData(keytipManager, keytipProps, describedByPrepend) {
  var newKeytipProps = keytipManager.addParentOverflow(keytipProps);
  var ariaDescribedBy = mergeAriaAttributeValues(describedByPrepend, getAriaDescribedBy(newKeytipProps.keySequences));
  var keySequences = __spreadArray([], newKeytipProps.keySequences);
  if (newKeytipProps.overflowSetSequence) {
    keySequences = mergeOverflows(keySequences, newKeytipProps.overflowSetSequence);
  }
  var keytipId = sequencesToID(keySequences);
  return {
    ariaDescribedBy,
    keytipId
  };
}

// node_modules/@fluentui/react/lib/components/KeytipData/KeytipData.js
var KeytipData = function(props) {
  var _a2;
  var children = props.children, keytipDataProps = __rest(props, ["children"]);
  var _b2 = useKeytipData(keytipDataProps), keytipId = _b2.keytipId, ariaDescribedBy = _b2.ariaDescribedBy;
  return children((_a2 = {}, _a2[DATAKTP_TARGET] = keytipId, _a2[DATAKTP_EXECUTE_TARGET] = keytipId, _a2["aria-describedby"] = ariaDescribedBy, _a2));
};

// node_modules/@fluentui/react/lib/components/KeytipData/useKeytipRef.js
var React3 = __toESM(require_react());
function useKeytipRef(options) {
  var _a2 = useKeytipData(options), keytipId = _a2.keytipId, ariaDescribedBy = _a2.ariaDescribedBy;
  var contentRef = React3.useCallback(function(contentElement) {
    if (!contentElement) {
      return;
    }
    var targetElement = findFirstElement(contentElement, DATAKTP_TARGET) || contentElement;
    var executeElement = findFirstElement(contentElement, DATAKTP_EXECUTE_TARGET) || targetElement;
    var ariaElement = findFirstElement(contentElement, DATAKTP_ARIA_TARGET) || executeElement;
    setAttribute(targetElement, DATAKTP_TARGET, keytipId);
    setAttribute(executeElement, DATAKTP_EXECUTE_TARGET, keytipId);
    setAttribute(ariaElement, "aria-describedby", ariaDescribedBy, true);
  }, [keytipId, ariaDescribedBy]);
  return contentRef;
}
function setAttribute(element, attributeName, attributeValue, append) {
  if (append === void 0) {
    append = false;
  }
  if (element && attributeValue) {
    var value = attributeValue;
    if (append) {
      var currentValue = element.getAttribute(attributeName);
      if (currentValue && currentValue.indexOf(attributeValue) === -1) {
        value = currentValue + " " + attributeValue;
      }
    }
    element.setAttribute(attributeName, value);
  }
}
function findFirstElement(rootElement, dataAttribute) {
  return rootElement.querySelector("[" + dataAttribute + "]");
}

// node_modules/@fluentui/react/lib/components/Divider/VerticalDivider.styles.js
var getStyles = function(props) {
  var theme = props.theme, getClassNames5 = props.getClassNames, className = props.className;
  if (!theme) {
    throw new Error("Theme is undefined or null.");
  }
  if (getClassNames5) {
    var names = getClassNames5(theme);
    return {
      wrapper: [names.wrapper],
      divider: [names.divider]
    };
  }
  return {
    wrapper: [
      {
        display: "inline-flex",
        height: "100%",
        alignItems: "center"
      },
      className
    ],
    divider: [
      {
        width: 1,
        height: "100%",
        backgroundColor: theme.palette.neutralTertiaryAlt
      }
    ]
  };
};

// node_modules/@fluentui/react/lib/components/Divider/VerticalDivider.base.js
var React4 = __toESM(require_react());
var getClassNames = classNamesFunction();
var VerticalDividerBase = React4.forwardRef(function(props, ref) {
  var styles = props.styles, theme = props.theme, deprecatedGetClassNames = props.getClassNames, className = props.className;
  var classNames = getClassNames(styles, { theme, getClassNames: deprecatedGetClassNames, className });
  return React4.createElement(
    "span",
    { className: classNames.wrapper, ref },
    React4.createElement("span", { className: classNames.divider })
  );
});
VerticalDividerBase.displayName = "VerticalDividerBase";

// node_modules/@fluentui/react/lib/components/Divider/VerticalDivider.js
var VerticalDivider = styled(VerticalDividerBase, getStyles, void 0, {
  scope: "VerticalDivider"
});

// node_modules/@fluentui/react/lib/utilities/decorators/withResponsiveMode.js
var React5 = __toESM(require_react());
var ResponsiveMode;
(function(ResponsiveMode2) {
  ResponsiveMode2[ResponsiveMode2["small"] = 0] = "small";
  ResponsiveMode2[ResponsiveMode2["medium"] = 1] = "medium";
  ResponsiveMode2[ResponsiveMode2["large"] = 2] = "large";
  ResponsiveMode2[ResponsiveMode2["xLarge"] = 3] = "xLarge";
  ResponsiveMode2[ResponsiveMode2["xxLarge"] = 4] = "xxLarge";
  ResponsiveMode2[ResponsiveMode2["xxxLarge"] = 5] = "xxxLarge";
  ResponsiveMode2[ResponsiveMode2["unknown"] = 999] = "unknown";
})(ResponsiveMode || (ResponsiveMode = {}));
var RESPONSIVE_MAX_CONSTRAINT = [479, 639, 1023, 1365, 1919, 99999999];
var _defaultMode;
var _lastMode;
function setResponsiveMode(responsiveMode) {
  _defaultMode = responsiveMode;
}
function initializeResponsiveMode(element) {
  var currentWindow = getWindow(element);
  if (currentWindow) {
    getResponsiveMode(currentWindow);
  }
}
function getInitialResponsiveMode() {
  var _a2;
  return (_a2 = _defaultMode !== null && _defaultMode !== void 0 ? _defaultMode : _lastMode) !== null && _a2 !== void 0 ? _a2 : ResponsiveMode.large;
}
function withResponsiveMode(ComposedComponent) {
  var _a2;
  var resultClass = (_a2 = function(_super) {
    __extends(WithResponsiveMode, _super);
    function WithResponsiveMode(props) {
      var _this = _super.call(this, props) || this;
      _this._onResize = function() {
        var responsiveMode = getResponsiveMode(_this.context.window);
        if (responsiveMode !== _this.state.responsiveMode) {
          _this.setState({
            responsiveMode
          });
        }
      };
      _this._events = new EventGroup(_this);
      _this._updateComposedComponentRef = _this._updateComposedComponentRef.bind(_this);
      _this.state = {
        responsiveMode: getInitialResponsiveMode()
      };
      return _this;
    }
    WithResponsiveMode.prototype.componentDidMount = function() {
      this._events.on(this.context.window, "resize", this._onResize);
      this._onResize();
    };
    WithResponsiveMode.prototype.componentWillUnmount = function() {
      this._events.dispose();
    };
    WithResponsiveMode.prototype.render = function() {
      var responsiveMode = this.state.responsiveMode;
      return responsiveMode === ResponsiveMode.unknown ? null : React5.createElement(ComposedComponent, __assign({ ref: this._updateComposedComponentRef, responsiveMode }, this.props));
    };
    return WithResponsiveMode;
  }(BaseDecorator), _a2.contextType = WindowContext, _a2);
  return hoistStatics(ComposedComponent, resultClass);
}
function getWidthOfCurrentWindow(currentWindow) {
  try {
    return currentWindow.document.documentElement.clientWidth;
  } catch (e) {
    return currentWindow.innerWidth;
  }
}
function getResponsiveMode(currentWindow) {
  var responsiveMode = ResponsiveMode.small;
  if (currentWindow) {
    try {
      while (getWidthOfCurrentWindow(currentWindow) > RESPONSIVE_MAX_CONSTRAINT[responsiveMode]) {
        responsiveMode++;
      }
    } catch (e) {
      responsiveMode = getInitialResponsiveMode();
    }
    _lastMode = responsiveMode;
  } else {
    if (_defaultMode !== void 0) {
      responsiveMode = _defaultMode;
    } else {
      throw new Error("Content was rendered in a server environment without providing a default responsive mode. Call setResponsiveMode to define what the responsive mode is.");
    }
  }
  return responsiveMode;
}

// node_modules/@fluentui/react/lib/utilities/hooks/useResponsiveMode.js
var React6 = __toESM(require_react());
var useResponsiveMode = function(elementRef, overrideResponsiveMode) {
  var _a2 = React6.useState(getInitialResponsiveMode()), lastResponsiveMode = _a2[0], setLastResponsiveMode = _a2[1];
  var onResize = React6.useCallback(function() {
    var newResponsiveMode = getResponsiveMode(getWindow(elementRef.current));
    if (lastResponsiveMode !== newResponsiveMode) {
      setLastResponsiveMode(newResponsiveMode);
    }
  }, [elementRef, lastResponsiveMode]);
  var win = useWindow();
  useOnEvent(win, "resize", onResize);
  React6.useEffect(function() {
    if (overrideResponsiveMode === void 0) {
      onResize();
    }
  }, [overrideResponsiveMode]);
  return overrideResponsiveMode !== null && overrideResponsiveMode !== void 0 ? overrideResponsiveMode : lastResponsiveMode;
};

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenu.base.js
var React12 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenuItemWrapper/ContextualMenuAnchor.js
var React8 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenuItemWrapper/ContextualMenuItemWrapper.js
var React7 = __toESM(require_react());
var ContextualMenuItemWrapper = function(_super) {
  __extends(ContextualMenuItemWrapper2, _super);
  function ContextualMenuItemWrapper2(props) {
    var _this = _super.call(this, props) || this;
    _this._onItemMouseEnter = function(ev) {
      var _a2 = _this.props, item = _a2.item, onItemMouseEnter = _a2.onItemMouseEnter;
      if (onItemMouseEnter) {
        onItemMouseEnter(item, ev, ev.currentTarget);
      }
    };
    _this._onItemClick = function(ev) {
      var _a2 = _this.props, item = _a2.item, onItemClickBase = _a2.onItemClickBase;
      if (onItemClickBase) {
        onItemClickBase(item, ev, ev.currentTarget);
      }
    };
    _this._onItemMouseLeave = function(ev) {
      var _a2 = _this.props, item = _a2.item, onItemMouseLeave = _a2.onItemMouseLeave;
      if (onItemMouseLeave) {
        onItemMouseLeave(item, ev);
      }
    };
    _this._onItemKeyDown = function(ev) {
      var _a2 = _this.props, item = _a2.item, onItemKeyDown = _a2.onItemKeyDown;
      if (onItemKeyDown) {
        onItemKeyDown(item, ev);
      }
    };
    _this._onItemMouseMove = function(ev) {
      var _a2 = _this.props, item = _a2.item, onItemMouseMove = _a2.onItemMouseMove;
      if (onItemMouseMove) {
        onItemMouseMove(item, ev, ev.currentTarget);
      }
    };
    _this._getSubmenuTarget = function() {
      return void 0;
    };
    initializeComponentRef(_this);
    return _this;
  }
  ContextualMenuItemWrapper2.prototype.shouldComponentUpdate = function(newProps) {
    return !shallowCompare(newProps, this.props);
  };
  return ContextualMenuItemWrapper2;
}(React7.Component);

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenuItemWrapper/ContextualMenuAnchor.js
var ContextualMenuAnchor = function(_super) {
  __extends(ContextualMenuAnchor2, _super);
  function ContextualMenuAnchor2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._anchor = React8.createRef();
    _this._getMemoizedMenuButtonKeytipProps = memoizeFunction(function(keytipProps) {
      return __assign(__assign({}, keytipProps), { hasMenu: true });
    });
    _this._getSubmenuTarget = function() {
      return _this._anchor.current ? _this._anchor.current : void 0;
    };
    _this._onItemClick = function(ev) {
      var _a2 = _this.props, item = _a2.item, onItemClick = _a2.onItemClick;
      if (onItemClick) {
        onItemClick(item, ev);
      }
    };
    _this._renderAriaDescription = function(ariaDescription, className) {
      return ariaDescription ? React8.createElement("span", { id: _this._ariaDescriptionId, className }, ariaDescription) : null;
    };
    return _this;
  }
  ContextualMenuAnchor2.prototype.render = function() {
    var _this = this;
    var _a2 = this.props, item = _a2.item, classNames = _a2.classNames, index = _a2.index, focusableElementIndex = _a2.focusableElementIndex, totalItemCount = _a2.totalItemCount, hasCheckmarks = _a2.hasCheckmarks, hasIcons = _a2.hasIcons, _b2 = _a2.contextualMenuItemAs, ChildrenRenderer = _b2 === void 0 ? ContextualMenuItem : _b2, expandedMenuItemKey = _a2.expandedMenuItemKey, onItemClick = _a2.onItemClick, openSubMenu = _a2.openSubMenu, dismissSubMenu = _a2.dismissSubMenu, dismissMenu = _a2.dismissMenu;
    var anchorRel = item.rel;
    if (item.target && item.target.toLowerCase() === "_blank") {
      anchorRel = anchorRel ? anchorRel : "nofollow noopener noreferrer";
    }
    var itemHasSubmenu = hasSubmenu(item);
    var nativeProps = getNativeProps(item, anchorProperties);
    var disabled = isItemDisabled(item);
    var itemProps = item.itemProps, ariaDescription = item.ariaDescription;
    var keytipProps = item.keytipProps;
    if (keytipProps && itemHasSubmenu) {
      keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);
    }
    if (ariaDescription) {
      this._ariaDescriptionId = getId();
    }
    var ariaDescribedByIds = mergeAriaAttributeValues(item.ariaDescribedBy, ariaDescription ? this._ariaDescriptionId : void 0, nativeProps["aria-describedby"]);
    var additionalItemProperties = {
      "aria-describedby": ariaDescribedByIds
    };
    return React8.createElement(
      "div",
      null,
      React8.createElement(KeytipData, { keytipProps: item.keytipProps, ariaDescribedBy: ariaDescribedByIds, disabled }, function(keytipAttributes) {
        return React8.createElement(
          "a",
          __assign({}, additionalItemProperties, nativeProps, keytipAttributes, {
            ref: _this._anchor,
            href: item.href,
            target: item.target,
            rel: anchorRel,
            className: classNames.root,
            role: "menuitem",
            "aria-haspopup": itemHasSubmenu || void 0,
            "aria-expanded": itemHasSubmenu ? item.key === expandedMenuItemKey : void 0,
            "aria-posinset": focusableElementIndex + 1,
            "aria-setsize": totalItemCount,
            "aria-disabled": isItemDisabled(item),
            style: item.style,
            onClick: _this._onItemClick,
            onMouseEnter: _this._onItemMouseEnter,
            onMouseLeave: _this._onItemMouseLeave,
            onMouseMove: _this._onItemMouseMove,
            onKeyDown: itemHasSubmenu ? _this._onItemKeyDown : void 0
          }),
          React8.createElement(ChildrenRenderer, __assign({ componentRef: item.componentRef, item, classNames, index, onCheckmarkClick: hasCheckmarks && onItemClick ? onItemClick : void 0, hasIcons, openSubMenu, dismissSubMenu, dismissMenu, getSubmenuTarget: _this._getSubmenuTarget }, itemProps)),
          _this._renderAriaDescription(ariaDescription, classNames.screenReaderText)
        );
      })
    );
  };
  return ContextualMenuAnchor2;
}(ContextualMenuItemWrapper);

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenuItemWrapper/ContextualMenuButton.js
var React9 = __toESM(require_react());
var ContextualMenuButton = function(_super) {
  __extends(ContextualMenuButton2, _super);
  function ContextualMenuButton2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._btn = React9.createRef();
    _this._getMemoizedMenuButtonKeytipProps = memoizeFunction(function(keytipProps) {
      return __assign(__assign({}, keytipProps), { hasMenu: true });
    });
    _this._renderAriaDescription = function(ariaDescription, className) {
      return ariaDescription ? React9.createElement("span", { id: _this._ariaDescriptionId, className }, ariaDescription) : null;
    };
    _this._getSubmenuTarget = function() {
      return _this._btn.current ? _this._btn.current : void 0;
    };
    return _this;
  }
  ContextualMenuButton2.prototype.render = function() {
    var _this = this;
    var _a2 = this.props, item = _a2.item, classNames = _a2.classNames, index = _a2.index, focusableElementIndex = _a2.focusableElementIndex, totalItemCount = _a2.totalItemCount, hasCheckmarks = _a2.hasCheckmarks, hasIcons = _a2.hasIcons, _b2 = _a2.contextualMenuItemAs, ChildrenRenderer = _b2 === void 0 ? ContextualMenuItem : _b2, expandedMenuItemKey = _a2.expandedMenuItemKey, onItemMouseDown2 = _a2.onItemMouseDown, onItemClick = _a2.onItemClick, openSubMenu = _a2.openSubMenu, dismissSubMenu = _a2.dismissSubMenu, dismissMenu = _a2.dismissMenu;
    var isChecked = getIsChecked(item);
    var canCheck = isChecked !== null;
    var defaultRole = getMenuItemAriaRole(item);
    var itemHasSubmenu = hasSubmenu(item);
    var itemProps = item.itemProps, ariaLabel = item.ariaLabel, ariaDescription = item.ariaDescription;
    var buttonNativeProperties = getNativeProps(item, buttonProperties);
    delete buttonNativeProperties.disabled;
    var itemRole = item.role || defaultRole;
    if (ariaDescription) {
      this._ariaDescriptionId = getId();
    }
    var ariaDescribedByIds = mergeAriaAttributeValues(item.ariaDescribedBy, ariaDescription ? this._ariaDescriptionId : void 0, buttonNativeProperties["aria-describedby"]);
    var itemButtonProperties = {
      className: classNames.root,
      onClick: this._onItemClick,
      onKeyDown: itemHasSubmenu ? this._onItemKeyDown : void 0,
      onMouseEnter: this._onItemMouseEnter,
      onMouseLeave: this._onItemMouseLeave,
      onMouseDown: function(ev) {
        return onItemMouseDown2 ? onItemMouseDown2(item, ev) : void 0;
      },
      onMouseMove: this._onItemMouseMove,
      href: item.href,
      title: item.title,
      "aria-label": ariaLabel,
      "aria-describedby": ariaDescribedByIds,
      "aria-haspopup": itemHasSubmenu || void 0,
      "aria-expanded": itemHasSubmenu ? item.key === expandedMenuItemKey : void 0,
      "aria-posinset": focusableElementIndex + 1,
      "aria-setsize": totalItemCount,
      "aria-disabled": isItemDisabled(item),
      "aria-checked": (itemRole === "menuitemcheckbox" || itemRole === "menuitemradio") && canCheck ? !!isChecked : void 0,
      "aria-selected": itemRole === "menuitem" && canCheck ? !!isChecked : void 0,
      role: itemRole,
      style: item.style
    };
    var keytipProps = item.keytipProps;
    if (keytipProps && itemHasSubmenu) {
      keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);
    }
    return React9.createElement(KeytipData, { keytipProps, ariaDescribedBy: ariaDescribedByIds, disabled: isItemDisabled(item) }, function(keytipAttributes) {
      return React9.createElement(
        "button",
        __assign({ ref: _this._btn }, buttonNativeProperties, itemButtonProperties, keytipAttributes),
        React9.createElement(ChildrenRenderer, __assign({ componentRef: item.componentRef, item, classNames, index, onCheckmarkClick: hasCheckmarks && onItemClick ? onItemClick : void 0, hasIcons, openSubMenu, dismissSubMenu, dismissMenu, getSubmenuTarget: _this._getSubmenuTarget }, itemProps)),
        _this._renderAriaDescription(ariaDescription, classNames.screenReaderText)
      );
    });
  };
  return ContextualMenuButton2;
}(ContextualMenuItemWrapper);

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenuItemWrapper/ContextualMenuSplitButton.js
var React10 = __toESM(require_react());
var TouchIdleDelay = 500;
var ContextualMenuSplitButton = function(_super) {
  __extends(ContextualMenuSplitButton2, _super);
  function ContextualMenuSplitButton2(props) {
    var _this = _super.call(this, props) || this;
    _this._getMemoizedMenuButtonKeytipProps = memoizeFunction(function(keytipProps) {
      return __assign(__assign({}, keytipProps), { hasMenu: true });
    });
    _this._onItemKeyDown = function(ev) {
      var _a2 = _this.props, item = _a2.item, onItemKeyDown = _a2.onItemKeyDown;
      if (ev.which === KeyCodes.enter) {
        _this._executeItemClick(ev);
        ev.preventDefault();
        ev.stopPropagation();
      } else if (onItemKeyDown) {
        onItemKeyDown(item, ev);
      }
    };
    _this._getSubmenuTarget = function() {
      return _this._splitButton;
    };
    _this._renderAriaDescription = function(ariaDescription, className) {
      return ariaDescription ? React10.createElement("span", { id: _this._ariaDescriptionId, className }, ariaDescription) : null;
    };
    _this._onItemMouseEnterPrimary = function(ev) {
      var _a2 = _this.props, item = _a2.item, onItemMouseEnter = _a2.onItemMouseEnter;
      if (onItemMouseEnter) {
        onItemMouseEnter(__assign(__assign({}, item), { subMenuProps: void 0, items: void 0 }), ev, _this._splitButton);
      }
    };
    _this._onItemMouseEnterIcon = function(ev) {
      var _a2 = _this.props, item = _a2.item, onItemMouseEnter = _a2.onItemMouseEnter;
      if (onItemMouseEnter) {
        onItemMouseEnter(item, ev, _this._splitButton);
      }
    };
    _this._onItemMouseMovePrimary = function(ev) {
      var _a2 = _this.props, item = _a2.item, onItemMouseMove = _a2.onItemMouseMove;
      if (onItemMouseMove) {
        onItemMouseMove(__assign(__assign({}, item), { subMenuProps: void 0, items: void 0 }), ev, _this._splitButton);
      }
    };
    _this._onItemMouseMoveIcon = function(ev) {
      var _a2 = _this.props, item = _a2.item, onItemMouseMove = _a2.onItemMouseMove;
      if (onItemMouseMove) {
        onItemMouseMove(item, ev, _this._splitButton);
      }
    };
    _this._onIconItemClick = function(ev) {
      var _a2 = _this.props, item = _a2.item, onItemClickBase = _a2.onItemClickBase;
      if (onItemClickBase) {
        onItemClickBase(item, ev, _this._splitButton ? _this._splitButton : ev.currentTarget);
      }
    };
    _this._executeItemClick = function(ev) {
      var _a2 = _this.props, item = _a2.item, executeItemClick = _a2.executeItemClick, onItemClick = _a2.onItemClick;
      if (item.disabled || item.isDisabled) {
        return;
      }
      if (_this._processingTouch && onItemClick) {
        return onItemClick(item, ev);
      }
      if (executeItemClick) {
        executeItemClick(item, ev);
      }
    };
    _this._onTouchStart = function(ev) {
      if (_this._splitButton && !("onpointerdown" in _this._splitButton)) {
        _this._handleTouchAndPointerEvent(ev);
      }
    };
    _this._onPointerDown = function(ev) {
      if (ev.pointerType === "touch") {
        _this._handleTouchAndPointerEvent(ev);
        ev.preventDefault();
        ev.stopImmediatePropagation();
      }
    };
    _this._async = new Async(_this);
    _this._events = new EventGroup(_this);
    return _this;
  }
  ContextualMenuSplitButton2.prototype.componentDidMount = function() {
    if (this._splitButton && "onpointerdown" in this._splitButton) {
      this._events.on(this._splitButton, "pointerdown", this._onPointerDown, true);
    }
  };
  ContextualMenuSplitButton2.prototype.componentWillUnmount = function() {
    this._async.dispose();
    this._events.dispose();
  };
  ContextualMenuSplitButton2.prototype.render = function() {
    var _this = this;
    var _a2 = this.props, item = _a2.item, classNames = _a2.classNames, index = _a2.index, focusableElementIndex = _a2.focusableElementIndex, totalItemCount = _a2.totalItemCount, hasCheckmarks = _a2.hasCheckmarks, hasIcons = _a2.hasIcons, onItemMouseLeave = _a2.onItemMouseLeave, expandedMenuItemKey = _a2.expandedMenuItemKey;
    var itemHasSubmenu = hasSubmenu(item);
    var keytipProps = item.keytipProps;
    if (keytipProps) {
      keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);
    }
    var ariaDescription = item.ariaDescription;
    if (ariaDescription) {
      this._ariaDescriptionId = getId();
    }
    return React10.createElement(KeytipData, { keytipProps, disabled: isItemDisabled(item) }, function(keytipAttributes) {
      return React10.createElement(
        "div",
        { "data-ktp-target": keytipAttributes["data-ktp-target"], ref: function(splitButton) {
          return _this._splitButton = splitButton;
        }, role: getMenuItemAriaRole(item), "aria-label": item.ariaLabel, className: classNames.splitContainer, "aria-disabled": isItemDisabled(item), "aria-expanded": itemHasSubmenu ? item.key === expandedMenuItemKey : void 0, "aria-haspopup": true, "aria-describedby": mergeAriaAttributeValues(item.ariaDescribedBy, ariaDescription ? _this._ariaDescriptionId : void 0, keytipAttributes["aria-describedby"]), "aria-checked": item.isChecked || item.checked, "aria-posinset": focusableElementIndex + 1, "aria-setsize": totalItemCount, onMouseEnter: _this._onItemMouseEnterPrimary, onMouseLeave: onItemMouseLeave ? onItemMouseLeave.bind(_this, __assign(__assign({}, item), { subMenuProps: null, items: null })) : void 0, onMouseMove: _this._onItemMouseMovePrimary, onKeyDown: _this._onItemKeyDown, onClick: _this._executeItemClick, onTouchStart: _this._onTouchStart, tabIndex: 0, "data-is-focusable": true, "aria-roledescription": item["aria-roledescription"] },
        _this._renderSplitPrimaryButton(item, classNames, index, hasCheckmarks, hasIcons),
        _this._renderSplitDivider(item),
        _this._renderSplitIconButton(item, classNames, index, keytipAttributes),
        _this._renderAriaDescription(ariaDescription, classNames.screenReaderText)
      );
    });
  };
  ContextualMenuSplitButton2.prototype._renderSplitPrimaryButton = function(item, classNames, index, hasCheckmarks, hasIcons) {
    var _a2 = this.props, _b2 = _a2.contextualMenuItemAs, ChildrenRenderer = _b2 === void 0 ? ContextualMenuItem : _b2, onItemClick = _a2.onItemClick;
    var itemProps = {
      key: item.key,
      disabled: isItemDisabled(item) || item.primaryDisabled,
      name: item.name,
      text: item.text || item.name,
      secondaryText: item.secondaryText,
      className: classNames.splitPrimary,
      canCheck: item.canCheck,
      isChecked: item.isChecked,
      checked: item.checked,
      iconProps: item.iconProps,
      onRenderIcon: item.onRenderIcon,
      data: item.data,
      "data-is-focusable": false
    };
    var itemComponentProps = item.itemProps;
    return React10.createElement(
      "button",
      __assign({}, getNativeProps(itemProps, buttonProperties)),
      React10.createElement(ChildrenRenderer, __assign({ "data-is-focusable": false, item: itemProps, classNames, index, onCheckmarkClick: hasCheckmarks && onItemClick ? onItemClick : void 0, hasIcons }, itemComponentProps))
    );
  };
  ContextualMenuSplitButton2.prototype._renderSplitDivider = function(item) {
    var getDividerClassNames2 = item.getSplitButtonVerticalDividerClassNames || getSplitButtonVerticalDividerClassNames;
    return React10.createElement(VerticalDivider, { getClassNames: getDividerClassNames2 });
  };
  ContextualMenuSplitButton2.prototype._renderSplitIconButton = function(item, classNames, index, keytipAttributes) {
    var _a2 = this.props, _b2 = _a2.contextualMenuItemAs, ChildrenRenderer = _b2 === void 0 ? ContextualMenuItem : _b2, onItemMouseLeave = _a2.onItemMouseLeave, onItemMouseDown2 = _a2.onItemMouseDown, openSubMenu = _a2.openSubMenu, dismissSubMenu = _a2.dismissSubMenu, dismissMenu = _a2.dismissMenu;
    var itemProps = {
      onClick: this._onIconItemClick,
      disabled: isItemDisabled(item),
      className: classNames.splitMenu,
      subMenuProps: item.subMenuProps,
      submenuIconProps: item.submenuIconProps,
      split: true,
      key: item.key
    };
    var buttonProps = __assign(__assign({}, getNativeProps(itemProps, buttonProperties)), {
      onMouseEnter: this._onItemMouseEnterIcon,
      onMouseLeave: onItemMouseLeave ? onItemMouseLeave.bind(this, item) : void 0,
      onMouseDown: function(ev) {
        return onItemMouseDown2 ? onItemMouseDown2(item, ev) : void 0;
      },
      onMouseMove: this._onItemMouseMoveIcon,
      "data-is-focusable": false,
      "data-ktp-execute-target": keytipAttributes["data-ktp-execute-target"],
      "aria-hidden": true
    });
    var itemComponentProps = item.itemProps;
    return React10.createElement(
      "button",
      __assign({}, buttonProps),
      React10.createElement(ChildrenRenderer, __assign({ componentRef: item.componentRef, item: itemProps, classNames, index, hasIcons: false, openSubMenu, dismissSubMenu, dismissMenu, getSubmenuTarget: this._getSubmenuTarget }, itemComponentProps))
    );
  };
  ContextualMenuSplitButton2.prototype._handleTouchAndPointerEvent = function(ev) {
    var _this = this;
    var onTap = this.props.onTap;
    if (onTap) {
      onTap(ev);
    }
    if (this._lastTouchTimeoutId) {
      this._async.clearTimeout(this._lastTouchTimeoutId);
      this._lastTouchTimeoutId = void 0;
    }
    this._processingTouch = true;
    this._lastTouchTimeoutId = this._async.setTimeout(function() {
      _this._processingTouch = false;
      _this._lastTouchTimeoutId = void 0;
    }, TouchIdleDelay);
  };
  return ContextualMenuSplitButton2;
}(ContextualMenuItemWrapper);

// node_modules/@fluentui/react/lib/utilities/MenuContext/MenuContext.js
var React11 = __toESM(require_react());
var MenuContext = React11.createContext({});

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenu.base.js
var getClassNames2 = classNamesFunction();
var getContextualMenuItemClassNames = classNamesFunction();
var DEFAULT_PROPS = {
  items: [],
  shouldFocusOnMount: true,
  gapSpace: 0,
  directionalHint: DirectionalHint.bottomAutoEdge,
  beakWidth: 16
};
function getSubmenuItems(item, options) {
  var target = options === null || options === void 0 ? void 0 : options.target;
  var items = item.subMenuProps ? item.subMenuProps.items : item.items;
  if (items) {
    var overrideItems = [];
    for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
      var subItem = items_1[_i];
      if (subItem.preferMenuTargetAsEventTarget) {
        var onClick = subItem.onClick, contextItem = __rest(subItem, ["onClick"]);
        overrideItems.push(__assign(__assign({}, contextItem), { onClick: getOnClickWithOverrideTarget(onClick, target) }));
      } else {
        overrideItems.push(subItem);
      }
    }
    return overrideItems;
  }
}
function canAnyMenuItemsCheck(items) {
  return items.some(function(item) {
    if (item.canCheck) {
      return true;
    }
    if (item.sectionProps && item.sectionProps.items.some(function(submenuItem) {
      return submenuItem.canCheck === true;
    })) {
      return true;
    }
    return false;
  });
}
var NavigationIdleDelay = 250;
var COMPONENT_NAME = "ContextualMenu";
var _getMenuItemStylesFunction = memoizeFunction(function() {
  var styles = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    styles[_i] = arguments[_i];
  }
  return function(styleProps) {
    return concatStyleSetsWithProps.apply(void 0, __spreadArray([styleProps, getItemStyles], styles));
  };
});
function useVisibility(props, targetWindow) {
  var _a2 = props.hidden, hidden = _a2 === void 0 ? false : _a2, onMenuDismissed = props.onMenuDismissed, onMenuOpened = props.onMenuOpened;
  var previousHidden = usePrevious(hidden);
  var onMenuOpenedRef = React12.useRef(onMenuOpened);
  var onMenuClosedRef = React12.useRef(onMenuDismissed);
  var propsRef = React12.useRef(props);
  onMenuOpenedRef.current = onMenuOpened;
  onMenuClosedRef.current = onMenuDismissed;
  propsRef.current = props;
  React12.useEffect(function() {
    var _a3, _b2;
    if (hidden && previousHidden === false) {
      (_a3 = onMenuClosedRef.current) === null || _a3 === void 0 ? void 0 : _a3.call(onMenuClosedRef, propsRef.current);
    } else if (!hidden && previousHidden !== false) {
      (_b2 = onMenuOpenedRef.current) === null || _b2 === void 0 ? void 0 : _b2.call(onMenuOpenedRef, propsRef.current);
    }
  }, [hidden, previousHidden]);
  React12.useEffect(function() {
    return function() {
      var _a3;
      return (_a3 = onMenuClosedRef.current) === null || _a3 === void 0 ? void 0 : _a3.call(onMenuClosedRef, propsRef.current);
    };
  }, []);
}
function useSubMenuState(_a2, dismiss) {
  var hidden = _a2.hidden, items = _a2.items, theme = _a2.theme, className = _a2.className, id = _a2.id, menuTarget = _a2.target;
  var _b2 = React12.useState(), expandedMenuItemKey = _b2[0], setExpandedMenuItemKey = _b2[1];
  var _c2 = React12.useState(), submenuTarget = _c2[0], setSubmenuTarget = _c2[1];
  var _d2 = React12.useState(), shouldFocusOnContainer = _d2[0], setShouldFocusOnContainer = _d2[1];
  var subMenuId = useId(COMPONENT_NAME, id);
  var closeSubMenu = React12.useCallback(function() {
    setShouldFocusOnContainer(void 0);
    setExpandedMenuItemKey(void 0);
    setSubmenuTarget(void 0);
  }, []);
  var openSubMenu = React12.useCallback(function(_a3, target, focusContainer) {
    var submenuItemKey = _a3.key;
    if (expandedMenuItemKey === submenuItemKey) {
      return;
    }
    target.focus();
    setShouldFocusOnContainer(focusContainer);
    setExpandedMenuItemKey(submenuItemKey);
    setSubmenuTarget(target);
  }, [expandedMenuItemKey]);
  React12.useEffect(function() {
    if (hidden) {
      closeSubMenu();
    }
  }, [hidden, closeSubMenu]);
  var onSubMenuDismiss = useOnSubmenuDismiss(dismiss, closeSubMenu);
  var getSubmenuProps = function() {
    var item = findItemByKeyFromItems(expandedMenuItemKey, items);
    var submenuProps = null;
    if (item) {
      submenuProps = {
        items: getSubmenuItems(item, { target: menuTarget }),
        target: submenuTarget,
        onDismiss: onSubMenuDismiss,
        isSubMenu: true,
        id: subMenuId,
        shouldFocusOnMount: true,
        shouldFocusOnContainer,
        directionalHint: getRTL(theme) ? DirectionalHint.leftTopEdge : DirectionalHint.rightTopEdge,
        className,
        gapSpace: 0,
        isBeakVisible: false
      };
      if (item.subMenuProps) {
        assign(submenuProps, item.subMenuProps);
      }
      if (item.preferMenuTargetAsEventTarget) {
        var onItemClick = item.onItemClick;
        submenuProps.onItemClick = getOnClickWithOverrideTarget(onItemClick, menuTarget);
      }
    }
    return submenuProps;
  };
  return [expandedMenuItemKey, openSubMenu, getSubmenuProps, onSubMenuDismiss];
}
function useShouldUpdateFocusOnMouseMove(_a2) {
  var delayUpdateFocusOnHover = _a2.delayUpdateFocusOnHover, hidden = _a2.hidden;
  var shouldUpdateFocusOnMouseEvent = React12.useRef(!delayUpdateFocusOnHover);
  var gotMouseMove = React12.useRef(false);
  React12.useEffect(function() {
    shouldUpdateFocusOnMouseEvent.current = !delayUpdateFocusOnHover;
    gotMouseMove.current = hidden ? false : !delayUpdateFocusOnHover && gotMouseMove.current;
  }, [delayUpdateFocusOnHover, hidden]);
  var onMenuFocusCapture = React12.useCallback(function() {
    if (delayUpdateFocusOnHover) {
      shouldUpdateFocusOnMouseEvent.current = false;
    }
  }, [delayUpdateFocusOnHover]);
  return [shouldUpdateFocusOnMouseEvent, gotMouseMove, onMenuFocusCapture];
}
function usePreviousActiveElement(_a2, targetWindow) {
  var hidden = _a2.hidden, onRestoreFocus = _a2.onRestoreFocus;
  var previousActiveElement = React12.useRef();
  var tryFocusPreviousActiveElement = React12.useCallback(function(options) {
    var _a3, _b2;
    if (onRestoreFocus) {
      onRestoreFocus(options);
    } else if (options === null || options === void 0 ? void 0 : options.documentContainsFocus) {
      (_b2 = (_a3 = previousActiveElement.current) === null || _a3 === void 0 ? void 0 : _a3.focus) === null || _b2 === void 0 ? void 0 : _b2.call(_a3);
    }
  }, [onRestoreFocus]);
  useIsomorphicLayoutEffect(function() {
    var _a3;
    if (!hidden) {
      previousActiveElement.current = targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document.activeElement;
    } else if (previousActiveElement.current) {
      tryFocusPreviousActiveElement({
        originalElement: previousActiveElement.current,
        containsFocus: true,
        documentContainsFocus: ((_a3 = getDocument()) === null || _a3 === void 0 ? void 0 : _a3.hasFocus()) || false
      });
      previousActiveElement.current = void 0;
    }
  }, [hidden, targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document.activeElement, tryFocusPreviousActiveElement]);
  return [tryFocusPreviousActiveElement];
}
function useKeyHandlers(_a2, dismiss, hostElement, openSubMenu) {
  var theme = _a2.theme, isSubMenu = _a2.isSubMenu, _b2 = _a2.focusZoneProps, _c2 = _b2 === void 0 ? {} : _b2, checkForNoWrap = _c2.checkForNoWrap, _d2 = _c2.direction, focusZoneDirection = _d2 === void 0 ? FocusZoneDirection.vertical : _d2;
  var lastKeyDownWasAltOrMeta = React12.useRef();
  var keyHandler = function(ev, shouldHandleKey, dismissAllMenus) {
    var handled = false;
    if (shouldHandleKey(ev)) {
      dismiss(ev, dismissAllMenus);
      ev.preventDefault();
      ev.stopPropagation();
      handled = true;
    }
    return handled;
  };
  var shouldCloseSubMenu = function(ev) {
    var submenuCloseKey = getRTL(theme) ? KeyCodes.right : KeyCodes.left;
    if (ev.which !== submenuCloseKey || !isSubMenu) {
      return false;
    }
    return !!(focusZoneDirection === FocusZoneDirection.vertical || checkForNoWrap && !shouldWrapFocus(ev.target, "data-no-horizontal-wrap"));
  };
  var shouldHandleKeyDown = function(ev) {
    return ev.which === KeyCodes.escape || shouldCloseSubMenu(ev) || ev.which === KeyCodes.up && (ev.altKey || ev.metaKey);
  };
  var onKeyDown = function(ev) {
    lastKeyDownWasAltOrMeta.current = isAltOrMeta(ev);
    var dismissAllMenus = ev.which === KeyCodes.escape && (isMac() || isIOS());
    return keyHandler(ev, shouldHandleKeyDown, dismissAllMenus);
  };
  var shouldHandleKeyUp = function(ev) {
    var keyPressIsAltOrMetaAlone = lastKeyDownWasAltOrMeta.current && isAltOrMeta(ev);
    lastKeyDownWasAltOrMeta.current = false;
    return !!keyPressIsAltOrMetaAlone && !(isIOS() || isMac());
  };
  var onKeyUp = function(ev) {
    return keyHandler(ev, shouldHandleKeyUp, true);
  };
  var onMenuKeyDown = function(ev) {
    var handled = onKeyDown(ev);
    if (handled || !hostElement.current) {
      return;
    }
    var hasModifier = !!(ev.altKey || ev.metaKey);
    var isUp = ev.which === KeyCodes.up;
    var isDown = ev.which === KeyCodes.down;
    if (!hasModifier && (isUp || isDown)) {
      var elementToFocus = isUp ? getLastFocusable(hostElement.current, hostElement.current.lastChild, true) : getFirstFocusable(hostElement.current, hostElement.current.firstChild, true);
      if (elementToFocus) {
        elementToFocus.focus();
        ev.preventDefault();
        ev.stopPropagation();
      }
    }
  };
  var onItemKeyDown = function(item, ev) {
    var openKey = getRTL(theme) ? KeyCodes.left : KeyCodes.right;
    if (!item.disabled && (ev.which === openKey || ev.which === KeyCodes.enter || ev.which === KeyCodes.down && (ev.altKey || ev.metaKey))) {
      openSubMenu(item, ev.currentTarget);
      ev.preventDefault();
    }
  };
  return [onKeyDown, onKeyUp, onMenuKeyDown, onItemKeyDown];
}
function useScrollHandler(asyncTracker) {
  var isScrollIdle = React12.useRef(true);
  var scrollIdleTimeoutId = React12.useRef();
  var onScroll = function() {
    if (!isScrollIdle.current && scrollIdleTimeoutId.current !== void 0) {
      asyncTracker.clearTimeout(scrollIdleTimeoutId.current);
      scrollIdleTimeoutId.current = void 0;
    } else {
      isScrollIdle.current = false;
    }
    scrollIdleTimeoutId.current = asyncTracker.setTimeout(function() {
      isScrollIdle.current = true;
    }, NavigationIdleDelay);
  };
  return [onScroll, isScrollIdle];
}
function useOnSubmenuDismiss(dismiss, closeSubMenu) {
  var isMountedRef = React12.useRef(false);
  React12.useEffect(function() {
    isMountedRef.current = true;
    return function() {
      isMountedRef.current = false;
    };
  }, []);
  var onSubMenuDismiss = function(ev, dismissAll) {
    if (dismissAll) {
      dismiss(ev, dismissAll);
    } else if (isMountedRef.current) {
      closeSubMenu();
    }
  };
  return onSubMenuDismiss;
}
function useSubmenuEnterTimer(_a2, asyncTracker) {
  var _b2 = _a2.subMenuHoverDelay, subMenuHoverDelay = _b2 === void 0 ? NavigationIdleDelay : _b2;
  var enterTimerRef = React12.useRef(void 0);
  var cancelSubMenuTimer = function() {
    if (enterTimerRef.current !== void 0) {
      asyncTracker.clearTimeout(enterTimerRef.current);
      enterTimerRef.current = void 0;
    }
  };
  var startSubmenuTimer = function(onTimerExpired) {
    enterTimerRef.current = asyncTracker.setTimeout(function() {
      onTimerExpired();
      cancelSubMenuTimer();
    }, subMenuHoverDelay);
  };
  return [cancelSubMenuTimer, startSubmenuTimer, enterTimerRef];
}
function useMouseHandlers(props, isScrollIdle, subMenuEntryTimer, targetWindow, shouldUpdateFocusOnMouseEvent, gotMouseMove, expandedMenuItemKey, hostElement, startSubmenuTimer, cancelSubMenuTimer, openSubMenu, onSubMenuDismiss, dismiss) {
  var menuTarget = props.target;
  var onItemMouseEnterBase = function(item, ev, target) {
    if (shouldUpdateFocusOnMouseEvent.current) {
      gotMouseMove.current = true;
    }
    if (shouldIgnoreMouseEvent()) {
      return;
    }
    updateFocusOnMouseEvent(item, ev, target);
  };
  var onItemMouseMoveBase = function(item, ev, target) {
    var targetElement = ev.currentTarget;
    if (shouldUpdateFocusOnMouseEvent.current) {
      gotMouseMove.current = true;
    } else {
      return;
    }
    if (!isScrollIdle.current || subMenuEntryTimer.current !== void 0 || targetElement === (targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document.activeElement)) {
      return;
    }
    updateFocusOnMouseEvent(item, ev, target);
  };
  var shouldIgnoreMouseEvent = function() {
    return !isScrollIdle.current || !gotMouseMove.current;
  };
  var onMouseItemLeave = function(item, ev) {
    var _a2;
    if (shouldIgnoreMouseEvent()) {
      return;
    }
    cancelSubMenuTimer();
    if (expandedMenuItemKey !== void 0) {
      return;
    }
    if (hostElement.current.setActive) {
      try {
        hostElement.current.setActive();
      } catch (e) {
      }
    } else {
      (_a2 = hostElement.current) === null || _a2 === void 0 ? void 0 : _a2.focus();
    }
  };
  var updateFocusOnMouseEvent = function(item, ev, target) {
    var targetElement = target ? target : ev.currentTarget;
    if (item.key === expandedMenuItemKey) {
      return;
    }
    cancelSubMenuTimer();
    if (expandedMenuItemKey === void 0) {
      targetElement.focus();
    }
    if (hasSubmenu(item)) {
      ev.stopPropagation();
      startSubmenuTimer(function() {
        targetElement.focus();
        openSubMenu(item, targetElement, true);
      });
    } else {
      startSubmenuTimer(function() {
        onSubMenuDismiss(ev);
        targetElement.focus();
      });
    }
  };
  var onItemClick = function(item, ev) {
    onItemClickBase(item, ev, ev.currentTarget);
  };
  var onItemClickBase = function(item, ev, target) {
    var items = getSubmenuItems(item, { target: menuTarget });
    cancelSubMenuTimer();
    if (!hasSubmenu(item) && (!items || !items.length)) {
      executeItemClick(item, ev);
    } else {
      if (item.key !== expandedMenuItemKey) {
        var shouldFocusOnContainer = typeof props.shouldFocusOnContainer === "boolean" ? props.shouldFocusOnContainer : ev.nativeEvent.pointerType === "mouse";
        openSubMenu(item, target, shouldFocusOnContainer);
      }
    }
    ev.stopPropagation();
    ev.preventDefault();
  };
  var onAnchorClick = function(item, ev) {
    executeItemClick(item, ev);
    ev.stopPropagation();
  };
  var executeItemClick = function(item, ev) {
    if (item.disabled || item.isDisabled) {
      return;
    }
    if (item.preferMenuTargetAsEventTarget) {
      overrideTarget(ev, menuTarget);
    }
    var shouldDismiss = false;
    if (item.onClick) {
      shouldDismiss = !!item.onClick(ev, item);
    } else if (props.onItemClick) {
      shouldDismiss = !!props.onItemClick(ev, item);
    }
    if (shouldDismiss || !ev.defaultPrevented) {
      dismiss(ev, true);
    }
  };
  return [
    onItemMouseEnterBase,
    onItemMouseMoveBase,
    onMouseItemLeave,
    onItemClick,
    onAnchorClick,
    executeItemClick,
    onItemClickBase
  ];
}
var ContextualMenuBase = React12.memo(React12.forwardRef(function(propsWithoutDefaults, forwardedRef) {
  var _a2;
  var _b2 = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults), ref = _b2.ref, props = __rest(_b2, ["ref"]);
  var hostElement = React12.useRef(null);
  var asyncTracker = useAsync();
  var menuId = useId(COMPONENT_NAME, props.id);
  useWarnings({
    name: COMPONENT_NAME,
    props,
    deprecations: {
      getMenuClassNames: "styles"
    }
  });
  var dismiss = function(ev, dismissAll) {
    var _a3;
    return (_a3 = props.onDismiss) === null || _a3 === void 0 ? void 0 : _a3.call(props, ev, dismissAll);
  };
  var _c2 = useTarget(props.target, hostElement), targetRef = _c2[0], targetWindow = _c2[1];
  var tryFocusPreviousActiveElement = usePreviousActiveElement(props, targetWindow)[0];
  var _d2 = useSubMenuState(props, dismiss), expandedMenuItemKey = _d2[0], openSubMenu = _d2[1], getSubmenuProps = _d2[2], onSubMenuDismiss = _d2[3];
  var _e2 = useShouldUpdateFocusOnMouseMove(props), shouldUpdateFocusOnMouseEvent = _e2[0], gotMouseMove = _e2[1], onMenuFocusCapture = _e2[2];
  var _f = useScrollHandler(asyncTracker), onScroll = _f[0], isScrollIdle = _f[1];
  var _g = useSubmenuEnterTimer(props, asyncTracker), cancelSubMenuTimer = _g[0], startSubmenuTimer = _g[1], subMenuEntryTimer = _g[2];
  var responsiveMode = useResponsiveMode(hostElement, props.responsiveMode);
  useVisibility(props, targetWindow);
  var _h = useKeyHandlers(props, dismiss, hostElement, openSubMenu), onKeyDown = _h[0], onKeyUp = _h[1], onMenuKeyDown = _h[2], onItemKeyDown = _h[3];
  var _j = useMouseHandlers(props, isScrollIdle, subMenuEntryTimer, targetWindow, shouldUpdateFocusOnMouseEvent, gotMouseMove, expandedMenuItemKey, hostElement, startSubmenuTimer, cancelSubMenuTimer, openSubMenu, onSubMenuDismiss, dismiss), onItemMouseEnterBase = _j[0], onItemMouseMoveBase = _j[1], onMouseItemLeave = _j[2], onItemClick = _j[3], onAnchorClick = _j[4], executeItemClick = _j[5], onItemClickBase = _j[6];
  var onDefaultRenderMenuList = function(menuListProps, menuClassNames, defaultRender) {
    var indexCorrection = 0;
    var items2 = menuListProps.items, totalItemCount = menuListProps.totalItemCount, hasCheckmarks2 = menuListProps.hasCheckmarks, hasIcons2 = menuListProps.hasIcons;
    return React12.createElement("ul", { className: menuClassNames.list, onKeyDown, onKeyUp, role: "presentation" }, items2.map(function(item2, index) {
      var menuItem = renderMenuItem(item2, index, indexCorrection, totalItemCount, hasCheckmarks2, hasIcons2, menuClassNames);
      if (item2.itemType !== ContextualMenuItemType.Divider && item2.itemType !== ContextualMenuItemType.Header) {
        var indexIncrease = item2.customOnRenderListLength ? item2.customOnRenderListLength : 1;
        indexCorrection += indexIncrease;
      }
      return menuItem;
    }));
  };
  var renderFocusZone = function(children, adjustedFocusZoneProps2) {
    var _a3 = props.focusZoneAs, ChildrenRenderer = _a3 === void 0 ? FocusZone : _a3;
    return React12.createElement(ChildrenRenderer, __assign({}, adjustedFocusZoneProps2), children);
  };
  var renderMenuItem = function(item2, index, focusableElementIndex, totalItemCount, hasCheckmarks2, hasIcons2, menuClassNames) {
    var _a3;
    var renderedItems = [];
    var iconProps = item2.iconProps || { iconName: "None" };
    var getItemClassNames2 = item2.getItemClassNames, itemProps = item2.itemProps;
    var styles2 = itemProps ? itemProps.styles : void 0;
    var dividerClassName = item2.itemType === ContextualMenuItemType.Divider ? item2.className : void 0;
    var subMenuIconClassName = item2.submenuIconProps ? item2.submenuIconProps.className : "";
    var itemClassNames;
    if (getItemClassNames2) {
      itemClassNames = getItemClassNames2(props.theme, isItemDisabled(item2), expandedMenuItemKey === item2.key, !!getIsChecked(item2), !!item2.href, iconProps.iconName !== "None", item2.className, dividerClassName, iconProps.className, subMenuIconClassName, item2.primaryDisabled);
    } else {
      var itemStyleProps = {
        theme: props.theme,
        disabled: isItemDisabled(item2),
        expanded: expandedMenuItemKey === item2.key,
        checked: !!getIsChecked(item2),
        isAnchorLink: !!item2.href,
        knownIcon: iconProps.iconName !== "None",
        itemClassName: item2.className,
        dividerClassName,
        iconClassName: iconProps.className,
        subMenuClassName: subMenuIconClassName,
        primaryDisabled: item2.primaryDisabled
      };
      itemClassNames = getContextualMenuItemClassNames(_getMenuItemStylesFunction((_a3 = menuClassNames.subComponentStyles) === null || _a3 === void 0 ? void 0 : _a3.menuItem, styles2), itemStyleProps);
    }
    if (item2.text === "-" || item2.name === "-") {
      item2.itemType = ContextualMenuItemType.Divider;
    }
    switch (item2.itemType) {
      case ContextualMenuItemType.Divider:
        renderedItems.push(renderSeparator(index, itemClassNames));
        break;
      case ContextualMenuItemType.Header:
        renderedItems.push(renderSeparator(index, itemClassNames));
        var headerItem = renderHeaderMenuItem(item2, itemClassNames, menuClassNames, index, hasCheckmarks2, hasIcons2);
        renderedItems.push(renderListItem(headerItem, item2.key || index, itemClassNames, item2.title));
        break;
      case ContextualMenuItemType.Section:
        renderedItems.push(renderSectionItem(item2, itemClassNames, menuClassNames, index, hasCheckmarks2, hasIcons2));
        break;
      default:
        var defaultRenderNormalItem = function() {
          return renderNormalItem(item2, itemClassNames, index, focusableElementIndex, totalItemCount, hasCheckmarks2, hasIcons2);
        };
        var menuItem = props.onRenderContextualMenuItem ? props.onRenderContextualMenuItem(item2, defaultRenderNormalItem) : defaultRenderNormalItem();
        renderedItems.push(renderListItem(menuItem, item2.key || index, itemClassNames, item2.title));
        break;
    }
    return React12.createElement(React12.Fragment, { key: item2.key }, renderedItems);
  };
  var defaultMenuItemRenderer = function(item2, menuClassNames) {
    var index = item2.index, focusableElementIndex = item2.focusableElementIndex, totalItemCount = item2.totalItemCount, hasCheckmarks2 = item2.hasCheckmarks, hasIcons2 = item2.hasIcons;
    return renderMenuItem(item2, index, focusableElementIndex, totalItemCount, hasCheckmarks2, hasIcons2, menuClassNames);
  };
  var renderSectionItem = function(sectionItem, itemClassNames, menuClassNames, index, hasCheckmarks2, hasIcons2) {
    var sectionProps = sectionItem.sectionProps;
    if (!sectionProps) {
      return;
    }
    var headerItem;
    var groupProps;
    if (sectionProps.title) {
      var headerContextualMenuItem = void 0;
      var ariaLabelledby = "";
      if (typeof sectionProps.title === "string") {
        var id_1 = menuId + sectionProps.title.replace(/\s/g, "");
        headerContextualMenuItem = {
          key: "section-" + sectionProps.title + "-title",
          itemType: ContextualMenuItemType.Header,
          text: sectionProps.title,
          id: id_1
        };
        ariaLabelledby = id_1;
      } else {
        var id_2 = sectionProps.title.id || menuId + sectionProps.title.key.replace(/\s/g, "");
        headerContextualMenuItem = __assign(__assign({}, sectionProps.title), { id: id_2 });
        ariaLabelledby = id_2;
      }
      if (headerContextualMenuItem) {
        groupProps = {
          role: "group",
          "aria-labelledby": ariaLabelledby
        };
        headerItem = renderHeaderMenuItem(headerContextualMenuItem, itemClassNames, menuClassNames, index, hasCheckmarks2, hasIcons2);
      }
    }
    if (sectionProps.items && sectionProps.items.length > 0) {
      return React12.createElement(
        "li",
        { role: "presentation", key: sectionProps.key || sectionItem.key || "section-" + index },
        React12.createElement(
          "div",
          __assign({}, groupProps),
          React12.createElement(
            "ul",
            { className: menuClassNames.list, role: "presentation" },
            sectionProps.topDivider && renderSeparator(index, itemClassNames, true, true),
            headerItem && renderListItem(headerItem, sectionItem.key || index, itemClassNames, sectionItem.title),
            sectionProps.items.map(function(contextualMenuItem, itemsIndex) {
              return renderMenuItem(contextualMenuItem, itemsIndex, itemsIndex, sectionProps.items.length, hasCheckmarks2, hasIcons2, menuClassNames);
            }),
            sectionProps.bottomDivider && renderSeparator(index, itemClassNames, false, true)
          )
        )
      );
    }
  };
  var renderListItem = function(content, key, classNames2, title2) {
    return React12.createElement("li", { role: "presentation", title: title2, key, className: classNames2.item }, content);
  };
  var renderSeparator = function(index, classNames2, top, fromSection) {
    if (fromSection || index > 0) {
      return React12.createElement("li", { role: "separator", key: "separator-" + index + (top === void 0 ? "" : top ? "-top" : "-bottom"), className: classNames2.divider, "aria-hidden": "true" });
    }
    return null;
  };
  var renderNormalItem = function(item2, classNames2, index, focusableElementIndex, totalItemCount, hasCheckmarks2, hasIcons2) {
    if (item2.onRender) {
      return item2.onRender(__assign({ "aria-posinset": focusableElementIndex + 1, "aria-setsize": totalItemCount }, item2), dismiss);
    }
    var contextualMenuItemAs = props.contextualMenuItemAs;
    var commonProps = {
      item: item2,
      classNames: classNames2,
      index,
      focusableElementIndex,
      totalItemCount,
      hasCheckmarks: hasCheckmarks2,
      hasIcons: hasIcons2,
      contextualMenuItemAs,
      onItemMouseEnter: onItemMouseEnterBase,
      onItemMouseLeave: onMouseItemLeave,
      onItemMouseMove: onItemMouseMoveBase,
      onItemMouseDown,
      executeItemClick,
      onItemKeyDown,
      expandedMenuItemKey,
      openSubMenu,
      dismissSubMenu: onSubMenuDismiss,
      dismissMenu: dismiss
    };
    if (item2.href) {
      return React12.createElement(ContextualMenuAnchor, __assign({}, commonProps, { onItemClick: onAnchorClick }));
    }
    if (item2.split && hasSubmenu(item2)) {
      return React12.createElement(ContextualMenuSplitButton, __assign({}, commonProps, { onItemClick, onItemClickBase, onTap: cancelSubMenuTimer }));
    }
    return React12.createElement(ContextualMenuButton, __assign({}, commonProps, { onItemClick, onItemClickBase }));
  };
  var renderHeaderMenuItem = function(item2, itemClassNames, menuClassNames, index, hasCheckmarks2, hasIcons2) {
    var _a3 = props.contextualMenuItemAs, ChildrenRenderer = _a3 === void 0 ? ContextualMenuItem : _a3;
    var itemProps = item2.itemProps, id2 = item2.id;
    var divHtmlProperties = itemProps && getNativeProps(itemProps, divProperties);
    return React12.createElement(
      "div",
      __assign({ id: id2, className: menuClassNames.header }, divHtmlProperties, { style: item2.style }),
      React12.createElement(ChildrenRenderer, __assign({ item: item2, classNames: itemClassNames, index, onCheckmarkClick: hasCheckmarks2 ? onItemClick : void 0, hasIcons: hasIcons2 }, itemProps))
    );
  };
  var isBeakVisible = props.isBeakVisible;
  var items = props.items, labelElementId = props.labelElementId, id = props.id, className = props.className, beakWidth = props.beakWidth, directionalHint = props.directionalHint, directionalHintForRTL = props.directionalHintForRTL, alignTargetEdge = props.alignTargetEdge, gapSpace = props.gapSpace, coverTarget = props.coverTarget, ariaLabel = props.ariaLabel, doNotLayer = props.doNotLayer, target = props.target, bounds = props.bounds, useTargetWidth = props.useTargetWidth, useTargetAsMinWidth = props.useTargetAsMinWidth, directionalHintFixed = props.directionalHintFixed, shouldFocusOnMount = props.shouldFocusOnMount, shouldFocusOnContainer = props.shouldFocusOnContainer, title = props.title, styles = props.styles, theme = props.theme, calloutProps = props.calloutProps, _k = props.onRenderSubMenu, onRenderSubMenu2 = _k === void 0 ? onDefaultRenderSubMenu : _k, _l = props.onRenderMenuList, onRenderMenuList = _l === void 0 ? function(menuListProps, defaultRender) {
    return onDefaultRenderMenuList(menuListProps, classNames, defaultRender);
  } : _l, focusZoneProps = props.focusZoneProps, getMenuClassNames = props.getMenuClassNames;
  var classNames = getMenuClassNames ? getMenuClassNames(theme, className) : getClassNames2(styles, {
    theme,
    className
  });
  var hasIcons = itemsHaveIcons(items);
  function itemsHaveIcons(contextualMenuItems) {
    for (var _i2 = 0, contextualMenuItems_1 = contextualMenuItems; _i2 < contextualMenuItems_1.length; _i2++) {
      var item2 = contextualMenuItems_1[_i2];
      if (item2.iconProps) {
        return true;
      }
      if (item2.itemType === ContextualMenuItemType.Section && item2.sectionProps && itemsHaveIcons(item2.sectionProps.items)) {
        return true;
      }
    }
    return false;
  }
  var adjustedFocusZoneProps = __assign(__assign({ direction: FocusZoneDirection.vertical, handleTabKey: FocusZoneTabbableElements.all, isCircularNavigation: true }, focusZoneProps), { className: css(classNames.root, (_a2 = props.focusZoneProps) === null || _a2 === void 0 ? void 0 : _a2.className) });
  var hasCheckmarks = canAnyMenuItemsCheck(items);
  var submenuProps = expandedMenuItemKey && props.hidden !== true ? getSubmenuProps() : null;
  isBeakVisible = isBeakVisible === void 0 ? responsiveMode <= ResponsiveMode.medium : isBeakVisible;
  var contextMenuStyle;
  var targetAsHtmlElement = targetRef.current;
  if ((useTargetWidth || useTargetAsMinWidth) && targetAsHtmlElement && targetAsHtmlElement.offsetWidth) {
    var targetBoundingRect = targetAsHtmlElement.getBoundingClientRect();
    var targetWidth = targetBoundingRect.width - 2;
    if (useTargetWidth) {
      contextMenuStyle = {
        width: targetWidth
      };
    } else if (useTargetAsMinWidth) {
      contextMenuStyle = {
        minWidth: targetWidth
      };
    }
  }
  if (items && items.length > 0) {
    var totalItemCount_1 = 0;
    for (var _i = 0, items_2 = items; _i < items_2.length; _i++) {
      var item = items_2[_i];
      if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {
        var itemCount = item.customOnRenderListLength ? item.customOnRenderListLength : 1;
        totalItemCount_1 += itemCount;
      }
    }
    var calloutStyles_1 = classNames.subComponentStyles ? classNames.subComponentStyles.callout : void 0;
    return React12.createElement(MenuContext.Consumer, null, function(menuContext) {
      return React12.createElement(
        Callout,
        __assign({ styles: calloutStyles_1, onRestoreFocus: tryFocusPreviousActiveElement }, calloutProps, { target: target || menuContext.target, isBeakVisible, beakWidth, directionalHint, directionalHintForRTL, gapSpace, coverTarget, doNotLayer, className: css("ms-ContextualMenu-Callout", calloutProps && calloutProps.className), setInitialFocus: shouldFocusOnMount, onDismiss: props.onDismiss || menuContext.onDismiss, onScroll, bounds, directionalHintFixed, alignTargetEdge, hidden: props.hidden || menuContext.hidden, ref: forwardedRef }),
        React12.createElement(
          "div",
          { style: contextMenuStyle, ref: hostElement, id, className: classNames.container, tabIndex: shouldFocusOnContainer ? 0 : -1, onKeyDown: onMenuKeyDown, onKeyUp, onFocusCapture: onMenuFocusCapture, "aria-label": ariaLabel, "aria-labelledby": labelElementId, role: "menu" },
          title && React12.createElement(
            "div",
            { className: classNames.title },
            " ",
            title,
            " "
          ),
          items && items.length ? renderFocusZone(onRenderMenuList({
            ariaLabel,
            items,
            totalItemCount: totalItemCount_1,
            hasCheckmarks,
            hasIcons,
            defaultMenuItemRenderer: function(item2) {
              return defaultMenuItemRenderer(item2, classNames);
            },
            labelElementId
          }, function(menuListProps, defaultRender) {
            return onDefaultRenderMenuList(menuListProps, classNames, defaultRender);
          }), adjustedFocusZoneProps) : null,
          submenuProps && onRenderSubMenu2(submenuProps, onDefaultRenderSubMenu)
        )
      );
    });
  } else {
    return null;
  }
}), function(prevProps, newProps) {
  if (!newProps.shouldUpdateWhenHidden && prevProps.hidden && newProps.hidden) {
    return true;
  }
  return shallowCompare(prevProps, newProps);
});
ContextualMenuBase.displayName = "ContextualMenuBase";
function isAltOrMeta(ev) {
  return ev.which === KeyCodes.alt || ev.key === "Meta";
}
function onItemMouseDown(item, ev) {
  var _a2;
  (_a2 = item.onMouseDown) === null || _a2 === void 0 ? void 0 : _a2.call(item, item, ev);
}
function onDefaultRenderSubMenu(subMenuProps, defaultRender) {
  throw Error("ContextualMenuBase: onRenderSubMenu callback is null or undefined. Please ensure to set `onRenderSubMenu` property either manually or with `styled` helper.");
}
function findItemByKeyFromItems(key, items) {
  for (var _i = 0, items_3 = items; _i < items_3.length; _i++) {
    var item = items_3[_i];
    if (item.itemType === ContextualMenuItemType.Section && item.sectionProps) {
      var match = findItemByKeyFromItems(key, item.sectionProps.items);
      if (match) {
        return match;
      }
    } else if (item.key && item.key === key) {
      return item;
    }
  }
}
function getOnClickWithOverrideTarget(onClick, target) {
  return onClick ? function(ev, item) {
    overrideTarget(ev, target);
    return onClick(ev, item);
  } : onClick;
}
function overrideTarget(ev, target) {
  if (ev && target) {
    ev.persist();
    if (target instanceof Event) {
      ev.target = target.target;
    } else if (target instanceof Element) {
      ev.target = target;
    }
  }
}

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenu.js
var React13 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenu.styles.js
var GlobalClassNames2 = {
  root: "ms-ContextualMenu",
  container: "ms-ContextualMenu-container",
  list: "ms-ContextualMenu-list",
  header: "ms-ContextualMenu-header",
  title: "ms-ContextualMenu-title",
  isopen: "is-open"
};
var getStyles2 = function(props) {
  var className = props.className, theme = props.theme;
  var classNames = getGlobalClassNames(GlobalClassNames2, theme);
  var fonts = theme.fonts, semanticColors = theme.semanticColors, effects = theme.effects;
  return {
    root: [
      theme.fonts.medium,
      classNames.root,
      classNames.isopen,
      {
        backgroundColor: semanticColors.menuBackground,
        minWidth: "180px"
      },
      className
    ],
    container: [
      classNames.container,
      {
        selectors: {
          ":focus": { outline: 0 }
        }
      }
    ],
    list: [
      classNames.list,
      classNames.isopen,
      {
        listStyleType: "none",
        margin: "0",
        padding: "0"
      }
    ],
    header: [
      classNames.header,
      fonts.small,
      {
        fontWeight: FontWeights.semibold,
        color: semanticColors.menuHeader,
        background: "none",
        backgroundColor: "transparent",
        border: "none",
        height: CONTEXTUAL_MENU_ITEM_HEIGHT,
        lineHeight: CONTEXTUAL_MENU_ITEM_HEIGHT,
        cursor: "default",
        padding: "0px 6px",
        userSelect: "none",
        textAlign: "left"
      }
    ],
    title: [
      classNames.title,
      {
        fontSize: fonts.mediumPlus.fontSize,
        paddingRight: "14px",
        paddingLeft: "14px",
        paddingBottom: "5px",
        paddingTop: "5px",
        backgroundColor: semanticColors.menuItemBackgroundPressed
      }
    ],
    subComponentStyles: {
      callout: {
        root: {
          boxShadow: effects.elevation8
        }
      },
      menuItem: {}
    }
  };
};

// node_modules/@fluentui/react/lib/components/ContextualMenu/ContextualMenu.js
function onRenderSubMenu(subMenuProps) {
  return React13.createElement(LocalContextualMenu, __assign({}, subMenuProps));
}
var LocalContextualMenu = styled(ContextualMenuBase, getStyles2, function(props) {
  return {
    onRenderSubMenu: props.onRenderSubMenu ? composeRenderFunction(props.onRenderSubMenu, onRenderSubMenu) : onRenderSubMenu
  };
}, { scope: "ContextualMenu" });
var ContextualMenu = LocalContextualMenu;
ContextualMenu.displayName = "ContextualMenu";

// node_modules/@fluentui/react/lib/components/Button/SplitButton/SplitButton.classNames.js
var getSplitButtonClassNames = memoizeFunction(function(styles, disabled, expanded, checked, primaryDisabled) {
  return {
    root: mergeStyles(styles.splitButtonMenuButton, expanded && [styles.splitButtonMenuButtonExpanded], disabled && [styles.splitButtonMenuButtonDisabled], checked && !disabled && [styles.splitButtonMenuButtonChecked], primaryDisabled && !disabled && [
      {
        selectors: {
          ":focus": styles.splitButtonMenuFocused
        }
      }
    ]),
    splitButtonContainer: mergeStyles(styles.splitButtonContainer, !disabled && checked && [
      styles.splitButtonContainerChecked,
      {
        selectors: {
          ":hover": styles.splitButtonContainerCheckedHovered
        }
      }
    ], !disabled && !checked && [
      {
        selectors: {
          ":hover": styles.splitButtonContainerHovered,
          ":focus": styles.splitButtonContainerFocused
        }
      }
    ], disabled && styles.splitButtonContainerDisabled),
    icon: mergeStyles(styles.splitButtonMenuIcon, disabled && styles.splitButtonMenuIconDisabled, !disabled && primaryDisabled && styles.splitButtonMenuIcon),
    flexContainer: mergeStyles(styles.splitButtonFlexContainer),
    divider: mergeStyles(styles.splitButtonDivider, (primaryDisabled || disabled) && styles.splitButtonDividerDisabled)
  };
});

// node_modules/@fluentui/react/lib/components/Button/BaseButton.js
var React14 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Button/BaseButton.classNames.js
var ButtonGlobalClassNames = {
  msButton: "ms-Button",
  msButtonHasMenu: "ms-Button--hasMenu",
  msButtonIcon: "ms-Button-icon",
  msButtonMenuIcon: "ms-Button-menuIcon",
  msButtonLabel: "ms-Button-label",
  msButtonDescription: "ms-Button-description",
  msButtonScreenReaderText: "ms-Button-screenReaderText",
  msButtonFlexContainer: "ms-Button-flexContainer",
  msButtonTextContainer: "ms-Button-textContainer"
};
var getBaseButtonClassNames = memoizeFunction(function(theme, styles, className, variantClassName, iconClassName, menuIconClassName, disabled, hasMenu, checked, expanded, isSplit) {
  var _a2, _b2;
  var classNames = getGlobalClassNames(ButtonGlobalClassNames, theme || {});
  var isExpanded = expanded && !isSplit;
  return mergeStyleSets({
    root: [
      classNames.msButton,
      styles.root,
      variantClassName,
      checked && ["is-checked", styles.rootChecked],
      isExpanded && [
        "is-expanded",
        styles.rootExpanded,
        {
          selectors: (_a2 = {}, _a2[":hover ." + classNames.msButtonIcon] = styles.iconExpandedHovered, _a2[":hover ." + classNames.msButtonMenuIcon] = styles.menuIconExpandedHovered || styles.rootExpandedHovered, _a2[":hover"] = styles.rootExpandedHovered, _a2)
        }
      ],
      hasMenu && [ButtonGlobalClassNames.msButtonHasMenu, styles.rootHasMenu],
      disabled && ["is-disabled", styles.rootDisabled],
      !disabled && !isExpanded && !checked && {
        selectors: (_b2 = {
          ":hover": styles.rootHovered
        }, _b2[":hover ." + classNames.msButtonLabel] = styles.labelHovered, _b2[":hover ." + classNames.msButtonIcon] = styles.iconHovered, _b2[":hover ." + classNames.msButtonDescription] = styles.descriptionHovered, _b2[":hover ." + classNames.msButtonMenuIcon] = styles.menuIconHovered, _b2[":focus"] = styles.rootFocused, _b2[":active"] = styles.rootPressed, _b2[":active ." + classNames.msButtonIcon] = styles.iconPressed, _b2[":active ." + classNames.msButtonDescription] = styles.descriptionPressed, _b2[":active ." + classNames.msButtonMenuIcon] = styles.menuIconPressed, _b2)
      },
      disabled && checked && [styles.rootCheckedDisabled],
      !disabled && checked && {
        selectors: {
          ":hover": styles.rootCheckedHovered,
          ":active": styles.rootCheckedPressed
        }
      },
      className
    ],
    flexContainer: [classNames.msButtonFlexContainer, styles.flexContainer],
    textContainer: [classNames.msButtonTextContainer, styles.textContainer],
    icon: [
      classNames.msButtonIcon,
      iconClassName,
      styles.icon,
      isExpanded && styles.iconExpanded,
      checked && styles.iconChecked,
      disabled && styles.iconDisabled
    ],
    label: [classNames.msButtonLabel, styles.label, checked && styles.labelChecked, disabled && styles.labelDisabled],
    menuIcon: [
      classNames.msButtonMenuIcon,
      menuIconClassName,
      styles.menuIcon,
      checked && styles.menuIconChecked,
      disabled && !isSplit && styles.menuIconDisabled,
      !disabled && !isExpanded && !checked && {
        selectors: {
          ":hover": styles.menuIconHovered,
          ":active": styles.menuIconPressed
        }
      },
      isExpanded && ["is-expanded", styles.menuIconExpanded]
    ],
    description: [
      classNames.msButtonDescription,
      styles.description,
      checked && styles.descriptionChecked,
      disabled && styles.descriptionDisabled
    ],
    screenReaderText: [classNames.msButtonScreenReaderText, styles.screenReaderText]
  });
});

// node_modules/@fluentui/react/lib/components/Button/BaseButton.js
var TouchIdleDelay2 = 500;
var COMPONENT_NAME2 = "BaseButton";
var BaseButton = function(_super) {
  __extends(BaseButton2, _super);
  function BaseButton2(props) {
    var _this = _super.call(this, props) || this;
    _this._buttonElement = React14.createRef();
    _this._splitButtonContainer = React14.createRef();
    _this._mergedRef = createMergedRef();
    _this._renderedVisibleMenu = false;
    _this._getMemoizedMenuButtonKeytipProps = memoizeFunction(function(keytipProps) {
      return __assign(__assign({}, keytipProps), { hasMenu: true });
    });
    _this._onRenderIcon = function(buttonProps, defaultRender) {
      var iconProps = _this.props.iconProps;
      if (iconProps && (iconProps.iconName !== void 0 || iconProps.imageProps)) {
        var className = iconProps.className, imageProps = iconProps.imageProps, rest = __rest(iconProps, ["className", "imageProps"]);
        if (iconProps.styles) {
          return React14.createElement(Icon, __assign({ className: css(_this._classNames.icon, className), imageProps }, rest));
        }
        if (iconProps.iconName) {
          return React14.createElement(FontIcon, __assign({ className: css(_this._classNames.icon, className) }, rest));
        }
        if (imageProps) {
          return React14.createElement(ImageIcon, __assign({ className: css(_this._classNames.icon, className), imageProps }, rest));
        }
      }
      return null;
    };
    _this._onRenderTextContents = function() {
      var _a2 = _this.props, text = _a2.text, children = _a2.children, _b2 = _a2.secondaryText, secondaryText = _b2 === void 0 ? _this.props.description : _b2, _c2 = _a2.onRenderText, onRenderText = _c2 === void 0 ? _this._onRenderText : _c2, _d2 = _a2.onRenderDescription, onRenderDescription = _d2 === void 0 ? _this._onRenderDescription : _d2;
      if (text || typeof children === "string" || secondaryText) {
        return React14.createElement(
          "span",
          { className: _this._classNames.textContainer },
          onRenderText(_this.props, _this._onRenderText),
          onRenderDescription(_this.props, _this._onRenderDescription)
        );
      }
      return [onRenderText(_this.props, _this._onRenderText), onRenderDescription(_this.props, _this._onRenderDescription)];
    };
    _this._onRenderText = function() {
      var text = _this.props.text;
      var children = _this.props.children;
      if (text === void 0 && typeof children === "string") {
        text = children;
      }
      if (_this._hasText()) {
        return React14.createElement("span", { key: _this._labelId, className: _this._classNames.label, id: _this._labelId }, text);
      }
      return null;
    };
    _this._onRenderChildren = function() {
      var children = _this.props.children;
      if (typeof children === "string") {
        return null;
      }
      return children;
    };
    _this._onRenderDescription = function(props2) {
      var _a2 = props2.secondaryText, secondaryText = _a2 === void 0 ? _this.props.description : _a2;
      return secondaryText ? React14.createElement("span", { key: _this._descriptionId, className: _this._classNames.description, id: _this._descriptionId }, secondaryText) : null;
    };
    _this._onRenderAriaDescription = function() {
      var ariaDescription = _this.props.ariaDescription;
      return ariaDescription ? React14.createElement("span", { className: _this._classNames.screenReaderText, id: _this._ariaDescriptionId }, ariaDescription) : null;
    };
    _this._onRenderMenuIcon = function(props2) {
      var menuIconProps = _this.props.menuIconProps;
      return React14.createElement(FontIcon, __assign({ iconName: "ChevronDown" }, menuIconProps, { className: _this._classNames.menuIcon }));
    };
    _this._onRenderMenu = function(menuProps) {
      var MenuType = _this.props.menuAs ? composeComponentAs(_this.props.menuAs, ContextualMenu) : ContextualMenu;
      return React14.createElement(MenuType, __assign({}, menuProps));
    };
    _this._onDismissMenu = function(ev) {
      var menuProps = _this.props.menuProps;
      if (menuProps && menuProps.onDismiss) {
        menuProps.onDismiss(ev);
      }
      if (!ev || !ev.defaultPrevented) {
        _this._dismissMenu();
      }
    };
    _this._dismissMenu = function() {
      _this._menuShouldFocusOnMount = void 0;
      _this._menuShouldFocusOnContainer = void 0;
      _this.setState({ menuHidden: true });
    };
    _this._openMenu = function(shouldFocusOnContainer, shouldFocusOnMount) {
      if (shouldFocusOnMount === void 0) {
        shouldFocusOnMount = true;
      }
      if (_this.props.menuProps) {
        _this._menuShouldFocusOnContainer = shouldFocusOnContainer;
        _this._menuShouldFocusOnMount = shouldFocusOnMount;
        _this._renderedVisibleMenu = true;
        _this.setState({ menuHidden: false });
      }
    };
    _this._onToggleMenu = function(shouldFocusOnContainer) {
      var shouldFocusOnMount = true;
      if (_this.props.menuProps && _this.props.menuProps.shouldFocusOnMount === false) {
        shouldFocusOnMount = false;
      }
      _this.state.menuHidden ? _this._openMenu(shouldFocusOnContainer, shouldFocusOnMount) : _this._dismissMenu();
    };
    _this._onSplitContainerFocusCapture = function(ev) {
      var container = _this._splitButtonContainer.current;
      if (!container || ev.target && portalContainsElement(ev.target, container)) {
        return;
      }
      container.focus();
    };
    _this._onSplitButtonPrimaryClick = function(ev) {
      if (!_this.state.menuHidden) {
        _this._dismissMenu();
      }
      if (!_this._processingTouch && _this.props.onClick) {
        _this.props.onClick(ev);
      } else if (_this._processingTouch) {
        _this._onMenuClick(ev);
      }
    };
    _this._onKeyDown = function(ev) {
      if (_this.props.disabled && (ev.which === KeyCodes.enter || ev.which === KeyCodes.space)) {
        ev.preventDefault();
        ev.stopPropagation();
      } else if (!_this.props.disabled) {
        if (_this.props.menuProps) {
          _this._onMenuKeyDown(ev);
        } else if (_this.props.onKeyDown !== void 0) {
          _this.props.onKeyDown(ev);
        }
      }
    };
    _this._onKeyUp = function(ev) {
      if (!_this.props.disabled && _this.props.onKeyUp !== void 0) {
        _this.props.onKeyUp(ev);
      }
    };
    _this._onKeyPress = function(ev) {
      if (!_this.props.disabled && _this.props.onKeyPress !== void 0) {
        _this.props.onKeyPress(ev);
      }
    };
    _this._onMouseUp = function(ev) {
      if (!_this.props.disabled && _this.props.onMouseUp !== void 0) {
        _this.props.onMouseUp(ev);
      }
    };
    _this._onMouseDown = function(ev) {
      if (!_this.props.disabled && _this.props.onMouseDown !== void 0) {
        _this.props.onMouseDown(ev);
      }
    };
    _this._onClick = function(ev) {
      if (!_this.props.disabled) {
        if (_this.props.menuProps) {
          _this._onMenuClick(ev);
        } else if (_this.props.onClick !== void 0) {
          _this.props.onClick(ev);
        }
      }
    };
    _this._onSplitButtonContainerKeyDown = function(ev) {
      if (ev.which === KeyCodes.enter || ev.which === KeyCodes.space) {
        if (_this._buttonElement.current) {
          _this._buttonElement.current.click();
          ev.preventDefault();
          ev.stopPropagation();
        }
      } else {
        _this._onMenuKeyDown(ev);
      }
    };
    _this._onMenuKeyDown = function(ev) {
      if (_this.props.disabled) {
        return;
      }
      if (_this.props.onKeyDown) {
        _this.props.onKeyDown(ev);
      }
      var isUp = ev.which === KeyCodes.up;
      var isDown = ev.which === KeyCodes.down;
      if (!ev.defaultPrevented && _this._isValidMenuOpenKey(ev)) {
        var onMenuClick = _this.props.onMenuClick;
        if (onMenuClick) {
          onMenuClick(ev, _this.props);
        }
        _this._onToggleMenu(false);
        ev.preventDefault();
        ev.stopPropagation();
      }
      if (ev.which === KeyCodes.enter || ev.which === KeyCodes.space) {
        setFocusVisibility(true, ev.target);
      }
      if (!(ev.altKey || ev.metaKey) && (isUp || isDown)) {
        if (!_this.state.menuHidden && _this.props.menuProps) {
          var currentShouldFocusOnMount = _this._menuShouldFocusOnMount !== void 0 ? _this._menuShouldFocusOnMount : _this.props.menuProps.shouldFocusOnMount;
          if (!currentShouldFocusOnMount) {
            ev.preventDefault();
            ev.stopPropagation();
            _this._menuShouldFocusOnMount = true;
            _this.forceUpdate();
          }
        }
      }
    };
    _this._onTouchStart = function() {
      if (_this._isSplitButton && _this._splitButtonContainer.current && !("onpointerdown" in _this._splitButtonContainer.current)) {
        _this._handleTouchAndPointerEvent();
      }
    };
    _this._onMenuClick = function(ev) {
      var _a2 = _this.props, onMenuClick = _a2.onMenuClick, menuProps = _a2.menuProps;
      if (onMenuClick) {
        onMenuClick(ev, _this.props);
      }
      var shouldFocusOnContainer = typeof (menuProps === null || menuProps === void 0 ? void 0 : menuProps.shouldFocusOnContainer) === "boolean" ? menuProps.shouldFocusOnContainer : ev.nativeEvent.pointerType === "mouse";
      if (!ev.defaultPrevented) {
        _this._onToggleMenu(shouldFocusOnContainer);
        ev.preventDefault();
        ev.stopPropagation();
      }
    };
    initializeComponentRef(_this);
    _this._async = new Async(_this);
    _this._events = new EventGroup(_this);
    warnConditionallyRequiredProps(COMPONENT_NAME2, props, ["menuProps", "onClick"], "split", _this.props.split);
    warnDeprecations(COMPONENT_NAME2, props, {
      rootProps: void 0,
      description: "secondaryText",
      toggled: "checked"
    });
    _this._labelId = getId();
    _this._descriptionId = getId();
    _this._ariaDescriptionId = getId();
    _this.state = {
      menuHidden: true
    };
    return _this;
  }
  Object.defineProperty(BaseButton2.prototype, "_isSplitButton", {
    get: function() {
      return !!this.props.menuProps && !!this.props.onClick && this.props.split === true;
    },
    enumerable: false,
    configurable: true
  });
  BaseButton2.prototype.render = function() {
    var _a2;
    var _b2 = this.props, ariaDescription = _b2.ariaDescription, ariaLabel = _b2.ariaLabel, ariaHidden = _b2.ariaHidden, className = _b2.className, disabled = _b2.disabled, allowDisabledFocus = _b2.allowDisabledFocus, primaryDisabled = _b2.primaryDisabled, _c2 = _b2.secondaryText, secondaryText = _c2 === void 0 ? this.props.description : _c2, href = _b2.href, iconProps = _b2.iconProps, menuIconProps = _b2.menuIconProps, styles = _b2.styles, checked = _b2.checked, variantClassName = _b2.variantClassName, theme = _b2.theme, toggle = _b2.toggle, getClassNames5 = _b2.getClassNames, role = _b2.role;
    var menuHidden = this.state.menuHidden;
    var isPrimaryButtonDisabled = disabled || primaryDisabled;
    this._classNames = getClassNames5 ? getClassNames5(theme, className, variantClassName, iconProps && iconProps.className, menuIconProps && menuIconProps.className, isPrimaryButtonDisabled, checked, !menuHidden, !!this.props.menuProps, this.props.split, !!allowDisabledFocus) : getBaseButtonClassNames(theme, styles, className, variantClassName, iconProps && iconProps.className, menuIconProps && menuIconProps.className, isPrimaryButtonDisabled, !!this.props.menuProps, checked, !menuHidden, this.props.split);
    var _d2 = this, _ariaDescriptionId = _d2._ariaDescriptionId, _labelId = _d2._labelId, _descriptionId = _d2._descriptionId;
    var renderAsAnchor = !isPrimaryButtonDisabled && !!href;
    var tag = renderAsAnchor ? "a" : "button";
    var nativeProps = getNativeProps(
      assign(renderAsAnchor ? {} : { type: "button" }, this.props.rootProps, this.props),
      renderAsAnchor ? anchorProperties : buttonProperties,
      [
        "disabled"
      ]
    );
    var resolvedAriaLabel = ariaLabel || nativeProps["aria-label"];
    var ariaDescribedBy = void 0;
    if (ariaDescription) {
      ariaDescribedBy = _ariaDescriptionId;
    } else if (secondaryText && this.props.onRenderDescription !== nullRender) {
      ariaDescribedBy = _descriptionId;
    } else if (nativeProps["aria-describedby"]) {
      ariaDescribedBy = nativeProps["aria-describedby"];
    }
    var ariaLabelledBy = void 0;
    if (nativeProps["aria-labelledby"]) {
      ariaLabelledBy = nativeProps["aria-labelledby"];
    } else if (ariaDescribedBy && !resolvedAriaLabel) {
      ariaLabelledBy = this._hasText() ? _labelId : void 0;
    }
    var dataIsFocusable = this.props["data-is-focusable"] === false || disabled && !allowDisabledFocus || this._isSplitButton ? false : true;
    var isCheckboxTypeRole = role === "menuitemcheckbox" || role === "checkbox";
    var checkedOrPressedValue = isCheckboxTypeRole ? !!checked : toggle === true ? !!checked : void 0;
    var buttonProps = assign(nativeProps, (_a2 = {
      className: this._classNames.root,
      ref: this._mergedRef(this.props.elementRef, this._buttonElement),
      disabled: isPrimaryButtonDisabled && !allowDisabledFocus,
      onKeyDown: this._onKeyDown,
      onKeyPress: this._onKeyPress,
      onKeyUp: this._onKeyUp,
      onMouseDown: this._onMouseDown,
      onMouseUp: this._onMouseUp,
      onClick: this._onClick,
      "aria-label": resolvedAriaLabel,
      "aria-labelledby": ariaLabelledBy,
      "aria-describedby": ariaDescribedBy,
      "aria-disabled": isPrimaryButtonDisabled,
      "data-is-focusable": dataIsFocusable
    }, _a2[isCheckboxTypeRole ? "aria-checked" : "aria-pressed"] = checkedOrPressedValue, _a2));
    if (ariaHidden) {
      buttonProps["aria-hidden"] = true;
    }
    if (this._isSplitButton) {
      return this._onRenderSplitButtonContent(tag, buttonProps);
    } else if (this.props.menuProps) {
      var _e2 = this.props.menuProps.id, id = _e2 === void 0 ? this._labelId + "-menu" : _e2;
      assign(buttonProps, {
        "aria-expanded": !menuHidden,
        "aria-controls": !menuHidden ? id : null,
        "aria-haspopup": true
      });
    }
    return this._onRenderContent(tag, buttonProps);
  };
  BaseButton2.prototype.componentDidMount = function() {
    if (this._isSplitButton && this._splitButtonContainer.current) {
      if ("onpointerdown" in this._splitButtonContainer.current) {
        this._events.on(this._splitButtonContainer.current, "pointerdown", this._onPointerDown, true);
      }
      if ("onpointerup" in this._splitButtonContainer.current && this.props.onPointerUp) {
        this._events.on(this._splitButtonContainer.current, "pointerup", this.props.onPointerUp, true);
      }
    }
  };
  BaseButton2.prototype.componentDidUpdate = function(prevProps, prevState) {
    if (this.props.onAfterMenuDismiss && !prevState.menuHidden && this.state.menuHidden) {
      this.props.onAfterMenuDismiss();
    }
  };
  BaseButton2.prototype.componentWillUnmount = function() {
    this._async.dispose();
    this._events.dispose();
  };
  BaseButton2.prototype.focus = function() {
    if (this._isSplitButton && this._splitButtonContainer.current) {
      setFocusVisibility(true);
      this._splitButtonContainer.current.focus();
    } else if (this._buttonElement.current) {
      setFocusVisibility(true);
      this._buttonElement.current.focus();
    }
  };
  BaseButton2.prototype.dismissMenu = function() {
    this._dismissMenu();
  };
  BaseButton2.prototype.openMenu = function(shouldFocusOnContainer, shouldFocusOnMount) {
    this._openMenu(shouldFocusOnContainer, shouldFocusOnMount);
  };
  BaseButton2.prototype._onRenderContent = function(tag, buttonProps) {
    var _this = this;
    var props = this.props;
    var Tag = tag;
    var menuIconProps = props.menuIconProps, menuProps = props.menuProps, _a2 = props.onRenderIcon, onRenderIcon = _a2 === void 0 ? this._onRenderIcon : _a2, _b2 = props.onRenderAriaDescription, onRenderAriaDescription = _b2 === void 0 ? this._onRenderAriaDescription : _b2, _c2 = props.onRenderChildren, onRenderChildren = _c2 === void 0 ? this._onRenderChildren : _c2, _d2 = props.onRenderMenu, onRenderMenu = _d2 === void 0 ? this._onRenderMenu : _d2, _e2 = props.onRenderMenuIcon, onRenderMenuIcon = _e2 === void 0 ? this._onRenderMenuIcon : _e2, disabled = props.disabled;
    var keytipProps = props.keytipProps;
    if (keytipProps && menuProps) {
      keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);
    }
    var Button2 = function(keytipAttributes) {
      return React14.createElement(
        Tag,
        __assign({}, buttonProps, keytipAttributes),
        React14.createElement(
          "span",
          { className: _this._classNames.flexContainer, "data-automationid": "splitbuttonprimary" },
          onRenderIcon(props, _this._onRenderIcon),
          _this._onRenderTextContents(),
          onRenderAriaDescription(props, _this._onRenderAriaDescription),
          onRenderChildren(props, _this._onRenderChildren),
          !_this._isSplitButton && (menuProps || menuIconProps || _this.props.onRenderMenuIcon) && onRenderMenuIcon(_this.props, _this._onRenderMenuIcon),
          menuProps && !menuProps.doNotLayer && _this._shouldRenderMenu() && onRenderMenu(_this._getMenuProps(menuProps), _this._onRenderMenu)
        )
      );
    };
    var Content = keytipProps ? React14.createElement(KeytipData, { keytipProps: !this._isSplitButton ? keytipProps : void 0, ariaDescribedBy: buttonProps["aria-describedby"], disabled }, function(keytipAttributes) {
      return Button2(keytipAttributes);
    }) : Button2();
    if (menuProps && menuProps.doNotLayer) {
      return React14.createElement(
        React14.Fragment,
        null,
        Content,
        this._shouldRenderMenu() && onRenderMenu(this._getMenuProps(menuProps), this._onRenderMenu)
      );
    }
    return React14.createElement(
      React14.Fragment,
      null,
      Content,
      React14.createElement(FocusRects, null)
    );
  };
  BaseButton2.prototype._shouldRenderMenu = function() {
    var menuHidden = this.state.menuHidden;
    var _a2 = this.props, persistMenu = _a2.persistMenu, renderPersistedMenuHiddenOnMount = _a2.renderPersistedMenuHiddenOnMount;
    if (!menuHidden) {
      return true;
    } else if (persistMenu && (this._renderedVisibleMenu || renderPersistedMenuHiddenOnMount)) {
      return true;
    }
    return false;
  };
  BaseButton2.prototype._hasText = function() {
    return this.props.text !== null && (this.props.text !== void 0 || typeof this.props.children === "string");
  };
  BaseButton2.prototype._getMenuProps = function(menuProps) {
    var persistMenu = this.props.persistMenu;
    var menuHidden = this.state.menuHidden;
    if (!menuProps.ariaLabel && !menuProps.labelElementId && this._hasText()) {
      menuProps = __assign(__assign({}, menuProps), { labelElementId: this._labelId });
    }
    return __assign(__assign({ id: this._labelId + "-menu", directionalHint: DirectionalHint.bottomLeftEdge }, menuProps), { shouldFocusOnContainer: this._menuShouldFocusOnContainer, shouldFocusOnMount: this._menuShouldFocusOnMount, hidden: persistMenu ? menuHidden : void 0, className: css("ms-BaseButton-menuhost", menuProps.className), target: this._isSplitButton ? this._splitButtonContainer.current : this._buttonElement.current, onDismiss: this._onDismissMenu });
  };
  BaseButton2.prototype._onRenderSplitButtonContent = function(tag, buttonProps) {
    var _this = this;
    var _a2 = this.props, _b2 = _a2.styles, styles = _b2 === void 0 ? {} : _b2, disabled = _a2.disabled, allowDisabledFocus = _a2.allowDisabledFocus, checked = _a2.checked, getSplitButtonClassNames2 = _a2.getSplitButtonClassNames, primaryDisabled = _a2.primaryDisabled, menuProps = _a2.menuProps, toggle = _a2.toggle, role = _a2.role, primaryActionButtonProps = _a2.primaryActionButtonProps;
    var keytipProps = this.props.keytipProps;
    var menuHidden = this.state.menuHidden;
    var classNames = getSplitButtonClassNames2 ? getSplitButtonClassNames2(!!disabled, !menuHidden, !!checked, !!allowDisabledFocus) : styles && getSplitButtonClassNames(styles, !!disabled, !menuHidden, !!checked, !!primaryDisabled);
    assign(buttonProps, {
      onClick: void 0,
      onPointerDown: void 0,
      onPointerUp: void 0,
      tabIndex: -1,
      "data-is-focusable": false
    });
    if (keytipProps && menuProps) {
      keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);
    }
    var containerProps = getNativeProps(buttonProps, [], ["disabled"]);
    if (primaryActionButtonProps) {
      assign(buttonProps, primaryActionButtonProps);
    }
    var SplitButton = function(keytipAttributes) {
      return React14.createElement(
        "div",
        __assign({}, containerProps, { "data-ktp-target": keytipAttributes ? keytipAttributes["data-ktp-target"] : void 0, role: role ? role : "button", "aria-disabled": disabled, "aria-haspopup": true, "aria-expanded": !menuHidden, "aria-pressed": toggle ? !!checked : void 0, "aria-describedby": mergeAriaAttributeValues(buttonProps["aria-describedby"], keytipAttributes ? keytipAttributes["aria-describedby"] : void 0), className: classNames && classNames.splitButtonContainer, onKeyDown: _this._onSplitButtonContainerKeyDown, onTouchStart: _this._onTouchStart, ref: _this._splitButtonContainer, "data-is-focusable": true, onClick: !disabled && !primaryDisabled ? _this._onSplitButtonPrimaryClick : void 0, tabIndex: !disabled && !primaryDisabled || allowDisabledFocus ? 0 : void 0, "aria-roledescription": buttonProps["aria-roledescription"], onFocusCapture: _this._onSplitContainerFocusCapture }),
        React14.createElement(
          "span",
          { style: { display: "flex", width: "100%" } },
          _this._onRenderContent(tag, buttonProps),
          _this._onRenderSplitButtonMenuButton(classNames, keytipAttributes),
          _this._onRenderSplitButtonDivider(classNames)
        )
      );
    };
    return keytipProps ? React14.createElement(KeytipData, { keytipProps, disabled }, function(keytipAttributes) {
      return SplitButton(keytipAttributes);
    }) : SplitButton();
  };
  BaseButton2.prototype._onRenderSplitButtonDivider = function(classNames) {
    if (classNames && classNames.divider) {
      var onClick = function(ev) {
        ev.stopPropagation();
      };
      return React14.createElement("span", { className: classNames.divider, "aria-hidden": true, onClick });
    }
    return null;
  };
  BaseButton2.prototype._onRenderSplitButtonMenuButton = function(classNames, keytipAttributes) {
    var _a2 = this.props, allowDisabledFocus = _a2.allowDisabledFocus, checked = _a2.checked, disabled = _a2.disabled, splitButtonMenuProps = _a2.splitButtonMenuProps, splitButtonAriaLabel = _a2.splitButtonAriaLabel, primaryDisabled = _a2.primaryDisabled;
    var menuHidden = this.state.menuHidden;
    var menuIconProps = this.props.menuIconProps;
    if (menuIconProps === void 0) {
      menuIconProps = {
        iconName: "ChevronDown"
      };
    }
    var splitButtonProps = __assign(__assign({}, splitButtonMenuProps), { styles: classNames, checked, disabled, allowDisabledFocus, onClick: this._onMenuClick, menuProps: void 0, iconProps: __assign(__assign({}, menuIconProps), { className: this._classNames.menuIcon }), ariaLabel: splitButtonAriaLabel, "aria-haspopup": true, "aria-expanded": !menuHidden, "data-is-focusable": false });
    return React14.createElement(BaseButton2, __assign({}, splitButtonProps, { "data-ktp-execute-target": keytipAttributes ? keytipAttributes["data-ktp-execute-target"] : keytipAttributes, onMouseDown: this._onMouseDown, tabIndex: primaryDisabled && !allowDisabledFocus ? 0 : -1 }));
  };
  BaseButton2.prototype._onPointerDown = function(ev) {
    var onPointerDown = this.props.onPointerDown;
    if (onPointerDown) {
      onPointerDown(ev);
    }
    if (ev.pointerType === "touch") {
      this._handleTouchAndPointerEvent();
      ev.preventDefault();
      ev.stopImmediatePropagation();
    }
  };
  BaseButton2.prototype._handleTouchAndPointerEvent = function() {
    var _this = this;
    if (this._lastTouchTimeoutId !== void 0) {
      this._async.clearTimeout(this._lastTouchTimeoutId);
      this._lastTouchTimeoutId = void 0;
    }
    this._processingTouch = true;
    this._lastTouchTimeoutId = this._async.setTimeout(function() {
      _this._processingTouch = false;
      _this._lastTouchTimeoutId = void 0;
      _this.focus();
    }, TouchIdleDelay2);
  };
  BaseButton2.prototype._isValidMenuOpenKey = function(ev) {
    if (this.props.menuTriggerKeyCode) {
      return ev.which === this.props.menuTriggerKeyCode;
    } else if (this.props.menuProps) {
      return ev.which === KeyCodes.down && (ev.altKey || ev.metaKey);
    }
    return false;
  };
  BaseButton2.defaultProps = {
    baseClassName: "ms-Button",
    styles: {},
    split: false
  };
  return BaseButton2;
}(React14.Component);

// node_modules/@fluentui/react/lib/components/Button/Button.types.js
var ElementType;
(function(ElementType2) {
  ElementType2[ElementType2["button"] = 0] = "button";
  ElementType2[ElementType2["anchor"] = 1] = "anchor";
})(ElementType || (ElementType = {}));
var ButtonType;
(function(ButtonType2) {
  ButtonType2[ButtonType2["normal"] = 0] = "normal";
  ButtonType2[ButtonType2["primary"] = 1] = "primary";
  ButtonType2[ButtonType2["hero"] = 2] = "hero";
  ButtonType2[ButtonType2["compound"] = 3] = "compound";
  ButtonType2[ButtonType2["command"] = 4] = "command";
  ButtonType2[ButtonType2["icon"] = 5] = "icon";
  ButtonType2[ButtonType2["default"] = 6] = "default";
})(ButtonType || (ButtonType = {}));

// node_modules/@fluentui/react/lib/components/Button/DefaultButton/DefaultButton.js
var React15 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Button/BaseButton.styles.js
var noOutline = {
  outline: 0
};
var iconStyle = function(fontSize) {
  return {
    fontSize,
    margin: "0 4px",
    height: "16px",
    lineHeight: "16px",
    textAlign: "center",
    flexShrink: 0
  };
};
var getStyles3 = memoizeFunction(function(theme) {
  var _a2, _b2;
  var semanticColors = theme.semanticColors, effects = theme.effects, fonts = theme.fonts;
  var border = semanticColors.buttonBorder;
  var disabledBackground = semanticColors.disabledBackground;
  var disabledText = semanticColors.disabledText;
  var buttonHighContrastFocus = {
    left: -2,
    top: -2,
    bottom: -2,
    right: -2,
    outlineColor: "ButtonText"
  };
  return {
    root: [
      getFocusStyle(theme, { inset: 1, highContrastStyle: buttonHighContrastFocus, borderColor: "transparent" }),
      theme.fonts.medium,
      {
        boxSizing: "border-box",
        border: "1px solid " + border,
        userSelect: "none",
        display: "inline-block",
        textDecoration: "none",
        textAlign: "center",
        cursor: "pointer",
        padding: "0 16px",
        borderRadius: effects.roundedCorner2,
        selectors: {
          ":active > span": {
            position: "relative",
            left: 0,
            top: 0
          }
        }
      }
    ],
    rootDisabled: [
      getFocusStyle(theme, { inset: 1, highContrastStyle: buttonHighContrastFocus, borderColor: "transparent" }),
      {
        backgroundColor: disabledBackground,
        borderColor: disabledBackground,
        color: disabledText,
        cursor: "default",
        selectors: {
          ":hover": noOutline,
          ":focus": noOutline
        }
      }
    ],
    iconDisabled: {
      color: disabledText,
      selectors: (_a2 = {}, _a2[HighContrastSelector] = {
        color: "GrayText"
      }, _a2)
    },
    menuIconDisabled: {
      color: disabledText,
      selectors: (_b2 = {}, _b2[HighContrastSelector] = {
        color: "GrayText"
      }, _b2)
    },
    flexContainer: {
      display: "flex",
      height: "100%",
      flexWrap: "nowrap",
      justifyContent: "center",
      alignItems: "center"
    },
    description: {
      display: "block"
    },
    textContainer: {
      flexGrow: 1,
      display: "block"
    },
    icon: iconStyle(fonts.mediumPlus.fontSize),
    menuIcon: iconStyle(fonts.small.fontSize),
    label: {
      margin: "0 4px",
      lineHeight: "100%",
      display: "block"
    },
    screenReaderText: hiddenContentStyle
  };
});

// node_modules/@fluentui/react/lib/components/Button/SplitButton/SplitButton.styles.js
var getStyles4 = memoizeFunction(function(theme, customStyles) {
  var _a2, _b2, _c2, _d2, _e2, _f, _g, _h, _j, _k, _l, _m, _o;
  var effects = theme.effects, palette = theme.palette, semanticColors = theme.semanticColors;
  var buttonHighContrastFocus = {
    left: -2,
    top: -2,
    bottom: -2,
    right: -2,
    border: "none"
  };
  var splitButtonDividerBaseStyles2 = {
    position: "absolute",
    width: 1,
    right: 31,
    top: 8,
    bottom: 8
  };
  var splitButtonStyles = {
    splitButtonContainer: [
      getFocusStyle(theme, { highContrastStyle: buttonHighContrastFocus, inset: 2 }),
      {
        display: "inline-flex",
        selectors: {
          ".ms-Button--default": {
            borderTopRightRadius: "0",
            borderBottomRightRadius: "0",
            borderRight: "none",
            flexGrow: "1"
          },
          ".ms-Button--primary": {
            borderTopRightRadius: "0",
            borderBottomRightRadius: "0",
            border: "none",
            flexGrow: "1",
            selectors: (_a2 = {}, _a2[HighContrastSelector] = __assign({ color: "WindowText", backgroundColor: "Window", border: "1px solid WindowText", borderRightWidth: "0" }, getHighContrastNoAdjustStyle()), _a2)
          },
          ".ms-Button--primary + .ms-Button": {
            border: "none",
            selectors: (_b2 = {}, _b2[HighContrastSelector] = {
              border: "1px solid WindowText",
              borderLeftWidth: "0"
            }, _b2)
          }
        }
      }
    ],
    splitButtonContainerHovered: {
      selectors: {
        ".ms-Button--primary": {
          selectors: (_c2 = {}, _c2[HighContrastSelector] = {
            color: "Window",
            backgroundColor: "Highlight"
          }, _c2)
        },
        ".ms-Button.is-disabled": {
          color: semanticColors.buttonTextDisabled,
          selectors: (_d2 = {}, _d2[HighContrastSelector] = {
            color: "GrayText",
            borderColor: "GrayText",
            backgroundColor: "Window"
          }, _d2)
        }
      }
    },
    splitButtonContainerChecked: {
      selectors: {
        ".ms-Button--primary": {
          selectors: (_e2 = {}, _e2[HighContrastSelector] = __assign({ color: "Window", backgroundColor: "WindowText" }, getHighContrastNoAdjustStyle()), _e2)
        }
      }
    },
    splitButtonContainerCheckedHovered: {
      selectors: {
        ".ms-Button--primary": {
          selectors: (_f = {}, _f[HighContrastSelector] = __assign({ color: "Window", backgroundColor: "WindowText" }, getHighContrastNoAdjustStyle()), _f)
        }
      }
    },
    splitButtonContainerFocused: {
      outline: "none!important"
    },
    splitButtonMenuButton: (_g = {
      padding: 6,
      height: "auto",
      boxSizing: "border-box",
      borderRadius: 0,
      borderTopRightRadius: effects.roundedCorner2,
      borderBottomRightRadius: effects.roundedCorner2,
      border: "1px solid " + palette.neutralSecondaryAlt,
      borderLeft: "none",
      outline: "transparent",
      userSelect: "none",
      display: "inline-block",
      textDecoration: "none",
      textAlign: "center",
      cursor: "pointer",
      verticalAlign: "top",
      width: 32,
      marginLeft: -1,
      marginTop: 0,
      marginRight: 0,
      marginBottom: 0
    }, _g[HighContrastSelector] = {
      ".ms-Button-menuIcon": {
        color: "WindowText"
      }
    }, _g),
    splitButtonDivider: __assign(__assign({}, splitButtonDividerBaseStyles2), { selectors: (_h = {}, _h[HighContrastSelector] = {
      backgroundColor: "WindowText"
    }, _h) }),
    splitButtonDividerDisabled: __assign(__assign({}, splitButtonDividerBaseStyles2), { selectors: (_j = {}, _j[HighContrastSelector] = {
      backgroundColor: "GrayText"
    }, _j) }),
    splitButtonMenuButtonDisabled: {
      pointerEvents: "none",
      border: "none",
      selectors: (_k = {
        ":hover": {
          cursor: "default"
        },
        ".ms-Button--primary": {
          selectors: (_l = {}, _l[HighContrastSelector] = {
            color: "GrayText",
            borderColor: "GrayText",
            backgroundColor: "Window"
          }, _l)
        },
        ".ms-Button-menuIcon": {
          selectors: (_m = {}, _m[HighContrastSelector] = {
            color: "GrayText"
          }, _m)
        }
      }, _k[HighContrastSelector] = {
        color: "GrayText",
        border: "1px solid GrayText",
        backgroundColor: "Window"
      }, _k)
    },
    splitButtonFlexContainer: {
      display: "flex",
      height: "100%",
      flexWrap: "nowrap",
      justifyContent: "center",
      alignItems: "center"
    },
    splitButtonContainerDisabled: {
      outline: "none",
      border: "none",
      selectors: (_o = {}, _o[HighContrastSelector] = __assign({ color: "GrayText", borderColor: "GrayText", backgroundColor: "Window" }, getHighContrastNoAdjustStyle()), _o)
    },
    splitButtonMenuFocused: __assign({}, getFocusStyle(theme, { highContrastStyle: buttonHighContrastFocus, inset: 2 }))
  };
  return concatStyleSets(splitButtonStyles, customStyles);
});

// node_modules/@fluentui/react/lib/components/Button/ButtonThemes.js
var splitButtonDividerBaseStyles = function() {
  return {
    position: "absolute",
    width: 1,
    right: 31,
    top: 8,
    bottom: 8
  };
};
function standardStyles(theme) {
  var _a2, _b2, _c2, _d2, _e2;
  var s = theme.semanticColors, p = theme.palette;
  var buttonBackground = s.buttonBackground;
  var buttonBackgroundPressed = s.buttonBackgroundPressed;
  var buttonBackgroundHovered = s.buttonBackgroundHovered;
  var buttonBackgroundDisabled = s.buttonBackgroundDisabled;
  var buttonText = s.buttonText;
  var buttonTextHovered = s.buttonTextHovered;
  var buttonTextDisabled = s.buttonTextDisabled;
  var buttonTextChecked = s.buttonTextChecked;
  var buttonTextCheckedHovered = s.buttonTextCheckedHovered;
  return {
    root: {
      backgroundColor: buttonBackground,
      color: buttonText
    },
    rootHovered: {
      backgroundColor: buttonBackgroundHovered,
      color: buttonTextHovered,
      selectors: (_a2 = {}, _a2[HighContrastSelector] = {
        borderColor: "Highlight",
        color: "Highlight"
      }, _a2)
    },
    rootPressed: {
      backgroundColor: buttonBackgroundPressed,
      color: buttonTextChecked
    },
    rootExpanded: {
      backgroundColor: buttonBackgroundPressed,
      color: buttonTextChecked
    },
    rootChecked: {
      backgroundColor: buttonBackgroundPressed,
      color: buttonTextChecked
    },
    rootCheckedHovered: {
      backgroundColor: buttonBackgroundPressed,
      color: buttonTextCheckedHovered
    },
    rootDisabled: {
      color: buttonTextDisabled,
      backgroundColor: buttonBackgroundDisabled,
      selectors: (_b2 = {}, _b2[HighContrastSelector] = {
        color: "GrayText",
        borderColor: "GrayText",
        backgroundColor: "Window"
      }, _b2)
    },
    splitButtonContainer: {
      selectors: (_c2 = {}, _c2[HighContrastSelector] = {
        border: "none"
      }, _c2)
    },
    splitButtonMenuButton: {
      color: p.white,
      backgroundColor: "transparent",
      selectors: {
        ":hover": {
          backgroundColor: p.neutralLight,
          selectors: (_d2 = {}, _d2[HighContrastSelector] = {
            color: "Highlight"
          }, _d2)
        }
      }
    },
    splitButtonMenuButtonDisabled: {
      backgroundColor: s.buttonBackgroundDisabled,
      selectors: {
        ":hover": {
          backgroundColor: s.buttonBackgroundDisabled
        }
      }
    },
    splitButtonDivider: __assign(__assign({}, splitButtonDividerBaseStyles()), { backgroundColor: p.neutralTertiaryAlt, selectors: (_e2 = {}, _e2[HighContrastSelector] = {
      backgroundColor: "WindowText"
    }, _e2) }),
    splitButtonDividerDisabled: {
      backgroundColor: theme.palette.neutralTertiaryAlt
    },
    splitButtonMenuButtonChecked: {
      backgroundColor: p.neutralQuaternaryAlt,
      selectors: {
        ":hover": {
          backgroundColor: p.neutralQuaternaryAlt
        }
      }
    },
    splitButtonMenuButtonExpanded: {
      backgroundColor: p.neutralQuaternaryAlt,
      selectors: {
        ":hover": {
          backgroundColor: p.neutralQuaternaryAlt
        }
      }
    },
    splitButtonMenuIcon: {
      color: s.buttonText
    },
    splitButtonMenuIconDisabled: {
      color: s.buttonTextDisabled
    }
  };
}
function primaryStyles(theme) {
  var _a2, _b2, _c2, _d2, _e2, _f, _g, _h, _j;
  var p = theme.palette, s = theme.semanticColors;
  return {
    root: {
      backgroundColor: s.primaryButtonBackground,
      border: "1px solid " + s.primaryButtonBackground,
      color: s.primaryButtonText,
      selectors: (_a2 = {}, _a2[HighContrastSelector] = __assign({ color: "Window", backgroundColor: "WindowText", borderColor: "WindowText" }, getHighContrastNoAdjustStyle()), _a2["." + IsFocusVisibleClassName + " &:focus"] = {
        selectors: {
          ":after": {
            border: "none",
            outlineColor: p.white
          }
        }
      }, _a2)
    },
    rootHovered: {
      backgroundColor: s.primaryButtonBackgroundHovered,
      border: "1px solid " + s.primaryButtonBackgroundHovered,
      color: s.primaryButtonTextHovered,
      selectors: (_b2 = {}, _b2[HighContrastSelector] = {
        color: "Window",
        backgroundColor: "Highlight",
        borderColor: "Highlight"
      }, _b2)
    },
    rootPressed: {
      backgroundColor: s.primaryButtonBackgroundPressed,
      border: "1px solid " + s.primaryButtonBackgroundPressed,
      color: s.primaryButtonTextPressed,
      selectors: (_c2 = {}, _c2[HighContrastSelector] = __assign({ color: "Window", backgroundColor: "WindowText", borderColor: "WindowText" }, getHighContrastNoAdjustStyle()), _c2)
    },
    rootExpanded: {
      backgroundColor: s.primaryButtonBackgroundPressed,
      color: s.primaryButtonTextPressed
    },
    rootChecked: {
      backgroundColor: s.primaryButtonBackgroundPressed,
      color: s.primaryButtonTextPressed
    },
    rootCheckedHovered: {
      backgroundColor: s.primaryButtonBackgroundPressed,
      color: s.primaryButtonTextPressed
    },
    rootDisabled: {
      color: s.primaryButtonTextDisabled,
      backgroundColor: s.primaryButtonBackgroundDisabled,
      selectors: (_d2 = {}, _d2[HighContrastSelector] = {
        color: "GrayText",
        borderColor: "GrayText",
        backgroundColor: "Window"
      }, _d2)
    },
    splitButtonContainer: {
      selectors: (_e2 = {}, _e2[HighContrastSelector] = {
        border: "none"
      }, _e2)
    },
    splitButtonDivider: __assign(__assign({}, splitButtonDividerBaseStyles()), { backgroundColor: p.white, selectors: (_f = {}, _f[HighContrastSelector] = {
      backgroundColor: "Window"
    }, _f) }),
    splitButtonMenuButton: {
      backgroundColor: s.primaryButtonBackground,
      color: s.primaryButtonText,
      selectors: (_g = {}, _g[HighContrastSelector] = {
        backgroundColor: "WindowText"
      }, _g[":hover"] = {
        backgroundColor: s.primaryButtonBackgroundHovered,
        selectors: (_h = {}, _h[HighContrastSelector] = {
          color: "Highlight"
        }, _h)
      }, _g)
    },
    splitButtonMenuButtonDisabled: {
      backgroundColor: s.primaryButtonBackgroundDisabled,
      selectors: {
        ":hover": {
          backgroundColor: s.primaryButtonBackgroundDisabled
        }
      }
    },
    splitButtonMenuButtonChecked: {
      backgroundColor: s.primaryButtonBackgroundPressed,
      selectors: {
        ":hover": {
          backgroundColor: s.primaryButtonBackgroundPressed
        }
      }
    },
    splitButtonMenuButtonExpanded: {
      backgroundColor: s.primaryButtonBackgroundPressed,
      selectors: {
        ":hover": {
          backgroundColor: s.primaryButtonBackgroundPressed
        }
      }
    },
    splitButtonMenuIcon: {
      color: s.primaryButtonText
    },
    splitButtonMenuIconDisabled: {
      color: p.neutralTertiary,
      selectors: (_j = {}, _j[HighContrastSelector] = {
        color: "GrayText"
      }, _j)
    }
  };
}

// node_modules/@fluentui/react/lib/components/Button/DefaultButton/DefaultButton.styles.js
var DEFAULT_BUTTON_HEIGHT = "32px";
var DEFAULT_BUTTON_MIN_WIDTH = "80px";
var getStyles5 = memoizeFunction(function(theme, customStyles, primary) {
  var baseButtonStyles = getStyles3(theme);
  var splitButtonStyles = getStyles4(theme);
  var defaultButtonStyles = {
    root: {
      minWidth: DEFAULT_BUTTON_MIN_WIDTH,
      height: DEFAULT_BUTTON_HEIGHT
    },
    label: {
      fontWeight: FontWeights.semibold
    }
  };
  return concatStyleSets(baseButtonStyles, defaultButtonStyles, primary ? primaryStyles(theme) : standardStyles(theme), splitButtonStyles, customStyles);
});

// node_modules/@fluentui/react/lib/components/Button/DefaultButton/DefaultButton.js
var DefaultButton = function(_super) {
  __extends(DefaultButton2, _super);
  function DefaultButton2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  DefaultButton2.prototype.render = function() {
    var _a2 = this.props, _b2 = _a2.primary, primary = _b2 === void 0 ? false : _b2, styles = _a2.styles, theme = _a2.theme;
    return React15.createElement(BaseButton, __assign({}, this.props, { variantClassName: primary ? "ms-Button--primary" : "ms-Button--default", styles: getStyles5(theme, styles, primary), onRenderDescription: nullRender }));
  };
  DefaultButton2 = __decorate([
    customizable("DefaultButton", ["theme", "styles"], true)
  ], DefaultButton2);
  return DefaultButton2;
}(React15.Component);

// node_modules/@fluentui/react/lib/components/Button/ActionButton/ActionButton.js
var React16 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Button/ActionButton/ActionButton.styles.js
var DEFAULT_BUTTON_HEIGHT2 = "40px";
var DEFAULT_PADDING = "0 4px";
var getStyles6 = memoizeFunction(function(theme, customStyles) {
  var _a2, _b2, _c2;
  var baseButtonStyles = getStyles3(theme);
  var actionButtonStyles = {
    root: {
      padding: DEFAULT_PADDING,
      height: DEFAULT_BUTTON_HEIGHT2,
      color: theme.palette.neutralPrimary,
      backgroundColor: "transparent",
      border: "1px solid transparent",
      selectors: (_a2 = {}, _a2[HighContrastSelector] = {
        borderColor: "Window"
      }, _a2)
    },
    rootHovered: {
      color: theme.palette.themePrimary,
      selectors: (_b2 = {}, _b2[HighContrastSelector] = {
        color: "Highlight"
      }, _b2)
    },
    iconHovered: {
      color: theme.palette.themePrimary
    },
    rootPressed: {
      color: theme.palette.black
    },
    rootExpanded: {
      color: theme.palette.themePrimary
    },
    iconPressed: {
      color: theme.palette.themeDarker
    },
    rootDisabled: {
      color: theme.palette.neutralTertiary,
      backgroundColor: "transparent",
      borderColor: "transparent",
      selectors: (_c2 = {}, _c2[HighContrastSelector] = {
        color: "GrayText"
      }, _c2)
    },
    rootChecked: {
      color: theme.palette.black
    },
    iconChecked: {
      color: theme.palette.themeDarker
    },
    flexContainer: {
      justifyContent: "flex-start"
    },
    icon: {
      color: theme.palette.themeDarkAlt
    },
    iconDisabled: {
      color: "inherit"
    },
    menuIcon: {
      color: theme.palette.neutralSecondary
    },
    textContainer: {
      flexGrow: 0
    }
  };
  return concatStyleSets(baseButtonStyles, actionButtonStyles, customStyles);
});

// node_modules/@fluentui/react/lib/components/Button/ActionButton/ActionButton.js
var ActionButton = function(_super) {
  __extends(ActionButton2, _super);
  function ActionButton2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ActionButton2.prototype.render = function() {
    var _a2 = this.props, styles = _a2.styles, theme = _a2.theme;
    return React16.createElement(BaseButton, __assign({}, this.props, { variantClassName: "ms-Button--action ms-Button--command", styles: getStyles6(theme, styles), onRenderDescription: nullRender }));
  };
  ActionButton2 = __decorate([
    customizable("ActionButton", ["theme", "styles"], true)
  ], ActionButton2);
  return ActionButton2;
}(React16.Component);

// node_modules/@fluentui/react/lib/components/Button/CompoundButton/CompoundButton.js
var React17 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Button/CompoundButton/CompoundButton.styles.js
var getStyles7 = memoizeFunction(function(theme, customStyles, primary) {
  var _a2, _b2, _c2, _d2, _e2;
  var fonts = theme.fonts, palette = theme.palette;
  var baseButtonStyles = getStyles3(theme);
  var splitButtonStyles = getStyles4(theme);
  var compoundButtonStyles = {
    root: {
      maxWidth: "280px",
      minHeight: "72px",
      height: "auto",
      padding: "16px 12px"
    },
    flexContainer: {
      flexDirection: "row",
      alignItems: "flex-start",
      minWidth: "100%",
      margin: ""
    },
    textContainer: {
      textAlign: "left"
    },
    icon: {
      fontSize: "2em",
      lineHeight: "1em",
      height: "1em",
      margin: "0px 8px 0px 0px",
      flexBasis: "1em",
      flexShrink: "0"
    },
    label: {
      margin: "0 0 5px",
      lineHeight: "100%",
      fontWeight: FontWeights.semibold
    },
    description: [
      fonts.small,
      {
        lineHeight: "100%"
      }
    ]
  };
  var standardCompoundTheme = {
    description: {
      color: palette.neutralSecondary
    },
    descriptionHovered: {
      color: palette.neutralDark
    },
    descriptionPressed: {
      color: "inherit"
    },
    descriptionChecked: {
      color: "inherit"
    },
    descriptionDisabled: {
      color: "inherit"
    }
  };
  var primaryCompoundTheme = {
    description: {
      color: palette.white,
      selectors: (_a2 = {}, _a2[HighContrastSelector] = __assign({ backgroundColor: "WindowText", color: "Window" }, getHighContrastNoAdjustStyle()), _a2)
    },
    descriptionHovered: {
      color: palette.white,
      selectors: (_b2 = {}, _b2[HighContrastSelector] = {
        backgroundColor: "Highlight",
        color: "Window"
      }, _b2)
    },
    descriptionPressed: {
      color: "inherit",
      selectors: (_c2 = {}, _c2[HighContrastSelector] = __assign({ color: "Window", backgroundColor: "WindowText" }, getHighContrastNoAdjustStyle()), _c2)
    },
    descriptionChecked: {
      color: "inherit",
      selectors: (_d2 = {}, _d2[HighContrastSelector] = __assign({ color: "Window", backgroundColor: "WindowText" }, getHighContrastNoAdjustStyle()), _d2)
    },
    descriptionDisabled: {
      color: "inherit",
      selectors: (_e2 = {}, _e2[HighContrastSelector] = {
        color: "inherit"
      }, _e2)
    }
  };
  return concatStyleSets(baseButtonStyles, compoundButtonStyles, primary ? primaryStyles(theme) : standardStyles(theme), primary ? primaryCompoundTheme : standardCompoundTheme, splitButtonStyles, customStyles);
});

// node_modules/@fluentui/react/lib/components/Button/CompoundButton/CompoundButton.js
var CompoundButton = function(_super) {
  __extends(CompoundButton2, _super);
  function CompoundButton2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  CompoundButton2.prototype.render = function() {
    var _a2 = this.props, _b2 = _a2.primary, primary = _b2 === void 0 ? false : _b2, styles = _a2.styles, theme = _a2.theme;
    return React17.createElement(BaseButton, __assign({}, this.props, { variantClassName: primary ? "ms-Button--compoundPrimary" : "ms-Button--compound", styles: getStyles7(theme, styles, primary) }));
  };
  CompoundButton2 = __decorate([
    customizable("CompoundButton", ["theme", "styles"], true)
  ], CompoundButton2);
  return CompoundButton2;
}(React17.Component);

// node_modules/@fluentui/react/lib/components/Button/IconButton/IconButton.js
var React18 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Button/IconButton/IconButton.styles.js
var getStyles8 = memoizeFunction(function(theme, customStyles) {
  var _a2;
  var baseButtonStyles = getStyles3(theme);
  var splitButtonStyles = getStyles4(theme);
  var palette = theme.palette, semanticColors = theme.semanticColors;
  var iconButtonStyles = {
    root: {
      padding: "0 4px",
      width: "32px",
      height: "32px",
      backgroundColor: "transparent",
      border: "none",
      color: semanticColors.link
    },
    rootHovered: {
      color: palette.themeDarkAlt,
      backgroundColor: palette.neutralLighter,
      selectors: (_a2 = {}, _a2[HighContrastSelector] = {
        borderColor: "Highlight",
        color: "Highlight"
      }, _a2)
    },
    rootHasMenu: {
      width: "auto"
    },
    rootPressed: {
      color: palette.themeDark,
      backgroundColor: palette.neutralLight
    },
    rootExpanded: {
      color: palette.themeDark,
      backgroundColor: palette.neutralLight
    },
    rootChecked: {
      color: palette.themeDark,
      backgroundColor: palette.neutralLight
    },
    rootCheckedHovered: {
      color: palette.themeDark,
      backgroundColor: palette.neutralQuaternaryAlt
    },
    rootDisabled: {
      color: palette.neutralTertiaryAlt
    }
  };
  return concatStyleSets(baseButtonStyles, iconButtonStyles, splitButtonStyles, customStyles);
});

// node_modules/@fluentui/react/lib/components/Button/IconButton/IconButton.js
var IconButton = function(_super) {
  __extends(IconButton2, _super);
  function IconButton2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  IconButton2.prototype.render = function() {
    var _a2 = this.props, styles = _a2.styles, theme = _a2.theme;
    return React18.createElement(BaseButton, __assign({}, this.props, { variantClassName: "ms-Button--icon", styles: getStyles8(theme, styles), onRenderText: nullRender, onRenderDescription: nullRender }));
  };
  IconButton2 = __decorate([
    customizable("IconButton", ["theme", "styles"], true)
  ], IconButton2);
  return IconButton2;
}(React18.Component);

// node_modules/@fluentui/react/lib/components/Button/PrimaryButton/PrimaryButton.js
var React19 = __toESM(require_react());
var PrimaryButton = function(_super) {
  __extends(PrimaryButton2, _super);
  function PrimaryButton2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  PrimaryButton2.prototype.render = function() {
    return React19.createElement(DefaultButton, __assign({}, this.props, { primary: true, onRenderDescription: nullRender }));
  };
  PrimaryButton2 = __decorate([
    customizable("PrimaryButton", ["theme", "styles"], true)
  ], PrimaryButton2);
  return PrimaryButton2;
}(React19.Component);

// node_modules/@fluentui/react/lib/components/Button/Button.js
var React20 = __toESM(require_react());
var Button = function(_super) {
  __extends(Button2, _super);
  function Button2(props) {
    var _this = _super.call(this, props) || this;
    warn("The Button component has been deprecated. Use specific variants instead. (PrimaryButton, DefaultButton, IconButton, ActionButton, etc.)");
    return _this;
  }
  Button2.prototype.render = function() {
    var props = this.props;
    switch (props.buttonType) {
      case ButtonType.command:
        return React20.createElement(ActionButton, __assign({}, props));
      case ButtonType.compound:
        return React20.createElement(CompoundButton, __assign({}, props));
      case ButtonType.icon:
        return React20.createElement(IconButton, __assign({}, props));
      case ButtonType.primary:
        return React20.createElement(PrimaryButton, __assign({}, props));
      default:
        return React20.createElement(DefaultButton, __assign({}, props));
    }
  };
  return Button2;
}(React20.Component);

// node_modules/@fluentui/react/lib/components/Button/CommandBarButton/CommandBarButton.js
var React21 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Button/CommandBarButton/CommandBarButton.styles.js
var getStyles9 = memoizeFunction(function(theme, customStyles, focusInset, focusColor) {
  var _a2, _b2, _c2, _d2, _e2, _f, _g, _h, _j, _k, _l, _m, _o, _p;
  var baseButtonStyles = getStyles3(theme);
  var baseSplitButtonStyles = getStyles4(theme);
  var p = theme.palette, semanticColors = theme.semanticColors;
  var commandButtonHighContrastFocus = {
    left: 4,
    top: 4,
    bottom: 4,
    right: 4,
    border: "none"
  };
  var commandButtonStyles = {
    root: [
      getFocusStyle(theme, {
        inset: 2,
        highContrastStyle: commandButtonHighContrastFocus,
        borderColor: "transparent"
      }),
      theme.fonts.medium,
      {
        minWidth: "40px",
        backgroundColor: p.white,
        color: p.neutralPrimary,
        padding: "0 4px",
        border: "none",
        borderRadius: 0,
        selectors: (_a2 = {}, _a2[HighContrastSelector] = {
          border: "none"
        }, _a2)
      }
    ],
    rootHovered: {
      backgroundColor: p.neutralLighter,
      color: p.neutralDark,
      selectors: (_b2 = {}, _b2[HighContrastSelector] = {
        color: "Highlight"
      }, _b2["." + ButtonGlobalClassNames.msButtonIcon] = {
        color: p.themeDarkAlt
      }, _b2["." + ButtonGlobalClassNames.msButtonMenuIcon] = {
        color: p.neutralPrimary
      }, _b2)
    },
    rootPressed: {
      backgroundColor: p.neutralLight,
      color: p.neutralDark,
      selectors: (_c2 = {}, _c2["." + ButtonGlobalClassNames.msButtonIcon] = {
        color: p.themeDark
      }, _c2["." + ButtonGlobalClassNames.msButtonMenuIcon] = {
        color: p.neutralPrimary
      }, _c2)
    },
    rootChecked: {
      backgroundColor: p.neutralLight,
      color: p.neutralDark,
      selectors: (_d2 = {}, _d2["." + ButtonGlobalClassNames.msButtonIcon] = {
        color: p.themeDark
      }, _d2["." + ButtonGlobalClassNames.msButtonMenuIcon] = {
        color: p.neutralPrimary
      }, _d2)
    },
    rootCheckedHovered: {
      backgroundColor: p.neutralQuaternaryAlt,
      selectors: (_e2 = {}, _e2["." + ButtonGlobalClassNames.msButtonIcon] = {
        color: p.themeDark
      }, _e2["." + ButtonGlobalClassNames.msButtonMenuIcon] = {
        color: p.neutralPrimary
      }, _e2)
    },
    rootExpanded: {
      backgroundColor: p.neutralLight,
      color: p.neutralDark,
      selectors: (_f = {}, _f["." + ButtonGlobalClassNames.msButtonIcon] = {
        color: p.themeDark
      }, _f["." + ButtonGlobalClassNames.msButtonMenuIcon] = {
        color: p.neutralPrimary
      }, _f)
    },
    rootExpandedHovered: {
      backgroundColor: p.neutralQuaternaryAlt
    },
    rootDisabled: {
      backgroundColor: p.white,
      selectors: (_g = {}, _g["." + ButtonGlobalClassNames.msButtonIcon] = {
        color: semanticColors.disabledBodySubtext,
        selectors: (_h = {}, _h[HighContrastSelector] = __assign({ color: "GrayText" }, getHighContrastNoAdjustStyle()), _h)
      }, _g[HighContrastSelector] = __assign({ color: "GrayText", backgroundColor: "Window" }, getHighContrastNoAdjustStyle()), _g)
    },
    splitButtonContainer: {
      height: "100%",
      selectors: (_j = {}, _j[HighContrastSelector] = {
        border: "none"
      }, _j)
    },
    splitButtonDividerDisabled: {
      selectors: (_k = {}, _k[HighContrastSelector] = {
        backgroundColor: "Window"
      }, _k)
    },
    splitButtonDivider: {
      backgroundColor: p.neutralTertiaryAlt
    },
    splitButtonMenuButton: {
      backgroundColor: p.white,
      border: "none",
      borderTopRightRadius: "0",
      borderBottomRightRadius: "0",
      color: p.neutralSecondary,
      selectors: {
        ":hover": {
          backgroundColor: p.neutralLighter,
          color: p.neutralDark,
          selectors: (_l = {}, _l[HighContrastSelector] = {
            color: "Highlight"
          }, _l["." + ButtonGlobalClassNames.msButtonIcon] = {
            color: p.neutralPrimary
          }, _l)
        },
        ":active": {
          backgroundColor: p.neutralLight,
          selectors: (_m = {}, _m["." + ButtonGlobalClassNames.msButtonIcon] = {
            color: p.neutralPrimary
          }, _m)
        }
      }
    },
    splitButtonMenuButtonDisabled: {
      backgroundColor: p.white,
      selectors: (_o = {}, _o[HighContrastSelector] = __assign({ color: "GrayText", border: "none", backgroundColor: "Window" }, getHighContrastNoAdjustStyle()), _o)
    },
    splitButtonMenuButtonChecked: {
      backgroundColor: p.neutralLight,
      color: p.neutralDark,
      selectors: {
        ":hover": {
          backgroundColor: p.neutralQuaternaryAlt
        }
      }
    },
    splitButtonMenuButtonExpanded: {
      backgroundColor: p.neutralLight,
      color: p.black,
      selectors: {
        ":hover": {
          backgroundColor: p.neutralQuaternaryAlt
        }
      }
    },
    splitButtonMenuIcon: {
      color: p.neutralPrimary
    },
    splitButtonMenuIconDisabled: {
      color: p.neutralTertiary
    },
    label: {
      fontWeight: "normal"
    },
    icon: {
      color: p.themePrimary
    },
    menuIcon: (_p = {
      color: p.neutralSecondary
    }, _p[HighContrastSelector] = {
      color: "GrayText"
    }, _p)
  };
  return concatStyleSets(baseButtonStyles, baseSplitButtonStyles, commandButtonStyles, customStyles);
});

// node_modules/@fluentui/react/lib/components/Button/CommandBarButton/CommandBarButton.js
var CommandBarButton = function(_super) {
  __extends(CommandBarButton2, _super);
  function CommandBarButton2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  CommandBarButton2.prototype.render = function() {
    var _a2 = this.props, styles = _a2.styles, theme = _a2.theme;
    return React21.createElement(BaseButton, __assign({}, this.props, { variantClassName: "ms-Button--commandBar", styles: getStyles9(theme, styles), onRenderDescription: nullRender }));
  };
  CommandBarButton2 = __decorate([
    customizable("CommandBarButton", ["theme", "styles"], true)
  ], CommandBarButton2);
  return CommandBarButton2;
}(React21.Component);

// node_modules/@fluentui/react/lib/components/Button/CommandButton/CommandButton.js
var CommandButton = ActionButton;

// node_modules/@fluentui/react/lib/components/Button/MessageBarButton/MessageBarButton.js
var React22 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Button/MessageBarButton/MessageBarButton.styles.js
var getStyles10 = memoizeFunction(function(theme, customStyles) {
  return concatStyleSets({
    root: [
      getFocusStyle(theme, {
        inset: 1,
        highContrastStyle: {
          outlineOffset: "-4px",
          outline: "1px solid Window"
        },
        borderColor: "transparent"
      }),
      {
        height: 24
      }
    ]
  }, customStyles);
});

// node_modules/@fluentui/react/lib/components/Button/MessageBarButton/MessageBarButton.js
var MessageBarButton = function(_super) {
  __extends(MessageBarButton2, _super);
  function MessageBarButton2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MessageBarButton2.prototype.render = function() {
    var _a2 = this.props, styles = _a2.styles, theme = _a2.theme;
    return React22.createElement(DefaultButton, __assign({}, this.props, { styles: getStyles10(theme, styles), onRenderDescription: nullRender }));
  };
  MessageBarButton2 = __decorate([
    customizable("MessageBarButton", ["theme", "styles"], true)
  ], MessageBarButton2);
  return MessageBarButton2;
}(React22.Component);

// node_modules/@fluentui/react/lib/components/Overlay/Overlay.base.js
var React23 = __toESM(require_react());
var getClassNames3 = classNamesFunction();
var OverlayBase = function(_super) {
  __extends(OverlayBase2, _super);
  function OverlayBase2(props) {
    var _this = _super.call(this, props) || this;
    initializeComponentRef(_this);
    var _a2 = _this.props.allowTouchBodyScroll, allowTouchBodyScroll = _a2 === void 0 ? false : _a2;
    _this._allowTouchBodyScroll = allowTouchBodyScroll;
    return _this;
  }
  OverlayBase2.prototype.componentDidMount = function() {
    !this._allowTouchBodyScroll && disableBodyScroll();
  };
  OverlayBase2.prototype.componentWillUnmount = function() {
    !this._allowTouchBodyScroll && enableBodyScroll();
  };
  OverlayBase2.prototype.render = function() {
    var _a2 = this.props, isDark = _a2.isDarkThemed, className = _a2.className, theme = _a2.theme, styles = _a2.styles;
    var divProps = getNativeProps(this.props, divProperties);
    var classNames = getClassNames3(styles, {
      theme,
      className,
      isDark
    });
    return React23.createElement("div", __assign({}, divProps, { className: classNames.root }));
  };
  return OverlayBase2;
}(React23.Component);

// node_modules/@fluentui/react/lib/components/Overlay/Overlay.styles.js
var GlobalClassNames3 = {
  root: "ms-Overlay",
  rootDark: "ms-Overlay--dark"
};
var getStyles11 = function(props) {
  var _a2;
  var className = props.className, theme = props.theme, isNone = props.isNone, isDark = props.isDark;
  var palette = theme.palette;
  var classNames = getGlobalClassNames(GlobalClassNames3, theme);
  return {
    root: [
      classNames.root,
      theme.fonts.medium,
      {
        backgroundColor: palette.whiteTranslucent40,
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        position: "absolute",
        selectors: (_a2 = {}, _a2[HighContrastSelector] = {
          border: "1px solid WindowText",
          opacity: 0
        }, _a2)
      },
      isNone && {
        visibility: "hidden"
      },
      isDark && [
        classNames.rootDark,
        {
          backgroundColor: palette.blackTranslucent40
        }
      ],
      className
    ]
  };
};

// node_modules/@fluentui/react/lib/components/Overlay/Overlay.js
var Overlay = styled(OverlayBase, getStyles11, void 0, {
  scope: "Overlay"
});

// node_modules/@fluentui/react/lib/components/Panel/Panel.types.js
var PanelType;
(function(PanelType2) {
  PanelType2[PanelType2["smallFluid"] = 0] = "smallFluid";
  PanelType2[PanelType2["smallFixedFar"] = 1] = "smallFixedFar";
  PanelType2[PanelType2["smallFixedNear"] = 2] = "smallFixedNear";
  PanelType2[PanelType2["medium"] = 3] = "medium";
  PanelType2[PanelType2["large"] = 4] = "large";
  PanelType2[PanelType2["largeFixed"] = 5] = "largeFixed";
  PanelType2[PanelType2["extraLarge"] = 6] = "extraLarge";
  PanelType2[PanelType2["custom"] = 7] = "custom";
  PanelType2[PanelType2["customNear"] = 8] = "customNear";
})(PanelType || (PanelType = {}));

// node_modules/@fluentui/react/lib/components/Panel/Panel.base.js
var React24 = __toESM(require_react());
var getClassNames4 = classNamesFunction();
var COMPONENT_NAME3 = "Panel";
var PanelVisibilityState;
(function(PanelVisibilityState2) {
  PanelVisibilityState2[PanelVisibilityState2["closed"] = 0] = "closed";
  PanelVisibilityState2[PanelVisibilityState2["animatingOpen"] = 1] = "animatingOpen";
  PanelVisibilityState2[PanelVisibilityState2["open"] = 2] = "open";
  PanelVisibilityState2[PanelVisibilityState2["animatingClosed"] = 3] = "animatingClosed";
})(PanelVisibilityState || (PanelVisibilityState = {}));
var PanelBase = function(_super) {
  __extends(PanelBase2, _super);
  function PanelBase2(props) {
    var _this = _super.call(this, props) || this;
    _this._panel = React24.createRef();
    _this._animationCallback = null;
    _this._hasCustomNavigation = !!(_this.props.onRenderNavigation || _this.props.onRenderNavigationContent);
    _this.dismiss = function(ev) {
      if (_this.props.onDismiss && _this.isActive) {
        _this.props.onDismiss(ev);
      }
      if (!ev || ev && !ev.defaultPrevented) {
        _this.close();
      }
    };
    _this._allowScrollOnPanel = function(elt) {
      if (elt) {
        if (_this._allowTouchBodyScroll) {
          allowOverscrollOnElement(elt, _this._events);
        } else {
          allowScrollOnElement(elt, _this._events);
        }
      } else {
        _this._events.off(_this._scrollableContent);
      }
      _this._scrollableContent = elt;
    };
    _this._onRenderNavigation = function(props2) {
      if (!_this.props.onRenderNavigationContent && !_this.props.onRenderNavigation && !_this.props.hasCloseButton) {
        return null;
      }
      var _a3 = _this.props.onRenderNavigationContent, onRenderNavigationContent = _a3 === void 0 ? _this._onRenderNavigationContent : _a3;
      return React24.createElement("div", { className: _this._classNames.navigation }, onRenderNavigationContent(props2, _this._onRenderNavigationContent));
    };
    _this._onRenderNavigationContent = function(props2) {
      var _a3;
      var closeButtonAriaLabel = props2.closeButtonAriaLabel, hasCloseButton = props2.hasCloseButton, _b2 = props2.onRenderHeader, onRenderHeader = _b2 === void 0 ? _this._onRenderHeader : _b2;
      if (hasCloseButton) {
        var iconButtonStyles = (_a3 = _this._classNames.subComponentStyles) === null || _a3 === void 0 ? void 0 : _a3.closeButton();
        return React24.createElement(
          React24.Fragment,
          null,
          !_this._hasCustomNavigation && onRenderHeader(_this.props, _this._onRenderHeader, _this._headerTextId),
          React24.createElement(IconButton, { styles: iconButtonStyles, className: _this._classNames.closeButton, onClick: _this._onPanelClick, ariaLabel: closeButtonAriaLabel, title: closeButtonAriaLabel, "data-is-visible": true, iconProps: { iconName: "Cancel" } })
        );
      }
      return null;
    };
    _this._onRenderHeader = function(props2, defaultRender, headerTextId) {
      var headerText = props2.headerText, _a3 = props2.headerTextProps, headerTextProps = _a3 === void 0 ? {} : _a3;
      if (headerText) {
        return React24.createElement(
          "div",
          { className: _this._classNames.header },
          React24.createElement("div", __assign({ id: headerTextId, role: "heading", "aria-level": 1 }, headerTextProps, { className: css(_this._classNames.headerText, headerTextProps.className) }), headerText)
        );
      }
      return null;
    };
    _this._onRenderBody = function(props2) {
      return React24.createElement("div", { className: _this._classNames.content }, props2.children);
    };
    _this._onRenderFooter = function(props2) {
      var _a3 = _this.props.onRenderFooterContent, onRenderFooterContent = _a3 === void 0 ? null : _a3;
      if (onRenderFooterContent) {
        return React24.createElement(
          "div",
          { className: _this._classNames.footer },
          React24.createElement("div", { className: _this._classNames.footerInner }, onRenderFooterContent())
        );
      }
      return null;
    };
    _this._animateTo = function(newVisibilityState) {
      if (newVisibilityState === PanelVisibilityState.open && _this.props.onOpen) {
        _this.props.onOpen();
      }
      _this._animationCallback = _this._async.setTimeout(function() {
        _this.setState({ visibility: newVisibilityState });
        _this._onTransitionComplete();
      }, 200);
    };
    _this._clearExistingAnimationTimer = function() {
      if (_this._animationCallback !== null) {
        _this._async.clearTimeout(_this._animationCallback);
      }
    };
    _this._onPanelClick = function(ev) {
      _this.dismiss(ev);
    };
    _this._onTransitionComplete = function() {
      _this._updateFooterPosition();
      if (_this.state.visibility === PanelVisibilityState.open && _this.props.onOpened) {
        _this.props.onOpened();
      }
      if (_this.state.visibility === PanelVisibilityState.closed && _this.props.onDismissed) {
        _this.props.onDismissed();
      }
    };
    var _a2 = _this.props.allowTouchBodyScroll, allowTouchBodyScroll = _a2 === void 0 ? false : _a2;
    _this._allowTouchBodyScroll = allowTouchBodyScroll;
    _this._async = new Async(_this);
    _this._events = new EventGroup(_this);
    initializeComponentRef(_this);
    warnDeprecations(COMPONENT_NAME3, props, {
      ignoreExternalFocusing: "focusTrapZoneProps",
      forceFocusInsideTrap: "focusTrapZoneProps",
      firstFocusableSelector: "focusTrapZoneProps"
    });
    _this.state = {
      isFooterSticky: false,
      visibility: PanelVisibilityState.closed,
      id: getId("Panel")
    };
    return _this;
  }
  PanelBase2.getDerivedStateFromProps = function(nextProps, prevState) {
    if (nextProps.isOpen === void 0) {
      return null;
    }
    if (nextProps.isOpen && (prevState.visibility === PanelVisibilityState.closed || prevState.visibility === PanelVisibilityState.animatingClosed)) {
      return { visibility: PanelVisibilityState.animatingOpen };
    }
    if (!nextProps.isOpen && (prevState.visibility === PanelVisibilityState.open || prevState.visibility === PanelVisibilityState.animatingOpen)) {
      return { visibility: PanelVisibilityState.animatingClosed };
    }
    return null;
  };
  PanelBase2.prototype.componentDidMount = function() {
    this._events.on(window, "resize", this._updateFooterPosition);
    if (this._shouldListenForOuterClick(this.props)) {
      this._events.on(document.body, "mousedown", this._dismissOnOuterClick, true);
    }
    if (this.props.isOpen) {
      this.setState({ visibility: PanelVisibilityState.animatingOpen });
    }
  };
  PanelBase2.prototype.componentDidUpdate = function(previousProps, previousState) {
    var shouldListenOnOuterClick = this._shouldListenForOuterClick(this.props);
    var previousShouldListenOnOuterClick = this._shouldListenForOuterClick(previousProps);
    if (this.state.visibility !== previousState.visibility) {
      this._clearExistingAnimationTimer();
      if (this.state.visibility === PanelVisibilityState.animatingOpen) {
        this._animateTo(PanelVisibilityState.open);
      } else if (this.state.visibility === PanelVisibilityState.animatingClosed) {
        this._animateTo(PanelVisibilityState.closed);
      }
    }
    if (shouldListenOnOuterClick && !previousShouldListenOnOuterClick) {
      this._events.on(document.body, "mousedown", this._dismissOnOuterClick, true);
    } else if (!shouldListenOnOuterClick && previousShouldListenOnOuterClick) {
      this._events.off(document.body, "mousedown", this._dismissOnOuterClick, true);
    }
  };
  PanelBase2.prototype.componentWillUnmount = function() {
    this._async.dispose();
    this._events.dispose();
  };
  PanelBase2.prototype.render = function() {
    var _a2 = this.props, _b2 = _a2.className, className = _b2 === void 0 ? "" : _b2, elementToFocusOnDismiss = _a2.elementToFocusOnDismiss, firstFocusableSelector = _a2.firstFocusableSelector, focusTrapZoneProps = _a2.focusTrapZoneProps, forceFocusInsideTrap = _a2.forceFocusInsideTrap, hasCloseButton = _a2.hasCloseButton, headerText = _a2.headerText, _c2 = _a2.headerClassName, headerClassName = _c2 === void 0 ? "" : _c2, ignoreExternalFocusing = _a2.ignoreExternalFocusing, isBlocking = _a2.isBlocking, isFooterAtBottom = _a2.isFooterAtBottom, isLightDismiss = _a2.isLightDismiss, isHiddenOnDismiss = _a2.isHiddenOnDismiss, layerProps = _a2.layerProps, overlayProps = _a2.overlayProps, popupProps = _a2.popupProps, type = _a2.type, styles = _a2.styles, theme = _a2.theme, customWidth = _a2.customWidth, _d2 = _a2.onLightDismissClick, onLightDismissClick = _d2 === void 0 ? this._onPanelClick : _d2, _e2 = _a2.onRenderNavigation, onRenderNavigation = _e2 === void 0 ? this._onRenderNavigation : _e2, _f = _a2.onRenderHeader, onRenderHeader = _f === void 0 ? this._onRenderHeader : _f, _g = _a2.onRenderBody, onRenderBody = _g === void 0 ? this._onRenderBody : _g, _h = _a2.onRenderFooter, onRenderFooter = _h === void 0 ? this._onRenderFooter : _h;
    var _j = this.state, isFooterSticky = _j.isFooterSticky, visibility = _j.visibility, id = _j.id;
    var isLeft = type === PanelType.smallFixedNear || type === PanelType.customNear ? true : false;
    var isRTL = getRTL(theme);
    var isOnRightSide = isRTL ? isLeft : !isLeft;
    var customWidthStyles = type === PanelType.custom || type === PanelType.customNear ? { width: customWidth } : {};
    var nativeProps = getNativeProps(this.props, divProperties);
    var isOpen = this.isActive;
    var isAnimating = visibility === PanelVisibilityState.animatingClosed || visibility === PanelVisibilityState.animatingOpen;
    this._headerTextId = headerText && id + "-headerText";
    if (!isOpen && !isAnimating && !isHiddenOnDismiss) {
      return null;
    }
    this._classNames = getClassNames4(styles, {
      theme,
      className,
      focusTrapZoneClassName: focusTrapZoneProps ? focusTrapZoneProps.className : void 0,
      hasCloseButton,
      headerClassName,
      isAnimating,
      isFooterSticky,
      isFooterAtBottom,
      isOnRightSide,
      isOpen,
      isHiddenOnDismiss,
      type,
      hasCustomNavigation: this._hasCustomNavigation
    });
    var _k = this, _classNames = _k._classNames, _allowTouchBodyScroll = _k._allowTouchBodyScroll;
    var overlay;
    if (isBlocking && isOpen) {
      overlay = React24.createElement(Overlay, __assign({ className: _classNames.overlay, isDarkThemed: false, onClick: isLightDismiss ? onLightDismissClick : void 0, allowTouchBodyScroll: _allowTouchBodyScroll }, overlayProps));
    }
    return React24.createElement(
      Layer,
      __assign({}, layerProps),
      React24.createElement(
        Popup,
        __assign({ role: "dialog", "aria-modal": isBlocking ? "true" : void 0, ariaLabelledBy: this._headerTextId ? this._headerTextId : void 0, onDismiss: this.dismiss, className: _classNames.hiddenPanel, enableAriaHiddenSiblings: isOpen ? true : void 0 }, popupProps),
        React24.createElement(
          "div",
          __assign({ "aria-hidden": !isOpen && isAnimating }, nativeProps, { ref: this._panel, className: _classNames.root }),
          overlay,
          React24.createElement(
            FocusTrapZone,
            __assign({ ignoreExternalFocusing, forceFocusInsideTrap: !isBlocking || isHiddenOnDismiss && !isOpen ? false : forceFocusInsideTrap, firstFocusableSelector, isClickableOutsideFocusTrap: true }, focusTrapZoneProps, { className: _classNames.main, style: customWidthStyles, elementToFocusOnDismiss }),
            React24.createElement(
              "div",
              { className: _classNames.contentInner },
              React24.createElement(
                "div",
                { ref: this._allowScrollOnPanel, className: _classNames.scrollableContent, "data-is-scrollable": true },
                React24.createElement("div", { className: _classNames.commands, "data-is-visible": true }, onRenderNavigation(this.props, this._onRenderNavigation)),
                (this._hasCustomNavigation || !hasCloseButton) && onRenderHeader(this.props, this._onRenderHeader, this._headerTextId),
                onRenderBody(this.props, this._onRenderBody),
                onRenderFooter(this.props, this._onRenderFooter)
              )
            )
          )
        )
      )
    );
  };
  PanelBase2.prototype.open = function() {
    if (this.props.isOpen !== void 0) {
      return;
    }
    if (this.isActive) {
      return;
    }
    this.setState({ visibility: PanelVisibilityState.animatingOpen });
  };
  PanelBase2.prototype.close = function() {
    if (this.props.isOpen !== void 0) {
      return;
    }
    if (!this.isActive) {
      return;
    }
    this.setState({ visibility: PanelVisibilityState.animatingClosed });
  };
  Object.defineProperty(PanelBase2.prototype, "isActive", {
    get: function() {
      return this.state.visibility === PanelVisibilityState.open || this.state.visibility === PanelVisibilityState.animatingOpen;
    },
    enumerable: false,
    configurable: true
  });
  PanelBase2.prototype._shouldListenForOuterClick = function(props) {
    return !!props.isBlocking && !!props.isOpen;
  };
  PanelBase2.prototype._updateFooterPosition = function() {
    var scrollableContent = this._scrollableContent;
    if (scrollableContent) {
      var height = scrollableContent.clientHeight;
      var innerHeight_1 = scrollableContent.scrollHeight;
      this.setState({
        isFooterSticky: height < innerHeight_1 ? true : false
      });
    }
  };
  PanelBase2.prototype._dismissOnOuterClick = function(ev) {
    var panel = this._panel.current;
    if (this.isActive && panel && !ev.defaultPrevented) {
      if (!elementContains(panel, ev.target)) {
        if (this.props.onOuterClick) {
          this.props.onOuterClick(ev);
        } else {
          this.dismiss(ev);
        }
      }
    }
  };
  PanelBase2.defaultProps = {
    isHiddenOnDismiss: false,
    isOpen: void 0,
    isBlocking: true,
    hasCloseButton: true,
    type: PanelType.smallFixedFar
  };
  return PanelBase2;
}(React24.Component);

// node_modules/@fluentui/react/lib/components/Panel/Panel.styles.js
var _a;
var _b;
var _c;
var _d;
var _e;
var GlobalClassNames4 = {
  root: "ms-Panel",
  main: "ms-Panel-main",
  commands: "ms-Panel-commands",
  contentInner: "ms-Panel-contentInner",
  scrollableContent: "ms-Panel-scrollableContent",
  navigation: "ms-Panel-navigation",
  closeButton: "ms-Panel-closeButton ms-PanelAction-close",
  header: "ms-Panel-header",
  headerText: "ms-Panel-headerText",
  content: "ms-Panel-content",
  footer: "ms-Panel-footer",
  footerInner: "ms-Panel-footerInner",
  isOpen: "is-open",
  hasCloseButton: "ms-Panel--hasCloseButton",
  smallFluid: "ms-Panel--smFluid",
  smallFixedNear: "ms-Panel--smLeft",
  smallFixedFar: "ms-Panel--sm",
  medium: "ms-Panel--md",
  large: "ms-Panel--lg",
  largeFixed: "ms-Panel--fixed",
  extraLarge: "ms-Panel--xl",
  custom: "ms-Panel--custom",
  customNear: "ms-Panel--customLeft"
};
var panelWidth = {
  full: "100%",
  auto: "auto",
  xs: 272,
  sm: 340,
  md1: 592,
  md2: 644,
  lg: 940
};
var panelMargin = {
  auto: "auto",
  none: 0,
  md: 48,
  lg: 428,
  xl: 176
};
var smallPanelSelectors = (_a = {}, _a["@media (min-width: " + ScreenWidthMinMedium + "px)"] = {
  width: panelWidth.sm
}, _a);
var mediumPanelSelectors = (_b = {}, _b["@media (min-width: " + ScreenWidthMinLarge + "px)"] = {
  width: panelWidth.md1
}, _b["@media (min-width: " + ScreenWidthMinXLarge + "px)"] = {
  width: panelWidth.md2
}, _b);
var largePanelSelectors = (_c = {}, _c["@media (min-width: " + ScreenWidthMinUhfMobile + "px)"] = {
  left: panelMargin.md,
  width: panelWidth.auto
}, _c["@media (min-width: " + ScreenWidthMinXXLarge + "px)"] = {
  left: panelMargin.lg
}, _c);
var largeFixedPanelSelectors = (_d = {}, _d["@media (min-width: " + ScreenWidthMinXXLarge + "px)"] = {
  left: panelMargin.auto,
  width: panelWidth.lg
}, _d);
var extraLargePanelSelectors = (_e = {}, _e["@media (min-width: " + ScreenWidthMinXXLarge + "px)"] = {
  left: panelMargin.xl
}, _e);
var getPanelBreakpoints = function(type) {
  var selectors;
  switch (type) {
    case PanelType.smallFixedFar:
      selectors = __assign({}, smallPanelSelectors);
      break;
    case PanelType.medium:
      selectors = __assign(__assign({}, smallPanelSelectors), mediumPanelSelectors);
      break;
    case PanelType.large:
      selectors = __assign(__assign(__assign({}, smallPanelSelectors), mediumPanelSelectors), largePanelSelectors);
      break;
    case PanelType.largeFixed:
      selectors = __assign(__assign(__assign(__assign({}, smallPanelSelectors), mediumPanelSelectors), largePanelSelectors), largeFixedPanelSelectors);
      break;
    case PanelType.extraLarge:
      selectors = __assign(__assign(__assign(__assign({}, smallPanelSelectors), mediumPanelSelectors), largePanelSelectors), extraLargePanelSelectors);
      break;
    default:
      break;
  }
  return selectors;
};
var commandBarHeight = "44px";
var sharedPaddingStyles = {
  paddingLeft: "24px",
  paddingRight: "24px"
};
var getStyles12 = function(props) {
  var _a2, _b2, _c2, _d2;
  var className = props.className, focusTrapZoneClassName = props.focusTrapZoneClassName, hasCloseButton = props.hasCloseButton, headerClassName = props.headerClassName, isAnimating = props.isAnimating, isFooterSticky = props.isFooterSticky, isFooterAtBottom = props.isFooterAtBottom, isOnRightSide = props.isOnRightSide, isOpen = props.isOpen, isHiddenOnDismiss = props.isHiddenOnDismiss, hasCustomNavigation = props.hasCustomNavigation, theme = props.theme, _e2 = props.type, type = _e2 === void 0 ? PanelType.smallFixedFar : _e2;
  var effects = theme.effects, fonts = theme.fonts, semanticColors = theme.semanticColors;
  var classNames = getGlobalClassNames(GlobalClassNames4, theme);
  var isCustomPanel = type === PanelType.custom || type === PanelType.customNear;
  return {
    root: [
      classNames.root,
      theme.fonts.medium,
      isOpen && classNames.isOpen,
      hasCloseButton && classNames.hasCloseButton,
      {
        pointerEvents: "none",
        position: "absolute",
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
      },
      isCustomPanel && isOnRightSide && classNames.custom,
      isCustomPanel && !isOnRightSide && classNames.customNear,
      className
    ],
    overlay: [
      {
        pointerEvents: "auto",
        cursor: "pointer"
      },
      isOpen && isAnimating && AnimationClassNames.fadeIn100,
      !isOpen && isAnimating && AnimationClassNames.fadeOut100
    ],
    hiddenPanel: [
      !isOpen && !isAnimating && isHiddenOnDismiss && {
        visibility: "hidden"
      }
    ],
    main: [
      classNames.main,
      {
        backgroundColor: semanticColors.bodyBackground,
        boxShadow: effects.elevation64,
        pointerEvents: "auto",
        position: "absolute",
        display: "flex",
        flexDirection: "column",
        overflowX: "hidden",
        overflowY: "auto",
        WebkitOverflowScrolling: "touch",
        bottom: 0,
        top: 0,
        left: panelMargin.auto,
        right: panelMargin.none,
        width: panelWidth.full,
        selectors: __assign((_a2 = {}, _a2[HighContrastSelector] = {
          borderLeft: "3px solid " + semanticColors.variantBorder,
          borderRight: "3px solid " + semanticColors.variantBorder
        }, _a2), getPanelBreakpoints(type))
      },
      type === PanelType.smallFluid && {
        left: panelMargin.none
      },
      type === PanelType.smallFixedNear && {
        left: panelMargin.none,
        right: panelMargin.auto,
        width: panelWidth.xs
      },
      type === PanelType.customNear && {
        right: "auto",
        left: 0
      },
      isCustomPanel && {
        maxWidth: "100vw"
      },
      isOpen && isAnimating && !isOnRightSide && AnimationClassNames.slideRightIn40,
      isOpen && isAnimating && isOnRightSide && AnimationClassNames.slideLeftIn40,
      !isOpen && isAnimating && !isOnRightSide && AnimationClassNames.slideLeftOut40,
      !isOpen && isAnimating && isOnRightSide && AnimationClassNames.slideRightOut40,
      focusTrapZoneClassName
    ],
    commands: [
      classNames.commands,
      {
        paddingTop: 18,
        selectors: (_b2 = {}, _b2["@media (min-height: " + ScreenWidthMinMedium + "px)"] = {
          position: "sticky",
          top: 0,
          zIndex: 1
        }, _b2)
      },
      hasCustomNavigation && {
        paddingTop: "inherit"
      },
      isFooterSticky && {
        backgroundColor: semanticColors.bodyBackground
      }
    ],
    navigation: [
      classNames.navigation,
      {
        display: "flex",
        justifyContent: "flex-end"
      },
      hasCustomNavigation && {
        height: commandBarHeight
      }
    ],
    contentInner: [
      classNames.contentInner,
      {
        display: "flex",
        flexDirection: "column",
        flexGrow: 1,
        overflowY: "hidden"
      }
    ],
    header: [
      classNames.header,
      sharedPaddingStyles,
      {
        alignSelf: "flex-start"
      },
      hasCloseButton && !hasCustomNavigation && {
        flexGrow: 1
      },
      hasCustomNavigation && {
        flexShrink: 0
      }
    ],
    headerText: [
      classNames.headerText,
      fonts.xLarge,
      {
        color: semanticColors.bodyText,
        lineHeight: "27px",
        overflowWrap: "break-word",
        wordWrap: "break-word",
        wordBreak: "break-word",
        hyphens: "auto"
      },
      headerClassName
    ],
    scrollableContent: [
      classNames.scrollableContent,
      {
        overflowY: "auto"
      },
      isFooterAtBottom && {
        flexGrow: 1,
        display: "inherit",
        flexDirection: "inherit"
      }
    ],
    content: [
      classNames.content,
      sharedPaddingStyles,
      {
        paddingBottom: 20
      },
      isFooterAtBottom && {
        selectors: (_c2 = {}, _c2["@media (min-height: " + ScreenWidthMinMedium + "px)"] = {
          flexGrow: 1
        }, _c2)
      }
    ],
    footer: [
      classNames.footer,
      {
        flexShrink: 0,
        borderTop: "1px solid transparent",
        transition: "opacity " + AnimationVariables.durationValue3 + " " + AnimationVariables.easeFunction2,
        selectors: (_d2 = {}, _d2["@media (min-height: " + ScreenWidthMinMedium + "px)"] = {
          position: "sticky",
          bottom: 0
        }, _d2)
      },
      isFooterSticky && {
        backgroundColor: semanticColors.bodyBackground,
        borderTopColor: semanticColors.variantBorder
      }
    ],
    footerInner: [
      classNames.footerInner,
      sharedPaddingStyles,
      {
        paddingBottom: 16,
        paddingTop: 16
      }
    ],
    subComponentStyles: {
      closeButton: {
        root: [
          classNames.closeButton,
          {
            marginRight: 14,
            color: theme.palette.neutralSecondary,
            fontSize: IconFontSizes.large
          },
          hasCustomNavigation && {
            marginRight: 0,
            height: "auto",
            width: "44px"
          }
        ],
        rootHovered: {
          color: theme.palette.neutralPrimary
        }
      }
    }
  };
};

// node_modules/@fluentui/react/lib/components/Panel/Panel.js
var Panel = styled(PanelBase, getStyles12, void 0, {
  scope: "Panel"
});

export {
  ContextualMenuItemType,
  ContextualMenuItemBase,
  getMenuItemStyles,
  ContextualMenuItem,
  transitionKeysAreEqual,
  transitionKeysContain,
  buildKeytipConfigMap,
  constructKeytip,
  KTP_PREFIX,
  KTP_SEPARATOR,
  KTP_FULL_PREFIX,
  DATAKTP_TARGET,
  DATAKTP_EXECUTE_TARGET,
  DATAKTP_ARIA_TARGET,
  KTP_LAYER_ID,
  KTP_ARIA_SEPARATOR,
  KeytipEvents,
  KeytipManager,
  sequencesToID,
  mergeOverflows,
  ktpTargetFromSequences,
  ktpTargetFromId,
  getAriaDescribedBy,
  KeytipData,
  useKeytipRef,
  VerticalDivider,
  ResponsiveMode,
  setResponsiveMode,
  initializeResponsiveMode,
  getInitialResponsiveMode,
  withResponsiveMode,
  getResponsiveMode,
  useResponsiveMode,
  getSubmenuItems,
  canAnyMenuItemsCheck,
  ContextualMenuBase,
  ContextualMenu,
  ButtonGlobalClassNames,
  getSplitButtonClassNames,
  BaseButton,
  ElementType,
  ButtonType,
  getStyles3 as getStyles,
  DefaultButton,
  getStyles6 as getStyles2,
  ActionButton,
  CompoundButton,
  IconButton,
  PrimaryButton,
  Button,
  CommandBarButton,
  CommandButton,
  MessageBarButton,
  OverlayBase,
  Overlay,
  PanelType,
  PanelBase,
  Panel
};
//# sourceMappingURL=chunk-VKJ5QU44.js.map
