{
  "version": 3,
  "sources": ["../../@fluentui/react/lib/components/Tooltip/components/Tooltip/Tooltip.base.tsx", "../../@fluentui/react/lib/components/Tooltip/components/Tooltip/Tooltip.styles.ts", "../../@fluentui/react/lib/components/Tooltip/components/Tooltip/Tooltip.tsx", "../../@fluentui/react/lib/components/Tooltip/components/Tooltip/Tooltip.types.ts", "../../@fluentui/react/lib/components/Tooltip/components/Tooltip/TooltipHost.types.ts", "../../@fluentui/react/lib/components/Tooltip/components/Tooltip/TooltipHost.base.tsx", "../../@fluentui/react/lib/components/Tooltip/components/Tooltip/TooltipHost.styles.ts", "../../@fluentui/react/lib/components/Tooltip/components/Tooltip/TooltipHost.ts"],
  "sourcesContent": ["import * as React from 'react';\nimport { classNamesFunction, divProperties, getNativeProps } from '../../Utilities';\nimport { Callout } from '../../Callout';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport type { IProcessedStyleSet } from '../../Styling';\nimport type { ITooltipProps, ITooltipStyleProps, ITooltipStyles } from './Tooltip.types';\n\nconst getClassNames = classNamesFunction<ITooltipStyleProps, ITooltipStyles>();\n\nexport class TooltipBase extends React.Component<ITooltipProps, any> {\n  // Specify default props values\n  public static defaultProps: Partial<ITooltipProps> = {\n    directionalHint: DirectionalHint.topCenter,\n    maxWidth: '364px',\n    calloutProps: {\n      isBeakVisible: true,\n      beakWidth: 16,\n      gapSpace: 0,\n      setInitialFocus: true,\n      doNotLayer: false,\n    },\n  };\n\n  private _classNames: IProcessedStyleSet<ITooltipStyles>;\n\n  public render(): JSX.Element {\n    const {\n      className,\n      calloutProps,\n      directionalHint,\n      directionalHintForRTL,\n      styles,\n      id,\n      maxWidth,\n      onRenderContent = this._onRenderContent,\n      targetElement,\n      theme,\n    } = this.props;\n\n    this._classNames = getClassNames(styles!, {\n      theme: theme!,\n      className: className || (calloutProps && calloutProps.className),\n      beakWidth: calloutProps && calloutProps.beakWidth,\n      gapSpace: calloutProps && calloutProps.gapSpace,\n      maxWidth: maxWidth!,\n    });\n\n    return (\n      <Callout\n        target={targetElement}\n        directionalHint={directionalHint}\n        directionalHintForRTL={directionalHintForRTL}\n        {...calloutProps}\n        {...getNativeProps(this.props, divProperties, ['id'])} // omitting ID due to it being used in the div below\n        className={this._classNames.root}\n      >\n        <div\n          className={this._classNames.content}\n          id={id}\n          onMouseEnter={this.props.onMouseEnter}\n          onMouseLeave={this.props.onMouseLeave}\n        >\n          {onRenderContent(this.props, this._onRenderContent)}\n        </div>\n      </Callout>\n    );\n  }\n\n  private _onRenderContent = (props: ITooltipProps): JSX.Element => {\n    if (typeof props.content === 'string') {\n      return <p className={this._classNames.subText}>{props.content}</p>;\n    } else {\n      return <div className={this._classNames.subText}>{props.content}</div>;\n    }\n  };\n}\n", "import { AnimationClassNames } from '../../Styling';\nimport type { ITooltipStyleProps, ITooltipStyles } from './Tooltip.types';\n\nexport const getStyles = (props: ITooltipStyleProps): ITooltipStyles => {\n  const { className, beakWidth = 16, gapSpace = 0, maxWidth, theme } = props;\n  const { semanticColors, fonts, effects } = theme;\n\n  // The math here is done to account for the 45 degree rotation of the beak\n  // and sub-pixel rounding that differs across browsers, which is more noticeable when\n  // the device pixel ratio is larger\n  const tooltipGapSpace = -(Math.sqrt((beakWidth * beakWidth) / 2) + gapSpace) + 1 / window.devicePixelRatio;\n\n  return {\n    root: [\n      'ms-Tooltip',\n      theme.fonts.medium,\n      AnimationClassNames.fadeIn200,\n      {\n        background: semanticColors.menuBackground,\n        boxShadow: effects.elevation8,\n        padding: '8px',\n        maxWidth: maxWidth,\n        selectors: {\n          ':after': {\n            content: `''`,\n            position: 'absolute',\n            bottom: tooltipGapSpace,\n            left: tooltipGapSpace,\n            right: tooltipGapSpace,\n            top: tooltipGapSpace,\n            zIndex: 0,\n          },\n        },\n      },\n      className,\n    ],\n    content: [\n      'ms-Tooltip-content',\n      fonts.small,\n      {\n        position: 'relative',\n        zIndex: 1,\n        color: semanticColors.menuItemText,\n        wordWrap: 'break-word',\n        overflowWrap: 'break-word',\n        overflow: 'hidden',\n      },\n    ],\n    subText: [\n      'ms-Tooltip-subtext',\n      {\n        // Using inherit here to avoid unintentional global overrides of the <p> tag.\n        fontSize: 'inherit',\n        fontWeight: 'inherit',\n        color: 'inherit',\n        margin: 0,\n      },\n    ],\n  };\n};\n", "import * as React from 'react';\nimport { styled } from '../../Utilities';\nimport { TooltipBase } from './Tooltip.base';\nimport { getStyles } from './Tooltip.styles';\nimport type { ITooltipProps, ITooltipStyleProps, ITooltipStyles } from './Tooltip.types';\n\nexport const Tooltip: React.FunctionComponent<ITooltipProps> = styled<\n  ITooltipProps,\n  ITooltipStyleProps,\n  ITooltipStyles\n>(TooltipBase, getStyles, undefined, {\n  scope: 'Tooltip',\n});\n", "import * as React from 'react';\nimport { TooltipBase } from './Tooltip.base';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport type { ICalloutProps } from '../../Callout';\nimport type { IRenderFunction, IRefObject, IStyleFunctionOrObject } from '../../Utilities';\nimport type { IStyle, ITheme } from '../../Styling';\n\n/**\n * {@docCategory Tooltip}\n */\nexport interface ITooltip {}\n\n/**\n * {@docCategory Tooltip}\n */\nexport interface ITooltipProps extends React.HTMLAttributes<HTMLDivElement | TooltipBase> {\n  /**\n   * Optional callback to access the ITooltip interface. Use this instead of ref for accessing\n   * the public methods and properties of the component.\n   */\n  componentRef?: IRefObject<ITooltip>;\n\n  /**\n   * Properties to pass through for Callout.\n   * @defaultvalue `{ isBeakVisible: true, beakWidth: 16, gapSpace: 0, setInitialFocus: true, doNotLayer: false }`\n   */\n  calloutProps?: ICalloutProps;\n\n  /**\n   * Content to be passed to the tooltip\n   */\n  content?: string | JSX.Element | JSX.Element[];\n\n  /**\n   * Render function to populate tooltip content.\n   */\n  onRenderContent?: IRenderFunction<ITooltipProps>;\n\n  /**\n   * Length of delay. Set to `TooltipDelay.zero` if you do not want a delay.\n   * @defaultvalue TooltipDelay.medium\n   */\n  delay?: TooltipDelay;\n\n  /**\n   * Max width of tooltip\n   * @defaultvalue 364px\n   */\n  maxWidth?: string | null;\n\n  /**\n   * Element to anchor the Tooltip to.\n   */\n  targetElement?: HTMLElement;\n\n  /**\n   * How the tooltip should be anchored to its `targetElement`.\n   * @defaultvalue DirectionalHint.topCenter\n   */\n  directionalHint?: DirectionalHint;\n\n  /**\n   * How the element should be positioned in RTL layouts.\n   * If not specified, a mirror of `directionalHint` will be used instead\n   */\n  directionalHintForRTL?: DirectionalHint;\n\n  /**\n   * Theme provided by higher-order component.\n   */\n  theme?: ITheme;\n\n  /**\n   * Call to provide customized styling that will layer on top of the variant rules.\n   */\n  styles?: IStyleFunctionOrObject<ITooltipStyleProps, ITooltipStyles>;\n}\n\n/**\n * {@docCategory Tooltip}\n */\nexport enum TooltipDelay {\n  zero = 0,\n  /** 300 ms delay before showing the tooltip */\n  medium = 1,\n  /** 500 ms delay before showing the tooltip */\n  long = 2,\n}\n\n/**\n * {@docCategory Tooltip}\n */\nexport interface ITooltipStyleProps {\n  theme: ITheme;\n\n  className?: string;\n\n  /**\n   * Delay before tooltip appears.\n   * @deprecated Delay logic moved to TooltipHost vs relying on animation delay.\n   */\n  delay?: TooltipDelay;\n\n  /**\n   * Maximum width of tooltip.\n   */\n  maxWidth?: string;\n\n  /**\n   * The gap between the Callout and the target\n   * @defaultvalue 0\n   */\n  gapSpace?: number;\n\n  /**\n   * The width of the Callout's beak\n   * @defaultvalue 16\n   */\n  beakWidth?: number;\n}\n\n/**\n * {@docCategory Tooltip}\n */\nexport interface ITooltipStyles {\n  /**\n   * Style for the root element.\n   */\n  root: IStyle;\n\n  /**\n   * Style for the content element.\n   */\n  content: IStyle;\n\n  /**\n   * Style for the subtext element.\n   */\n  subText: IStyle;\n}\n", "import * as React from 'react';\nimport { TooltipHostBase } from './TooltipHost.base';\nimport { TooltipDelay } from './Tooltip.types';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport type { ITooltipProps } from './Tooltip.types';\nimport type { ICalloutProps } from '../../Callout';\nimport type { IRefObject, IStyleFunctionOrObject } from '../../Utilities';\nimport type { IStyle, ITheme } from '../../Styling';\n\n/**\n * {@docCategory Tooltip}\n */\nexport interface ITooltipHost {\n  /**\n   * Shows the tooltip.\n   */\n  show: () => void;\n\n  /**\n   * Dismisses the tooltip.\n   */\n  dismiss: () => void;\n}\n\n/**\n * {@docCategory Tooltip}\n */\nexport enum TooltipOverflowMode {\n  /** Only show tooltip if parent DOM element is overflowing */\n  Parent,\n\n  /**\n   * Only show tooltip if tooltip host's content is overflowing.\n   * Note that this does not check the children for overflow, only the TooltipHost root.\n   */\n  Self,\n}\n\n/**\n * TooltipHost props. Note that native props (such as `id`, `className`, and `aria-` props) are\n * passed through to the Tooltip itself, rather than being used on the host element.\n * {@docCategory Tooltip}\n */\nexport interface ITooltipHostProps extends React.HTMLAttributes<HTMLDivElement | TooltipHostBase> {\n  /**\n   * Optional callback to access the ITooltipHost interface. Use this instead of ref for accessing\n   * the public methods and properties of the component.\n   */\n  componentRef?: IRefObject<ITooltipHost>;\n\n  /**\n   * Additional properties to pass through for Callout.\n   */\n  calloutProps?: ICalloutProps;\n\n  /**\n   * Number of milliseconds to delay closing the tooltip, so that the user has time to hover over\n   * the tooltip and interact with it. Hovering over the tooltip will count as hovering over the\n   * host, so that the tooltip will stay open if the user is actively interacting with it.\n   */\n  closeDelay?: number;\n\n  /**\n   * Content to display in the Tooltip.\n   */\n  content?: string | JSX.Element | JSX.Element[];\n\n  /**\n   * Length of delay before showing the tooltip on hover.\n   * @defaultvalue TooltipDelay.medium\n   */\n  delay?: TooltipDelay;\n\n  /**\n   * How the tooltip should be anchored to its `targetElement`.\n   * @defaultvalue DirectionalHint.topCenter\n   */\n  directionalHint?: DirectionalHint;\n\n  /**\n   * How the element should be positioned in RTL layouts.\n   * If not specified, a mirror of `directionalHint` will be used.\n   */\n  directionalHintForRTL?: DirectionalHint;\n\n  /**\n   * Class name to apply to tooltip host.\n   */\n  hostClassName?: string;\n\n  /**\n   * Class name to apply to the *tooltip itself*, not the host.\n   * To apply a class to the host, use `hostClassName` or `styles.root`.\n   */\n  className?: string;\n\n  /**\n   * If this is unset (the default), the tooltip is always shown even if there's no overflow.\n   *\n   * If set, only show the tooltip if the specified element (`Self` or `Parent`) has overflow.\n   * When set to `Parent`, the parent element is also used as the tooltip's target element.\n   *\n   * Note that even with `Self` mode, the TooltipHost *does not* check whether any children have overflow.\n   */\n  overflowMode?: TooltipOverflowMode;\n\n  /**\n   * Whether or not to mark the TooltipHost root element as described by the tooltip.\n   * Since this applies aria-describedby to a generic <div>, the description will not be\n   * read by screen readers. Instead, the caller should pass an `id` to the TooltipHost\n   * (to be passed through to the Tooltip) and mark the appropriate element as `aria-describedby`\n   * with the `id`.\n   * @defaultvalue true\n   * @deprecated use aria-describedby on the appropriate element instead\n   */\n  setAriaDescribedBy?: boolean;\n\n  /**\n   * Additional properties to pass through for Tooltip.\n   */\n  tooltipProps?: ITooltipProps;\n\n  /**\n   * Optional ID to pass through to the tooltip (not used on the host itself).\n   * Auto-generated if not provided.\n   */\n  id?: string;\n\n  /**\n   * Call to provide customized styling that will layer on top of the variant rules.\n   */\n  styles?: IStyleFunctionOrObject<ITooltipHostStyleProps, ITooltipHostStyles>;\n\n  /**\n   * Theme provided by higher-order component.\n   */\n  theme?: ITheme;\n\n  /**\n   * Notifies when tooltip becomes visible or hidden, whatever the trigger was.\n   */\n  onTooltipToggle?(isTooltipVisible: boolean): void;\n}\n\n/**\n * {@docCategory Tooltip}\n */\nexport interface ITooltipHostStyleProps {\n  theme: ITheme;\n  className?: string;\n}\n\n/**\n * {@docCategory Tooltip}\n */\nexport interface ITooltipHostStyles {\n  /**\n   * Style for the host wrapper element.\n   */\n  root: IStyle;\n}\n", "import * as React from 'react';\nimport { hiddenContentStyle } from '../../Styling';\nimport {\n  initializeComponentRef,\n  Async,\n  divProperties,\n  getNativeProps,\n  getId,\n  assign,\n  hasOverflow,\n  portalContainsElement,\n  classNamesFunction,\n  KeyCodes,\n} from '../../Utilities';\nimport { TooltipOverflowMode } from './TooltipHost.types';\nimport { Tooltip } from './Tooltip';\nimport { TooltipDelay } from './Tooltip.types';\nimport type { ITooltipHostProps, ITooltipHostStyles, ITooltipHostStyleProps, ITooltipHost } from './TooltipHost.types';\n\nexport interface ITooltipHostState {\n  /** @deprecated No longer used internally */\n  isAriaPlaceholderRendered: boolean;\n  isTooltipVisible: boolean;\n}\n\nconst getClassNames = classNamesFunction<ITooltipHostStyleProps, ITooltipHostStyles>();\n\nexport class TooltipHostBase extends React.Component<ITooltipHostProps, ITooltipHostState> implements ITooltipHost {\n  public static defaultProps = {\n    delay: TooltipDelay.medium,\n  };\n\n  private static _currentVisibleTooltip: ITooltipHost | undefined;\n\n  // The wrapping div that gets the hover events\n  private _tooltipHost = React.createRef<HTMLDivElement>();\n\n  private _classNames: { [key in keyof ITooltipHostStyles]: string };\n  private _async: Async;\n  private _dismissTimerId: number;\n  private _openTimerId: number;\n  private _defaultTooltipId = getId('tooltip');\n  private _ignoreNextFocusEvent: boolean;\n\n  // Constructor\n  constructor(props: ITooltipHostProps) {\n    super(props);\n\n    initializeComponentRef(this);\n\n    this.state = {\n      isAriaPlaceholderRendered: false, // eslint-disable-line react/no-unused-state\n      isTooltipVisible: false,\n    };\n\n    this._async = new Async(this);\n  }\n\n  // Render\n  public render(): JSX.Element {\n    const {\n      calloutProps,\n      children,\n      content,\n      directionalHint,\n      directionalHintForRTL,\n      hostClassName: className,\n      id,\n      // eslint-disable-next-line deprecation/deprecation\n      setAriaDescribedBy = true,\n      tooltipProps,\n      styles,\n      theme,\n    } = this.props;\n\n    this._classNames = getClassNames(styles!, {\n      theme: theme!,\n      className,\n    });\n\n    const { isTooltipVisible } = this.state;\n    const tooltipId = id || this._defaultTooltipId;\n    const tooltipContent = tooltipProps?.onRenderContent ? tooltipProps.onRenderContent() : content;\n    const showTooltip = isTooltipVisible && !!tooltipContent;\n    const ariaDescribedBy = setAriaDescribedBy && isTooltipVisible && !!tooltipContent ? tooltipId : undefined;\n\n    return (\n      <div\n        className={this._classNames.root}\n        ref={this._tooltipHost}\n        {...{ onFocusCapture: this._onTooltipFocus }}\n        {...{ onBlurCapture: this._onTooltipBlur }}\n        onMouseEnter={this._onTooltipMouseEnter}\n        onMouseLeave={this._onTooltipMouseLeave}\n        onKeyDown={this._onTooltipKeyDown}\n        role=\"none\"\n        // WARNING: aria-describedby on this node provides no value, since it isn't allowed generic elements\n        aria-describedby={ariaDescribedBy}\n      >\n        {children}\n        {showTooltip && (\n          <Tooltip\n            id={`${tooltipId}--tooltip`}\n            content={content}\n            targetElement={this._getTargetElement()}\n            directionalHint={directionalHint}\n            directionalHintForRTL={directionalHintForRTL}\n            calloutProps={assign({}, calloutProps, {\n              onDismiss: this._hideTooltip,\n              onMouseEnter: this._onTooltipMouseEnter,\n              onMouseLeave: this._onTooltipMouseLeave,\n            })}\n            onMouseEnter={this._onTooltipMouseEnter}\n            onMouseLeave={this._onTooltipMouseLeave}\n            {...getNativeProps(this.props, divProperties, ['id'])} // Make sure we use the id above\n            {...tooltipProps}\n          />\n        )}\n        <div hidden={true} id={tooltipId} style={hiddenContentStyle as React.CSSProperties}>\n          {tooltipContent}\n        </div>\n      </div>\n    );\n  }\n\n  public componentWillUnmount(): void {\n    if (TooltipHostBase._currentVisibleTooltip && TooltipHostBase._currentVisibleTooltip === this) {\n      TooltipHostBase._currentVisibleTooltip = undefined;\n    }\n\n    this._async.dispose();\n  }\n\n  public show = (): void => {\n    this._toggleTooltip(true);\n  };\n\n  public dismiss = (): void => {\n    this._hideTooltip();\n  };\n\n  private _getTargetElement = (): HTMLElement | undefined => {\n    if (!this._tooltipHost.current) {\n      return undefined;\n    }\n\n    const { overflowMode } = this.props;\n\n    // Select target element based on overflow mode. For parent mode, you want to position the tooltip relative\n    // to the parent element, otherwise it might look off.\n    if (overflowMode !== undefined) {\n      switch (overflowMode) {\n        case TooltipOverflowMode.Parent:\n          return this._tooltipHost.current.parentElement!;\n\n        case TooltipOverflowMode.Self:\n          return this._tooltipHost.current;\n      }\n    }\n\n    return this._tooltipHost.current;\n  };\n\n  private _onTooltipFocus = (ev: React.FocusEvent<HTMLElement>) => {\n    if (this._ignoreNextFocusEvent) {\n      this._ignoreNextFocusEvent = false;\n      return;\n    }\n\n    this._onTooltipMouseEnter(ev);\n  };\n\n  private _onTooltipBlur = (ev: React.FocusEvent<HTMLElement>) => {\n    // The focused element gets a blur event when the document loses focus\n    // (e.g. switching tabs in the browser), but we don't want to show the\n    // tooltip again when the document gets focus back. Handle this case by\n    // checking if the blurred element is still the document's activeElement,\n    // and ignoring when it next gets focus back.\n    // See https://github.com/microsoft/fluentui/issues/13541\n    this._ignoreNextFocusEvent = document?.activeElement === ev.target;\n\n    this._hideTooltip();\n  };\n\n  // Show Tooltip\n  private _onTooltipMouseEnter = (ev: any): void => {\n    const { overflowMode, delay } = this.props;\n\n    if (TooltipHostBase._currentVisibleTooltip && TooltipHostBase._currentVisibleTooltip !== this) {\n      TooltipHostBase._currentVisibleTooltip.dismiss();\n    }\n    TooltipHostBase._currentVisibleTooltip = this;\n\n    if (overflowMode !== undefined) {\n      const overflowElement = this._getTargetElement();\n      if (overflowElement && !hasOverflow(overflowElement)) {\n        return;\n      }\n    }\n\n    if (ev.target && portalContainsElement(ev.target as HTMLElement, this._getTargetElement())) {\n      // Do not show tooltip when target is inside a portal relative to TooltipHost.\n      return;\n    }\n\n    this._clearDismissTimer();\n    this._clearOpenTimer();\n\n    if (delay !== TooltipDelay.zero) {\n      const delayTime = this._getDelayTime(delay!); // non-null assertion because we set it in `defaultProps`\n\n      this._openTimerId = this._async.setTimeout(() => {\n        this._toggleTooltip(true);\n      }, delayTime);\n    } else {\n      this._toggleTooltip(true);\n    }\n  };\n\n  // Hide Tooltip\n  private _onTooltipMouseLeave = (ev: any): void => {\n    const { closeDelay } = this.props;\n\n    this._clearDismissTimer();\n    this._clearOpenTimer();\n\n    if (closeDelay) {\n      this._dismissTimerId = this._async.setTimeout(() => {\n        this._toggleTooltip(false);\n      }, closeDelay);\n    } else {\n      this._toggleTooltip(false);\n    }\n\n    if (TooltipHostBase._currentVisibleTooltip === this) {\n      TooltipHostBase._currentVisibleTooltip = undefined;\n    }\n  };\n\n  private _onTooltipKeyDown = (ev: React.KeyboardEvent<HTMLElement>): void => {\n    // eslint-disable-next-line deprecation/deprecation\n    if ((ev.which === KeyCodes.escape || ev.ctrlKey) && this.state.isTooltipVisible) {\n      this._hideTooltip();\n      ev.stopPropagation();\n    }\n  };\n\n  private _clearDismissTimer = (): void => {\n    this._async.clearTimeout(this._dismissTimerId);\n  };\n\n  private _clearOpenTimer = (): void => {\n    this._async.clearTimeout(this._openTimerId);\n  };\n\n  // Hide Tooltip\n  private _hideTooltip = (): void => {\n    this._clearOpenTimer();\n    this._clearDismissTimer();\n    this._toggleTooltip(false);\n  };\n\n  private _toggleTooltip = (isTooltipVisible: boolean): void => {\n    if (this.state.isTooltipVisible !== isTooltipVisible) {\n      this.setState(\n        { isTooltipVisible },\n        () => this.props.onTooltipToggle && this.props.onTooltipToggle(isTooltipVisible),\n      );\n    }\n  };\n\n  private _getDelayTime = (delay: TooltipDelay): number => {\n    switch (delay) {\n      case TooltipDelay.medium:\n        return 300;\n      case TooltipDelay.long:\n        return 500;\n      default:\n        return 0;\n    }\n  };\n}\n", "import { getGlobalClassNames } from '../../Styling';\nimport type { ITooltipHostStyleProps, ITooltipHostStyles } from './TooltipHost.types';\n\nconst GlobalClassNames = {\n  root: 'ms-TooltipHost',\n  ariaPlaceholder: 'ms-TooltipHost-aria-placeholder',\n};\n\nexport const getStyles = (props: ITooltipHostStyleProps): ITooltipHostStyles => {\n  const { className, theme } = props;\n  const classNames = getGlobalClassNames(GlobalClassNames, theme);\n\n  return {\n    root: [\n      classNames.root,\n      {\n        display: 'inline',\n      },\n      className,\n    ],\n  };\n};\n", "import * as React from 'react';\nimport { styled } from '../../Utilities';\nimport { TooltipHostBase } from './TooltipHost.base';\nimport { getStyles } from './TooltipHost.styles';\nimport type { ITooltipHostProps, ITooltipHostStyleProps, ITooltipHostStyles } from './TooltipHost.types';\n\nexport const TooltipHost: React.FunctionComponent<ITooltipHostProps> = styled<\n  ITooltipHostProps,\n  ITooltipHostStyleProps,\n  ITooltipHostStyles\n>(TooltipHostBase, getStyles, undefined, {\n  scope: 'TooltipHost',\n});\n"],
  "mappings": "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",
  "names": ["TooltipBase", "TooltipDelay", "TooltipOverflowMode", "React", "getClassNames", "TooltipHostBase", "getStyles", "getStyles"]
}
