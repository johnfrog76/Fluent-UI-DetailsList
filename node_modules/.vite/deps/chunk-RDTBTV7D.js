import {
  useMergedRefs
} from "./chunk-OFNEIFUY.js";
import {
  AnimationClassNames,
  KeyCodes,
  __assign,
  __extends,
  classNamesFunction,
  createMergedRef,
  css,
  elementContains,
  findScrollableParent,
  getDocument,
  getElementIndexPath,
  getFocusableByIndexPath,
  getGlobalClassNames,
  getIcon,
  getId,
  getNativeProps,
  getNextElement,
  getParent,
  getPreviousElement,
  getRTL,
  getTheme,
  getWindow,
  hoistMethods,
  htmlElementProperties,
  imgProperties,
  initializeComponentRef,
  isElementFocusSubZone,
  isElementFocusZone,
  isElementTabbable,
  memoizeFunction,
  mergeStyleSets,
  mergeStyles,
  portalContainsElement,
  setVersion,
  shouldWrapFocus,
  styled,
  unhoistMethods,
  useIsomorphicLayoutEffect,
  warnDeprecations
} from "./chunk-KWCDGRXS.js";
import {
  __toESM,
  require_react
} from "./chunk-PC5MGJGW.js";

// node_modules/@fluentui/react/lib/components/Icon/Icon.types.js
var IconType;
(function(IconType2) {
  IconType2[IconType2["default"] = 0] = "default";
  IconType2[IconType2["image"] = 1] = "image";
  IconType2[IconType2["Default"] = 1e5] = "Default";
  IconType2[IconType2["Image"] = 100001] = "Image";
})(IconType || (IconType = {}));

// node_modules/@fluentui/react/lib/components/Image/Image.types.js
var ImageFit;
(function(ImageFit2) {
  ImageFit2[ImageFit2["center"] = 0] = "center";
  ImageFit2[ImageFit2["contain"] = 1] = "contain";
  ImageFit2[ImageFit2["cover"] = 2] = "cover";
  ImageFit2[ImageFit2["none"] = 3] = "none";
  ImageFit2[ImageFit2["centerCover"] = 4] = "centerCover";
  ImageFit2[ImageFit2["centerContain"] = 5] = "centerContain";
})(ImageFit || (ImageFit = {}));
var ImageCoverStyle;
(function(ImageCoverStyle2) {
  ImageCoverStyle2[ImageCoverStyle2["landscape"] = 0] = "landscape";
  ImageCoverStyle2[ImageCoverStyle2["portrait"] = 1] = "portrait";
})(ImageCoverStyle || (ImageCoverStyle = {}));
var ImageLoadState;
(function(ImageLoadState2) {
  ImageLoadState2[ImageLoadState2["notLoaded"] = 0] = "notLoaded";
  ImageLoadState2[ImageLoadState2["loaded"] = 1] = "loaded";
  ImageLoadState2[ImageLoadState2["error"] = 2] = "error";
  ImageLoadState2[ImageLoadState2["errorLoaded"] = 3] = "errorLoaded";
})(ImageLoadState || (ImageLoadState = {}));

// node_modules/@fluentui/react/lib/components/Image/Image.base.js
var React = __toESM(require_react());
var getClassNames = classNamesFunction();
var SVG_REGEX = /\.svg$/i;
var KEY_PREFIX = "fabricImage";
function useLoadState(props, imageElement) {
  var onLoadingStateChange = props.onLoadingStateChange, onLoad = props.onLoad, onError = props.onError, src = props.src;
  var _a = React.useState(ImageLoadState.notLoaded), loadState = _a[0], setLoadState = _a[1];
  useIsomorphicLayoutEffect(function() {
    setLoadState(ImageLoadState.notLoaded);
  }, [src]);
  React.useEffect(function() {
    if (loadState === ImageLoadState.notLoaded) {
      var isLoaded = imageElement.current ? src && imageElement.current.naturalWidth > 0 && imageElement.current.naturalHeight > 0 || imageElement.current.complete && SVG_REGEX.test(src) : false;
      if (isLoaded) {
        setLoadState(ImageLoadState.loaded);
      }
    }
  });
  React.useEffect(function() {
    onLoadingStateChange === null || onLoadingStateChange === void 0 ? void 0 : onLoadingStateChange(loadState);
  }, [loadState]);
  var onImageLoaded = React.useCallback(function(ev) {
    onLoad === null || onLoad === void 0 ? void 0 : onLoad(ev);
    if (src) {
      setLoadState(ImageLoadState.loaded);
    }
  }, [src, onLoad]);
  var onImageError = React.useCallback(function(ev) {
    onError === null || onError === void 0 ? void 0 : onError(ev);
    setLoadState(ImageLoadState.error);
  }, [onError]);
  return [loadState, onImageLoaded, onImageError];
}
var ImageBase = React.forwardRef(function(props, forwardedRef) {
  var frameElement = React.useRef();
  var imageElement = React.useRef();
  var _a = useLoadState(props, imageElement), loadState = _a[0], onImageLoaded = _a[1], onImageError = _a[2];
  var imageProps = getNativeProps(props, imgProperties, [
    "width",
    "height"
  ]);
  var src = props.src, alt = props.alt, width = props.width, height = props.height, _b = props.shouldFadeIn, shouldFadeIn = _b === void 0 ? true : _b, shouldStartVisible = props.shouldStartVisible, className = props.className, imageFit = props.imageFit, role = props.role, maximizeFrame = props.maximizeFrame, styles = props.styles, theme = props.theme, loading = props.loading;
  var coverStyle = useCoverStyle(props, loadState, imageElement, frameElement);
  var classNames2 = getClassNames(styles, {
    theme,
    className,
    width,
    height,
    maximizeFrame,
    shouldFadeIn,
    shouldStartVisible,
    isLoaded: loadState === ImageLoadState.loaded || loadState === ImageLoadState.notLoaded && props.shouldStartVisible,
    isLandscape: coverStyle === ImageCoverStyle.landscape,
    isCenter: imageFit === ImageFit.center,
    isCenterContain: imageFit === ImageFit.centerContain,
    isCenterCover: imageFit === ImageFit.centerCover,
    isContain: imageFit === ImageFit.contain,
    isCover: imageFit === ImageFit.cover,
    isNone: imageFit === ImageFit.none,
    isError: loadState === ImageLoadState.error,
    isNotImageFit: imageFit === void 0
  });
  return React.createElement(
    "div",
    { className: classNames2.root, style: { width, height }, ref: frameElement },
    React.createElement("img", __assign({}, imageProps, { onLoad: onImageLoaded, onError: onImageError, key: KEY_PREFIX + props.src || "", className: classNames2.image, ref: useMergedRefs(imageElement, forwardedRef), src, alt, role, loading }))
  );
});
ImageBase.displayName = "ImageBase";
function useCoverStyle(props, loadState, imageElement, frameElement) {
  var previousLoadState = React.useRef(loadState);
  var coverStyle = React.useRef();
  if (coverStyle === void 0 || previousLoadState.current === ImageLoadState.notLoaded && loadState === ImageLoadState.loaded) {
    coverStyle.current = computeCoverStyle(props, loadState, imageElement, frameElement);
  }
  previousLoadState.current = loadState;
  return coverStyle.current;
}
function computeCoverStyle(props, loadState, imageElement, frameElement) {
  var imageFit = props.imageFit, width = props.width, height = props.height;
  if (props.coverStyle !== void 0) {
    return props.coverStyle;
  } else if (loadState === ImageLoadState.loaded && (imageFit === ImageFit.cover || imageFit === ImageFit.contain || imageFit === ImageFit.centerContain || imageFit === ImageFit.centerCover) && imageElement.current && frameElement.current) {
    var desiredRatio = void 0;
    if (typeof width === "number" && typeof height === "number" && imageFit !== ImageFit.centerContain && imageFit !== ImageFit.centerCover) {
      desiredRatio = width / height;
    } else {
      desiredRatio = frameElement.current.clientWidth / frameElement.current.clientHeight;
    }
    var naturalRatio = imageElement.current.naturalWidth / imageElement.current.naturalHeight;
    if (naturalRatio > desiredRatio) {
      return ImageCoverStyle.landscape;
    }
  }
  return ImageCoverStyle.portrait;
}

// node_modules/@fluentui/react/lib/components/Image/Image.styles.js
var GlobalClassNames = {
  root: "ms-Image",
  rootMaximizeFrame: "ms-Image--maximizeFrame",
  image: "ms-Image-image",
  imageCenter: "ms-Image-image--center",
  imageContain: "ms-Image-image--contain",
  imageCover: "ms-Image-image--cover",
  imageCenterContain: "ms-Image-image--centerContain",
  imageCenterCover: "ms-Image-image--centerCover",
  imageNone: "ms-Image-image--none",
  imageLandscape: "ms-Image-image--landscape",
  imagePortrait: "ms-Image-image--portrait"
};
var getStyles = function(props) {
  var className = props.className, width = props.width, height = props.height, maximizeFrame = props.maximizeFrame, isLoaded = props.isLoaded, shouldFadeIn = props.shouldFadeIn, shouldStartVisible = props.shouldStartVisible, isLandscape = props.isLandscape, isCenter = props.isCenter, isContain = props.isContain, isCover = props.isCover, isCenterContain = props.isCenterContain, isCenterCover = props.isCenterCover, isNone = props.isNone, isError = props.isError, isNotImageFit = props.isNotImageFit, theme = props.theme;
  var classNames2 = getGlobalClassNames(GlobalClassNames, theme);
  var ImageFitStyles = {
    position: "absolute",
    left: "50% /* @noflip */",
    top: "50%",
    transform: "translate(-50%,-50%)"
  };
  var window2 = getWindow();
  var supportsObjectFit = window2 !== void 0 && window2.navigator.msMaxTouchPoints === void 0;
  var fallbackObjectFitStyles = isContain && isLandscape || isCover && !isLandscape ? { width: "100%", height: "auto" } : { width: "auto", height: "100%" };
  return {
    root: [
      classNames2.root,
      theme.fonts.medium,
      {
        overflow: "hidden"
      },
      maximizeFrame && [
        classNames2.rootMaximizeFrame,
        {
          height: "100%",
          width: "100%"
        }
      ],
      isLoaded && shouldFadeIn && !shouldStartVisible && AnimationClassNames.fadeIn400,
      (isCenter || isContain || isCover || isCenterContain || isCenterCover) && {
        position: "relative"
      },
      className
    ],
    image: [
      classNames2.image,
      {
        display: "block",
        opacity: 0
      },
      isLoaded && [
        "is-loaded",
        {
          opacity: 1
        }
      ],
      isCenter && [classNames2.imageCenter, ImageFitStyles],
      isContain && [
        classNames2.imageContain,
        supportsObjectFit && {
          width: "100%",
          height: "100%",
          objectFit: "contain"
        },
        !supportsObjectFit && fallbackObjectFitStyles,
        !supportsObjectFit && ImageFitStyles
      ],
      isCover && [
        classNames2.imageCover,
        supportsObjectFit && {
          width: "100%",
          height: "100%",
          objectFit: "cover"
        },
        !supportsObjectFit && fallbackObjectFitStyles,
        !supportsObjectFit && ImageFitStyles
      ],
      isCenterContain && [
        classNames2.imageCenterContain,
        isLandscape && {
          maxWidth: "100%"
        },
        !isLandscape && {
          maxHeight: "100%"
        },
        ImageFitStyles
      ],
      isCenterCover && [
        classNames2.imageCenterCover,
        isLandscape && {
          maxHeight: "100%"
        },
        !isLandscape && {
          maxWidth: "100%"
        },
        ImageFitStyles
      ],
      isNone && [
        classNames2.imageNone,
        {
          width: "auto",
          height: "auto"
        }
      ],
      isNotImageFit && [
        !!width && !height && {
          height: "auto",
          width: "100%"
        },
        !width && !!height && {
          height: "100%",
          width: "auto"
        },
        !!width && !!height && {
          height: "100%",
          width: "100%"
        }
      ],
      isLandscape && classNames2.imageLandscape,
      !isLandscape && classNames2.imagePortrait,
      !isLoaded && "is-notLoaded",
      shouldFadeIn && "is-fadeIn",
      isError && "is-error"
    ]
  };
};

// node_modules/@fluentui/react/lib/components/Image/Image.js
var Image = styled(ImageBase, getStyles, void 0, {
  scope: "Image"
}, true);
Image.displayName = "Image";

// node_modules/@fluentui/react/lib/components/Icon/FontIcon.js
var React2 = __toESM(require_react());

// node_modules/@fluentui/react/lib/components/Icon/Icon.styles.js
var classNames = mergeStyleSets({
  root: {
    display: "inline-block"
  },
  placeholder: [
    "ms-Icon-placeHolder",
    {
      width: "1em"
    }
  ],
  image: [
    "ms-Icon-imageContainer",
    {
      overflow: "hidden"
    }
  ]
});
var MS_ICON = "ms-Icon";
var getStyles2 = function(props) {
  var className = props.className, iconClassName = props.iconClassName, isPlaceholder = props.isPlaceholder, isImage = props.isImage, styles = props.styles;
  return {
    root: [
      isPlaceholder && classNames.placeholder,
      classNames.root,
      isImage && classNames.image,
      iconClassName,
      className,
      styles && styles.root,
      styles && styles.imageContainer
    ]
  };
};

// node_modules/@fluentui/react/lib/components/Icon/FontIcon.js
var getIconContent = memoizeFunction(function(iconName) {
  var _a = getIcon(iconName) || {
    subset: {},
    code: void 0
  }, code = _a.code, subset = _a.subset;
  if (!code) {
    return null;
  }
  return {
    children: code,
    iconClassName: subset.className,
    fontFamily: subset.fontFace && subset.fontFace.fontFamily,
    mergeImageProps: subset.mergeImageProps
  };
}, void 0, true);
var FontIcon = function(props) {
  var iconName = props.iconName, className = props.className, _a = props.style, style = _a === void 0 ? {} : _a;
  var iconContent = getIconContent(iconName) || {};
  var iconClassName = iconContent.iconClassName, children = iconContent.children, fontFamily = iconContent.fontFamily, mergeImageProps = iconContent.mergeImageProps;
  var nativeProps = getNativeProps(props, htmlElementProperties);
  var accessibleName = props["aria-label"] || props.title;
  var containerProps = props["aria-label"] || props["aria-labelledby"] || props.title ? {
    role: mergeImageProps ? void 0 : "img"
  } : {
    "aria-hidden": true
  };
  var finalChildren = children;
  if (mergeImageProps) {
    if (typeof children === "object" && typeof children.props === "object" && accessibleName) {
      finalChildren = React2.cloneElement(children, { alt: accessibleName });
    }
  }
  return React2.createElement("i", __assign({ "data-icon-name": iconName }, containerProps, nativeProps, mergeImageProps ? {
    title: void 0,
    "aria-label": void 0
  } : {}, {
    className: css(MS_ICON, classNames.root, iconClassName, !iconName && classNames.placeholder, className),
    style: __assign({ fontFamily }, style)
  }), finalChildren);
};
var getFontIcon = memoizeFunction(function(iconName, className, ariaLabel) {
  return FontIcon({ iconName, className, "aria-label": ariaLabel });
});

// node_modules/@fluentui/react/lib/components/Icon/Icon.base.js
var React3 = __toESM(require_react());
var getClassNames2 = classNamesFunction({
  cacheSize: 100
});
var IconBase = function(_super) {
  __extends(IconBase2, _super);
  function IconBase2(props) {
    var _this = _super.call(this, props) || this;
    _this._onImageLoadingStateChange = function(state) {
      if (_this.props.imageProps && _this.props.imageProps.onLoadingStateChange) {
        _this.props.imageProps.onLoadingStateChange(state);
      }
      if (state === ImageLoadState.error) {
        _this.setState({ imageLoadError: true });
      }
    };
    _this.state = {
      imageLoadError: false
    };
    return _this;
  }
  IconBase2.prototype.render = function() {
    var _a = this.props, children = _a.children, className = _a.className, styles = _a.styles, iconName = _a.iconName, imageErrorAs = _a.imageErrorAs, theme = _a.theme;
    var isPlaceholder = typeof iconName === "string" && iconName.length === 0;
    var isImage = !!this.props.imageProps || this.props.iconType === IconType.image || this.props.iconType === IconType.Image;
    var iconContent = getIconContent(iconName) || {};
    var iconClassName = iconContent.iconClassName, iconContentChildren = iconContent.children, mergeImageProps = iconContent.mergeImageProps;
    var classNames2 = getClassNames2(styles, {
      theme,
      className,
      iconClassName,
      isImage,
      isPlaceholder
    });
    var RootType = isImage ? "span" : "i";
    var nativeProps = getNativeProps(this.props, htmlElementProperties, [
      "aria-label"
    ]);
    var imageLoadError = this.state.imageLoadError;
    var imageProps = __assign(__assign({}, this.props.imageProps), { onLoadingStateChange: this._onImageLoadingStateChange });
    var ImageType = imageLoadError && imageErrorAs || Image;
    var ariaLabel = this.props["aria-label"] || this.props.ariaLabel;
    var accessibleName = imageProps.alt || ariaLabel || this.props.title;
    var hasName = !!(accessibleName || this.props["aria-labelledby"] || imageProps["aria-label"] || imageProps["aria-labelledby"]);
    var containerProps = hasName ? {
      role: isImage || mergeImageProps ? void 0 : "img",
      "aria-label": isImage || mergeImageProps ? void 0 : accessibleName
    } : {
      "aria-hidden": true
    };
    var finalIconContentChildren = iconContentChildren;
    if (mergeImageProps && iconContentChildren && typeof iconContentChildren === "object" && accessibleName) {
      finalIconContentChildren = React3.cloneElement(iconContentChildren, {
        alt: accessibleName
      });
    }
    return React3.createElement(RootType, __assign({ "data-icon-name": iconName }, containerProps, nativeProps, mergeImageProps ? {
      title: void 0,
      "aria-label": void 0
    } : {}, { className: classNames2.root }), isImage ? React3.createElement(ImageType, __assign({}, imageProps)) : children || finalIconContentChildren);
  };
  return IconBase2;
}(React3.Component);

// node_modules/@fluentui/react/lib/components/Icon/Icon.js
var Icon = styled(IconBase, getStyles2, void 0, {
  scope: "Icon"
}, true);
Icon.displayName = "Icon";

// node_modules/@fluentui/react/lib/components/Icon/ImageIcon.js
var React4 = __toESM(require_react());
var ImageIcon = function(props) {
  var className = props.className, imageProps = props.imageProps;
  var nativeProps = getNativeProps(props, htmlElementProperties, [
    "aria-label",
    "aria-labelledby",
    "title",
    "aria-describedby"
  ]);
  var altText = imageProps.alt || props["aria-label"];
  var hasName = altText || props["aria-labelledby"] || props.title || imageProps["aria-label"] || imageProps["aria-labelledby"] || imageProps.title;
  var imageNameProps = {
    "aria-labelledby": props["aria-labelledby"],
    "aria-describedby": props["aria-describedby"],
    title: props.title
  };
  var containerProps = hasName ? {} : {
    "aria-hidden": true
  };
  return React4.createElement(
    "div",
    __assign({}, containerProps, nativeProps, { className: css(MS_ICON, classNames.root, classNames.image, className) }),
    React4.createElement(Image, __assign({}, imageNameProps, imageProps, { alt: hasName ? altText : "" }))
  );
};

// node_modules/@fluentui/react-focus/lib/components/FocusZone/FocusZone.types.js
var FocusZoneTabbableElements = {
  none: 0,
  all: 1,
  inputOnly: 2
};
var FocusZoneDirection;
(function(FocusZoneDirection2) {
  FocusZoneDirection2[FocusZoneDirection2["vertical"] = 0] = "vertical";
  FocusZoneDirection2[FocusZoneDirection2["horizontal"] = 1] = "horizontal";
  FocusZoneDirection2[FocusZoneDirection2["bidirectional"] = 2] = "bidirectional";
  FocusZoneDirection2[FocusZoneDirection2["domOrder"] = 3] = "domOrder";
})(FocusZoneDirection || (FocusZoneDirection = {}));

// node_modules/@fluentui/react-focus/lib/components/FocusZone/FocusZone.js
var React5 = __toESM(require_react());
var IS_FOCUSABLE_ATTRIBUTE = "data-is-focusable";
var IS_ENTER_DISABLED_ATTRIBUTE = "data-disable-click-on-enter";
var FOCUSZONE_ID_ATTRIBUTE = "data-focuszone-id";
var TABINDEX = "tabindex";
var NO_VERTICAL_WRAP = "data-no-vertical-wrap";
var NO_HORIZONTAL_WRAP = "data-no-horizontal-wrap";
var LARGE_DISTANCE_FROM_CENTER = 999999999;
var LARGE_NEGATIVE_DISTANCE_FROM_CENTER = -999999999;
var focusZoneStyles;
var focusZoneClass = "ms-FocusZone";
function raiseClickFromKeyboardEvent(target, ev) {
  var event;
  if (typeof MouseEvent === "function") {
    event = new MouseEvent("click", {
      ctrlKey: ev === null || ev === void 0 ? void 0 : ev.ctrlKey,
      metaKey: ev === null || ev === void 0 ? void 0 : ev.metaKey,
      shiftKey: ev === null || ev === void 0 ? void 0 : ev.shiftKey,
      altKey: ev === null || ev === void 0 ? void 0 : ev.altKey,
      bubbles: ev === null || ev === void 0 ? void 0 : ev.bubbles,
      cancelable: ev === null || ev === void 0 ? void 0 : ev.cancelable
    });
  } else {
    event = document.createEvent("MouseEvents");
    event.initMouseEvent(
      "click",
      ev ? ev.bubbles : false,
      ev ? ev.cancelable : false,
      window,
      0,
      0,
      0,
      0,
      0,
      ev ? ev.ctrlKey : false,
      ev ? ev.altKey : false,
      ev ? ev.shiftKey : false,
      ev ? ev.metaKey : false,
      0,
      null
    );
  }
  target.dispatchEvent(event);
}
function getRootClass() {
  if (!focusZoneStyles) {
    focusZoneStyles = mergeStyles({
      selectors: {
        ":focus": {
          outline: "none"
        }
      }
    }, focusZoneClass);
  }
  return focusZoneStyles;
}
var _allInstances = {};
var _outerZones = /* @__PURE__ */ new Set();
var ALLOWED_INPUT_TYPES = ["text", "number", "password", "email", "tel", "url", "search", "textarea"];
var ALLOW_VIRTUAL_ELEMENTS = false;
var FocusZone = function(_super) {
  __extends(FocusZone2, _super);
  function FocusZone2(props) {
    var _a, _b, _c, _d;
    var _this = _super.call(this, props) || this;
    _this._root = React5.createRef();
    _this._mergedRef = createMergedRef();
    _this._onFocus = function(ev) {
      if (_this._portalContainsElement(ev.target)) {
        return;
      }
      var _a2 = _this.props, onActiveElementChanged = _a2.onActiveElementChanged, doNotAllowFocusEventToPropagate = _a2.doNotAllowFocusEventToPropagate, stopFocusPropagation = _a2.stopFocusPropagation, onFocusNotification = _a2.onFocusNotification, onFocus = _a2.onFocus, shouldFocusInnerElementWhenReceivedFocus = _a2.shouldFocusInnerElementWhenReceivedFocus, defaultTabbableElement = _a2.defaultTabbableElement;
      var isImmediateDescendant = _this._isImmediateDescendantOfZone(ev.target);
      var newActiveElement;
      if (isImmediateDescendant) {
        newActiveElement = ev.target;
      } else {
        var parentElement = ev.target;
        while (parentElement && parentElement !== _this._root.current) {
          if (isElementTabbable(parentElement) && _this._isImmediateDescendantOfZone(parentElement)) {
            newActiveElement = parentElement;
            break;
          }
          parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);
        }
      }
      if (shouldFocusInnerElementWhenReceivedFocus && ev.target === _this._root.current) {
        var maybeElementToFocus = defaultTabbableElement && typeof defaultTabbableElement === "function" && _this._root.current && defaultTabbableElement(_this._root.current);
        if (maybeElementToFocus && isElementTabbable(maybeElementToFocus)) {
          newActiveElement = maybeElementToFocus;
          maybeElementToFocus.focus();
        } else {
          _this.focus(true);
          if (_this._activeElement) {
            newActiveElement = null;
          }
        }
      }
      var initialElementFocused = !_this._activeElement;
      if (newActiveElement && newActiveElement !== _this._activeElement) {
        if (isImmediateDescendant || initialElementFocused) {
          _this._setFocusAlignment(newActiveElement, true, true);
        }
        _this._activeElement = newActiveElement;
        if (initialElementFocused) {
          _this._updateTabIndexes();
        }
      }
      if (onActiveElementChanged) {
        onActiveElementChanged(_this._activeElement, ev);
      }
      if (stopFocusPropagation || doNotAllowFocusEventToPropagate) {
        ev.stopPropagation();
      }
      if (onFocus) {
        onFocus(ev);
      } else if (onFocusNotification) {
        onFocusNotification();
      }
    };
    _this._onBlur = function() {
      _this._setParkedFocus(false);
    };
    _this._onMouseDown = function(ev) {
      if (_this._portalContainsElement(ev.target)) {
        return;
      }
      var disabled = _this.props.disabled;
      if (disabled) {
        return;
      }
      var target = ev.target;
      var path = [];
      while (target && target !== _this._root.current) {
        path.push(target);
        target = getParent(target, ALLOW_VIRTUAL_ELEMENTS);
      }
      while (path.length) {
        target = path.pop();
        if (target && isElementTabbable(target)) {
          _this._setActiveElement(target, true);
        }
        if (isElementFocusZone(target)) {
          break;
        }
      }
    };
    _this._onKeyDown = function(ev, theme) {
      if (_this._portalContainsElement(ev.target)) {
        return;
      }
      var _a2 = _this.props, direction = _a2.direction, disabled = _a2.disabled, isInnerZoneKeystroke = _a2.isInnerZoneKeystroke, pagingSupportDisabled = _a2.pagingSupportDisabled, shouldEnterInnerZone = _a2.shouldEnterInnerZone;
      if (disabled) {
        return;
      }
      if (_this.props.onKeyDown) {
        _this.props.onKeyDown(ev);
      }
      if (ev.isDefaultPrevented()) {
        return;
      }
      if (_this._getDocument().activeElement === _this._root.current && _this._isInnerZone) {
        return;
      }
      if ((shouldEnterInnerZone && shouldEnterInnerZone(ev) || isInnerZoneKeystroke && isInnerZoneKeystroke(ev)) && _this._isImmediateDescendantOfZone(ev.target)) {
        var innerZone = _this._getFirstInnerZone();
        if (innerZone) {
          if (!innerZone.focus(true)) {
            return;
          }
        } else if (isElementFocusSubZone(ev.target)) {
          if (!_this.focusElement(getNextElement(ev.target, ev.target.firstChild, true))) {
            return;
          }
        } else {
          return;
        }
      } else if (ev.altKey) {
        return;
      } else {
        switch (ev.which) {
          case KeyCodes.space:
            if (_this._shouldRaiseClicksOnSpace && _this._tryInvokeClickForFocusable(ev.target, ev)) {
              break;
            }
            return;
          case KeyCodes.left:
            if (direction !== FocusZoneDirection.vertical) {
              _this._preventDefaultWhenHandled(ev);
              if (_this._moveFocusLeft(theme)) {
                break;
              }
            }
            return;
          case KeyCodes.right:
            if (direction !== FocusZoneDirection.vertical) {
              _this._preventDefaultWhenHandled(ev);
              if (_this._moveFocusRight(theme)) {
                break;
              }
            }
            return;
          case KeyCodes.up:
            if (direction !== FocusZoneDirection.horizontal) {
              _this._preventDefaultWhenHandled(ev);
              if (_this._moveFocusUp()) {
                break;
              }
            }
            return;
          case KeyCodes.down:
            if (direction !== FocusZoneDirection.horizontal) {
              _this._preventDefaultWhenHandled(ev);
              if (_this._moveFocusDown()) {
                break;
              }
            }
            return;
          case KeyCodes.pageDown:
            if (!pagingSupportDisabled && _this._moveFocusPaging(true)) {
              break;
            }
            return;
          case KeyCodes.pageUp:
            if (!pagingSupportDisabled && _this._moveFocusPaging(false)) {
              break;
            }
            return;
          case KeyCodes.tab:
            if (_this.props.allowTabKey || _this.props.handleTabKey === FocusZoneTabbableElements.all || _this.props.handleTabKey === FocusZoneTabbableElements.inputOnly && _this._isElementInput(ev.target)) {
              var focusChanged = false;
              _this._processingTabKey = true;
              if (direction === FocusZoneDirection.vertical || !_this._shouldWrapFocus(_this._activeElement, NO_HORIZONTAL_WRAP)) {
                focusChanged = ev.shiftKey ? _this._moveFocusUp() : _this._moveFocusDown();
              } else {
                var tabWithDirection = getRTL(theme) ? !ev.shiftKey : ev.shiftKey;
                focusChanged = tabWithDirection ? _this._moveFocusLeft(theme) : _this._moveFocusRight(theme);
              }
              _this._processingTabKey = false;
              if (focusChanged) {
                break;
              } else if (_this.props.shouldResetActiveElementWhenTabFromZone) {
                _this._activeElement = null;
              }
            }
            return;
          case KeyCodes.home:
            if (_this._isContentEditableElement(ev.target) || _this._isElementInput(ev.target) && !_this._shouldInputLoseFocus(ev.target, false)) {
              return false;
            }
            var firstChild = _this._root.current && _this._root.current.firstChild;
            if (_this._root.current && firstChild && _this.focusElement(getNextElement(_this._root.current, firstChild, true))) {
              break;
            }
            return;
          case KeyCodes.end:
            if (_this._isContentEditableElement(ev.target) || _this._isElementInput(ev.target) && !_this._shouldInputLoseFocus(ev.target, true)) {
              return false;
            }
            var lastChild = _this._root.current && _this._root.current.lastChild;
            if (_this._root.current && _this.focusElement(getPreviousElement(_this._root.current, lastChild, true, true, true))) {
              break;
            }
            return;
          case KeyCodes.enter:
            if (_this._shouldRaiseClicksOnEnter && _this._tryInvokeClickForFocusable(ev.target, ev)) {
              break;
            }
            return;
          default:
            return;
        }
      }
      ev.preventDefault();
      ev.stopPropagation();
    };
    _this._getHorizontalDistanceFromCenter = function(isForward, activeRect, targetRect) {
      var leftAlignment = _this._focusAlignment.left || _this._focusAlignment.x || 0;
      var targetRectTop = Math.floor(targetRect.top);
      var activeRectBottom = Math.floor(activeRect.bottom);
      var targetRectBottom = Math.floor(targetRect.bottom);
      var activeRectTop = Math.floor(activeRect.top);
      var isValidCandidateOnpagingDown = isForward && targetRectTop > activeRectBottom;
      var isValidCandidateOnpagingUp = !isForward && targetRectBottom < activeRectTop;
      if (isValidCandidateOnpagingDown || isValidCandidateOnpagingUp) {
        if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {
          return 0;
        }
        return Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);
      }
      if (!_this._shouldWrapFocus(_this._activeElement, NO_VERTICAL_WRAP)) {
        return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
      }
      return LARGE_DISTANCE_FROM_CENTER;
    };
    initializeComponentRef(_this);
    if (true) {
      warnDeprecations("FocusZone", props, {
        rootProps: void 0,
        allowTabKey: "handleTabKey",
        elementType: "as",
        ariaDescribedBy: "aria-describedby",
        ariaLabelledBy: "aria-labelledby"
      });
    }
    _this._id = getId("FocusZone");
    _this._focusAlignment = {
      left: 0,
      top: 0
    };
    _this._processingTabKey = false;
    var shouldRaiseClicksFallback = (_b = (_a = props.shouldRaiseClicks) !== null && _a !== void 0 ? _a : FocusZone2.defaultProps.shouldRaiseClicks) !== null && _b !== void 0 ? _b : true;
    _this._shouldRaiseClicksOnEnter = (_c = props.shouldRaiseClicksOnEnter) !== null && _c !== void 0 ? _c : shouldRaiseClicksFallback;
    _this._shouldRaiseClicksOnSpace = (_d = props.shouldRaiseClicksOnSpace) !== null && _d !== void 0 ? _d : shouldRaiseClicksFallback;
    return _this;
  }
  FocusZone2.getOuterZones = function() {
    return _outerZones.size;
  };
  FocusZone2._onKeyDownCapture = function(ev) {
    if (ev.which === KeyCodes.tab) {
      _outerZones.forEach(function(zone) {
        return zone._updateTabIndexes();
      });
    }
  };
  FocusZone2.prototype.componentDidMount = function() {
    var root = this._root.current;
    _allInstances[this._id] = this;
    if (root) {
      var parentElement = getParent(root, ALLOW_VIRTUAL_ELEMENTS);
      while (parentElement && parentElement !== this._getDocument().body && parentElement.nodeType === 1) {
        if (isElementFocusZone(parentElement)) {
          this._isInnerZone = true;
          break;
        }
        parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);
      }
      if (!this._isInnerZone) {
        _outerZones.add(this);
        this._root.current && this._root.current.addEventListener("keydown", FocusZone2._onKeyDownCapture, true);
      }
      this._root.current && this._root.current.addEventListener("blur", this._onBlur, true);
      this._updateTabIndexes();
      if (this.props.defaultTabbableElement && typeof this.props.defaultTabbableElement === "string") {
        this._activeElement = this._getDocument().querySelector(this.props.defaultTabbableElement);
      } else if (this.props.defaultActiveElement) {
        this._activeElement = this._getDocument().querySelector(this.props.defaultActiveElement);
      }
      if (this.props.shouldFocusOnMount) {
        this.focus();
      }
    }
  };
  FocusZone2.prototype.componentDidUpdate = function() {
    var root = this._root.current;
    var doc = this._getDocument();
    if (this._activeElement && !elementContains(this._root.current, this._activeElement, ALLOW_VIRTUAL_ELEMENTS) || this._defaultFocusElement && !elementContains(this._root.current, this._defaultFocusElement, ALLOW_VIRTUAL_ELEMENTS)) {
      this._activeElement = null;
      this._defaultFocusElement = null;
      this._updateTabIndexes();
    }
    if (!this.props.preventFocusRestoration && doc && this._lastIndexPath && (doc.activeElement === doc.body || doc.activeElement === null || doc.activeElement === root)) {
      var elementToFocus = getFocusableByIndexPath(root, this._lastIndexPath);
      if (elementToFocus) {
        this._setActiveElement(elementToFocus, true);
        elementToFocus.focus();
        this._setParkedFocus(false);
      } else {
        this._setParkedFocus(true);
      }
    }
  };
  FocusZone2.prototype.componentWillUnmount = function() {
    delete _allInstances[this._id];
    if (!this._isInnerZone) {
      _outerZones.delete(this);
      this._root.current && this._root.current.removeEventListener("keydown", FocusZone2._onKeyDownCapture, true);
    }
    if (this._root.current) {
      this._root.current.removeEventListener("blur", this._onBlur, true);
    }
    this._activeElement = null;
    this._defaultFocusElement = null;
  };
  FocusZone2.prototype.render = function() {
    var _this = this;
    var _a = this.props, tag = _a.as, elementType = _a.elementType, rootProps = _a.rootProps, ariaDescribedBy = _a.ariaDescribedBy, ariaLabelledBy = _a.ariaLabelledBy, className = _a.className;
    var divProps = getNativeProps(this.props, htmlElementProperties);
    var Tag = tag || elementType || "div";
    this._evaluateFocusBeforeRender();
    var theme = getTheme();
    return React5.createElement(Tag, __assign({ "aria-labelledby": ariaLabelledBy, "aria-describedby": ariaDescribedBy }, divProps, rootProps, {
      className: css(getRootClass(), className),
      ref: this._mergedRef(this.props.elementRef, this._root),
      "data-focuszone-id": this._id,
      onKeyDown: function(ev) {
        return _this._onKeyDown(ev, theme);
      },
      onFocus: this._onFocus,
      onMouseDownCapture: this._onMouseDown
    }), this.props.children);
  };
  FocusZone2.prototype.focus = function(forceIntoFirstElement) {
    if (forceIntoFirstElement === void 0) {
      forceIntoFirstElement = false;
    }
    if (this._root.current) {
      if (!forceIntoFirstElement && this._root.current.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === "true" && this._isInnerZone) {
        var ownerZoneElement = this._getOwnerZone(this._root.current);
        if (ownerZoneElement !== this._root.current) {
          var ownerZone = _allInstances[ownerZoneElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE)];
          return !!ownerZone && ownerZone.focusElement(this._root.current);
        }
        return false;
      } else if (!forceIntoFirstElement && this._activeElement && elementContains(this._root.current, this._activeElement) && isElementTabbable(this._activeElement)) {
        this._activeElement.focus();
        return true;
      } else {
        var firstChild = this._root.current.firstChild;
        return this.focusElement(getNextElement(this._root.current, firstChild, true));
      }
    }
    return false;
  };
  FocusZone2.prototype.focusLast = function() {
    if (this._root.current) {
      var lastChild = this._root.current && this._root.current.lastChild;
      return this.focusElement(getPreviousElement(this._root.current, lastChild, true, true, true));
    }
    return false;
  };
  FocusZone2.prototype.focusElement = function(element, forceAlignment) {
    var _a = this.props, onBeforeFocus = _a.onBeforeFocus, shouldReceiveFocus = _a.shouldReceiveFocus;
    if (shouldReceiveFocus && !shouldReceiveFocus(element) || onBeforeFocus && !onBeforeFocus(element)) {
      return false;
    }
    if (element) {
      this._setActiveElement(element, forceAlignment);
      if (this._activeElement) {
        this._activeElement.focus();
      }
      return true;
    }
    return false;
  };
  FocusZone2.prototype.setFocusAlignment = function(point) {
    this._focusAlignment = point;
  };
  Object.defineProperty(FocusZone2.prototype, "defaultFocusElement", {
    get: function() {
      return this._defaultFocusElement;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FocusZone2.prototype, "activeElement", {
    get: function() {
      return this._activeElement;
    },
    enumerable: false,
    configurable: true
  });
  FocusZone2.prototype._evaluateFocusBeforeRender = function() {
    var root = this._root.current;
    var doc = this._getDocument();
    if (doc) {
      var focusedElement = doc.activeElement;
      if (focusedElement !== root) {
        var shouldRestoreFocus = elementContains(root, focusedElement, false);
        this._lastIndexPath = shouldRestoreFocus ? getElementIndexPath(root, focusedElement) : void 0;
      }
    }
  };
  FocusZone2.prototype._setParkedFocus = function(isParked) {
    var root = this._root.current;
    if (root && this._isParked !== isParked) {
      this._isParked = isParked;
      if (isParked) {
        if (!this.props.allowFocusRoot) {
          this._parkedTabIndex = root.getAttribute("tabindex");
          root.setAttribute("tabindex", "-1");
        }
        root.focus();
      } else if (!this.props.allowFocusRoot) {
        if (this._parkedTabIndex) {
          root.setAttribute("tabindex", this._parkedTabIndex);
          this._parkedTabIndex = void 0;
        } else {
          root.removeAttribute("tabindex");
        }
      }
    }
  };
  FocusZone2.prototype._setActiveElement = function(element, forceAlignment) {
    var previousActiveElement = this._activeElement;
    this._activeElement = element;
    if (previousActiveElement) {
      if (isElementFocusZone(previousActiveElement)) {
        this._updateTabIndexes(previousActiveElement);
      }
      previousActiveElement.tabIndex = -1;
    }
    if (this._activeElement) {
      if (!this._focusAlignment || forceAlignment) {
        this._setFocusAlignment(element, true, true);
      }
      this._activeElement.tabIndex = 0;
    }
  };
  FocusZone2.prototype._preventDefaultWhenHandled = function(ev) {
    this.props.preventDefaultWhenHandled && ev.preventDefault();
  };
  FocusZone2.prototype._tryInvokeClickForFocusable = function(targetElement, ev) {
    var target = targetElement;
    if (target === this._root.current) {
      return false;
    }
    do {
      if (target.tagName === "BUTTON" || target.tagName === "A" || target.tagName === "INPUT" || target.tagName === "TEXTAREA") {
        return false;
      }
      if (this._isImmediateDescendantOfZone(target) && target.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === "true" && target.getAttribute(IS_ENTER_DISABLED_ATTRIBUTE) !== "true") {
        raiseClickFromKeyboardEvent(target, ev);
        return true;
      }
      target = getParent(target, ALLOW_VIRTUAL_ELEMENTS);
    } while (target !== this._root.current);
    return false;
  };
  FocusZone2.prototype._getFirstInnerZone = function(rootElement) {
    rootElement = rootElement || this._activeElement || this._root.current;
    if (!rootElement) {
      return null;
    }
    if (isElementFocusZone(rootElement)) {
      return _allInstances[rootElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE)];
    }
    var child = rootElement.firstElementChild;
    while (child) {
      if (isElementFocusZone(child)) {
        return _allInstances[child.getAttribute(FOCUSZONE_ID_ATTRIBUTE)];
      }
      var match = this._getFirstInnerZone(child);
      if (match) {
        return match;
      }
      child = child.nextElementSibling;
    }
    return null;
  };
  FocusZone2.prototype._moveFocus = function(isForward, getDistanceFromCenter, ev, useDefaultWrap) {
    if (useDefaultWrap === void 0) {
      useDefaultWrap = true;
    }
    var element = this._activeElement;
    var candidateDistance = -1;
    var candidateElement = void 0;
    var changedFocus = false;
    var isBidirectional = this.props.direction === FocusZoneDirection.bidirectional;
    if (!element || !this._root.current) {
      return false;
    }
    if (this._isElementInput(element)) {
      if (!this._shouldInputLoseFocus(element, isForward)) {
        return false;
      }
    }
    var activeRect = isBidirectional ? element.getBoundingClientRect() : null;
    do {
      element = isForward ? getNextElement(this._root.current, element) : getPreviousElement(this._root.current, element);
      if (isBidirectional) {
        if (element) {
          var targetRect = element.getBoundingClientRect();
          var elementDistance = getDistanceFromCenter(activeRect, targetRect);
          if (elementDistance === -1 && candidateDistance === -1) {
            candidateElement = element;
            break;
          }
          if (elementDistance > -1 && (candidateDistance === -1 || elementDistance < candidateDistance)) {
            candidateDistance = elementDistance;
            candidateElement = element;
          }
          if (candidateDistance >= 0 && elementDistance < 0) {
            break;
          }
        }
      } else {
        candidateElement = element;
        break;
      }
    } while (element);
    if (candidateElement && candidateElement !== this._activeElement) {
      changedFocus = true;
      this.focusElement(candidateElement);
    } else if (this.props.isCircularNavigation && useDefaultWrap) {
      if (isForward) {
        return this.focusElement(getNextElement(this._root.current, this._root.current.firstElementChild, true));
      } else {
        return this.focusElement(getPreviousElement(this._root.current, this._root.current.lastElementChild, true, true, true));
      }
    }
    return changedFocus;
  };
  FocusZone2.prototype._moveFocusDown = function() {
    var _this = this;
    var targetTop = -1;
    var leftAlignment = this._focusAlignment.left || this._focusAlignment.x || 0;
    if (this._moveFocus(true, function(activeRect, targetRect) {
      var distance = -1;
      var targetRectTop = Math.floor(targetRect.top);
      var activeRectBottom = Math.floor(activeRect.bottom);
      if (targetRectTop < activeRectBottom) {
        if (!_this._shouldWrapFocus(_this._activeElement, NO_VERTICAL_WRAP)) {
          return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
        }
        return LARGE_DISTANCE_FROM_CENTER;
      }
      if (targetTop === -1 && targetRectTop >= activeRectBottom || targetRectTop === targetTop) {
        targetTop = targetRectTop;
        if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {
          distance = 0;
        } else {
          distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);
        }
      }
      return distance;
    })) {
      this._setFocusAlignment(this._activeElement, false, true);
      return true;
    }
    return false;
  };
  FocusZone2.prototype._moveFocusUp = function() {
    var _this = this;
    var targetTop = -1;
    var leftAlignment = this._focusAlignment.left || this._focusAlignment.x || 0;
    if (this._moveFocus(false, function(activeRect, targetRect) {
      var distance = -1;
      var targetRectBottom = Math.floor(targetRect.bottom);
      var targetRectTop = Math.floor(targetRect.top);
      var activeRectTop = Math.floor(activeRect.top);
      if (targetRectBottom > activeRectTop) {
        if (!_this._shouldWrapFocus(_this._activeElement, NO_VERTICAL_WRAP)) {
          return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
        }
        return LARGE_DISTANCE_FROM_CENTER;
      }
      if (targetTop === -1 && targetRectBottom <= activeRectTop || targetRectTop === targetTop) {
        targetTop = targetRectTop;
        if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {
          distance = 0;
        } else {
          distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);
        }
      }
      return distance;
    })) {
      this._setFocusAlignment(this._activeElement, false, true);
      return true;
    }
    return false;
  };
  FocusZone2.prototype._moveFocusLeft = function(theme) {
    var _this = this;
    var shouldWrap = this._shouldWrapFocus(this._activeElement, NO_HORIZONTAL_WRAP);
    if (this._moveFocus(getRTL(theme), function(activeRect, targetRect) {
      var distance = -1;
      var topBottomComparison;
      if (getRTL(theme)) {
        topBottomComparison = parseFloat(targetRect.top.toFixed(3)) < parseFloat(activeRect.bottom.toFixed(3));
      } else {
        topBottomComparison = parseFloat(targetRect.bottom.toFixed(3)) > parseFloat(activeRect.top.toFixed(3));
      }
      if (topBottomComparison && targetRect.right <= activeRect.right && _this.props.direction !== FocusZoneDirection.vertical) {
        distance = activeRect.right - targetRect.right;
      } else if (!shouldWrap) {
        distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
      }
      return distance;
    }, void 0, shouldWrap)) {
      this._setFocusAlignment(this._activeElement, true, false);
      return true;
    }
    return false;
  };
  FocusZone2.prototype._moveFocusRight = function(theme) {
    var _this = this;
    var shouldWrap = this._shouldWrapFocus(this._activeElement, NO_HORIZONTAL_WRAP);
    if (this._moveFocus(!getRTL(theme), function(activeRect, targetRect) {
      var distance = -1;
      var topBottomComparison;
      if (getRTL(theme)) {
        topBottomComparison = parseFloat(targetRect.bottom.toFixed(3)) > parseFloat(activeRect.top.toFixed(3));
      } else {
        topBottomComparison = parseFloat(targetRect.top.toFixed(3)) < parseFloat(activeRect.bottom.toFixed(3));
      }
      if (topBottomComparison && targetRect.left >= activeRect.left && _this.props.direction !== FocusZoneDirection.vertical) {
        distance = targetRect.left - activeRect.left;
      } else if (!shouldWrap) {
        distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
      }
      return distance;
    }, void 0, shouldWrap)) {
      this._setFocusAlignment(this._activeElement, true, false);
      return true;
    }
    return false;
  };
  FocusZone2.prototype._moveFocusPaging = function(isForward, useDefaultWrap) {
    if (useDefaultWrap === void 0) {
      useDefaultWrap = true;
    }
    var element = this._activeElement;
    if (!element || !this._root.current) {
      return false;
    }
    if (this._isElementInput(element)) {
      if (!this._shouldInputLoseFocus(element, isForward)) {
        return false;
      }
    }
    var scrollableParent = findScrollableParent(element);
    if (!scrollableParent) {
      return false;
    }
    var candidateDistance = -1;
    var candidateElement = void 0;
    var targetTop = -1;
    var targetBottom = -1;
    var pagesize = scrollableParent.clientHeight;
    var activeRect = element.getBoundingClientRect();
    do {
      element = isForward ? getNextElement(this._root.current, element) : getPreviousElement(this._root.current, element);
      if (element) {
        var targetRect = element.getBoundingClientRect();
        var targetRectTop = Math.floor(targetRect.top);
        var activeRectBottom = Math.floor(activeRect.bottom);
        var targetRectBottom = Math.floor(targetRect.bottom);
        var activeRectTop = Math.floor(activeRect.top);
        var elementDistance = this._getHorizontalDistanceFromCenter(isForward, activeRect, targetRect);
        var isElementPassedPageSizeOnPagingDown = isForward && targetRectTop > activeRectBottom + pagesize;
        var isElementPassedPageSizeOnPagingUp = !isForward && targetRectBottom < activeRectTop - pagesize;
        if (isElementPassedPageSizeOnPagingDown || isElementPassedPageSizeOnPagingUp) {
          break;
        }
        if (elementDistance > -1) {
          if (isForward && targetRectTop > targetTop) {
            targetTop = targetRectTop;
            candidateDistance = elementDistance;
            candidateElement = element;
          } else if (!isForward && targetRectBottom < targetBottom) {
            targetBottom = targetRectBottom;
            candidateDistance = elementDistance;
            candidateElement = element;
          } else if (candidateDistance === -1 || elementDistance <= candidateDistance) {
            candidateDistance = elementDistance;
            candidateElement = element;
          }
        }
      }
    } while (element);
    var changedFocus = false;
    if (candidateElement && candidateElement !== this._activeElement) {
      changedFocus = true;
      this.focusElement(candidateElement);
      this._setFocusAlignment(candidateElement, false, true);
    } else if (this.props.isCircularNavigation && useDefaultWrap) {
      if (isForward) {
        return this.focusElement(getNextElement(this._root.current, this._root.current.firstElementChild, true));
      }
      return this.focusElement(getPreviousElement(this._root.current, this._root.current.lastElementChild, true, true, true));
    }
    return changedFocus;
  };
  FocusZone2.prototype._setFocusAlignment = function(element, isHorizontal, isVertical) {
    if (this.props.direction === FocusZoneDirection.bidirectional && (!this._focusAlignment || isHorizontal || isVertical)) {
      var rect = element.getBoundingClientRect();
      var left = rect.left + rect.width / 2;
      var top_1 = rect.top + rect.height / 2;
      if (!this._focusAlignment) {
        this._focusAlignment = { left, top: top_1 };
      }
      if (isHorizontal) {
        this._focusAlignment.left = left;
      }
      if (isVertical) {
        this._focusAlignment.top = top_1;
      }
    }
  };
  FocusZone2.prototype._isImmediateDescendantOfZone = function(element) {
    return this._getOwnerZone(element) === this._root.current;
  };
  FocusZone2.prototype._getOwnerZone = function(element) {
    var parentElement = getParent(element, ALLOW_VIRTUAL_ELEMENTS);
    while (parentElement && parentElement !== this._root.current && parentElement !== this._getDocument().body) {
      if (isElementFocusZone(parentElement)) {
        return parentElement;
      }
      parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);
    }
    return parentElement;
  };
  FocusZone2.prototype._updateTabIndexes = function(element) {
    if (!this._activeElement && this.props.defaultTabbableElement && typeof this.props.defaultTabbableElement === "function") {
      this._activeElement = this.props.defaultTabbableElement(this._root.current);
    }
    if (!element && this._root.current) {
      this._defaultFocusElement = null;
      element = this._root.current;
      if (this._activeElement && !elementContains(element, this._activeElement)) {
        this._activeElement = null;
      }
    }
    if (this._activeElement && !isElementTabbable(this._activeElement)) {
      this._activeElement = null;
    }
    var childNodes = element && element.children;
    for (var childIndex = 0; childNodes && childIndex < childNodes.length; childIndex++) {
      var child = childNodes[childIndex];
      if (!isElementFocusZone(child)) {
        if (child.getAttribute && child.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === "false") {
          child.setAttribute(TABINDEX, "-1");
        }
        if (isElementTabbable(child)) {
          if (this.props.disabled) {
            child.setAttribute(TABINDEX, "-1");
          } else if (!this._isInnerZone && (!this._activeElement && !this._defaultFocusElement || this._activeElement === child)) {
            this._defaultFocusElement = child;
            if (child.getAttribute(TABINDEX) !== "0") {
              child.setAttribute(TABINDEX, "0");
            }
          } else if (child.getAttribute(TABINDEX) !== "-1") {
            child.setAttribute(TABINDEX, "-1");
          }
        } else if (child.tagName === "svg" && child.getAttribute("focusable") !== "false") {
          child.setAttribute("focusable", "false");
        }
      } else if (child.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === "true") {
        if (!this._isInnerZone && (!this._activeElement && !this._defaultFocusElement || this._activeElement === child)) {
          this._defaultFocusElement = child;
          if (child.getAttribute(TABINDEX) !== "0") {
            child.setAttribute(TABINDEX, "0");
          }
        } else if (child.getAttribute(TABINDEX) !== "-1") {
          child.setAttribute(TABINDEX, "-1");
        }
      }
      this._updateTabIndexes(child);
    }
  };
  FocusZone2.prototype._isContentEditableElement = function(element) {
    return element && element.getAttribute("contenteditable") === "true";
  };
  FocusZone2.prototype._isElementInput = function(element) {
    if (element && element.tagName && (element.tagName.toLowerCase() === "input" || element.tagName.toLowerCase() === "textarea")) {
      return true;
    }
    return false;
  };
  FocusZone2.prototype._shouldInputLoseFocus = function(element, isForward) {
    if (!this._processingTabKey && element && element.type && ALLOWED_INPUT_TYPES.indexOf(element.type.toLowerCase()) > -1) {
      var selectionStart = element.selectionStart;
      var selectionEnd = element.selectionEnd;
      var isRangeSelected = selectionStart !== selectionEnd;
      var inputValue = element.value;
      var isReadonly = element.readOnly;
      if (isRangeSelected || selectionStart > 0 && !isForward && !isReadonly || selectionStart !== inputValue.length && isForward && !isReadonly || !!this.props.handleTabKey && !(this.props.shouldInputLoseFocusOnArrowKey && this.props.shouldInputLoseFocusOnArrowKey(element))) {
        return false;
      }
    }
    return true;
  };
  FocusZone2.prototype._shouldWrapFocus = function(element, noWrapDataAttribute) {
    return this.props.checkForNoWrap ? shouldWrapFocus(element, noWrapDataAttribute) : true;
  };
  FocusZone2.prototype._portalContainsElement = function(element) {
    return element && !!this._root.current && portalContainsElement(element, this._root.current);
  };
  FocusZone2.prototype._getDocument = function() {
    return getDocument(this._root.current);
  };
  FocusZone2.defaultProps = {
    isCircularNavigation: false,
    direction: FocusZoneDirection.bidirectional,
    shouldRaiseClicks: true
  };
  return FocusZone2;
}(React5.Component);

// node_modules/@fluentui/react-focus/lib/version.js
setVersion("@fluentui/react-focus", "8.7.6");

// node_modules/@fluentui/react/lib/utilities/decorators/BaseDecorator.js
var React6 = __toESM(require_react());
var BaseDecorator = function(_super) {
  __extends(BaseDecorator2, _super);
  function BaseDecorator2(props) {
    var _this = _super.call(this, props) || this;
    _this._updateComposedComponentRef = _this._updateComposedComponentRef.bind(_this);
    return _this;
  }
  BaseDecorator2.prototype._updateComposedComponentRef = function(composedComponentInstance) {
    this._composedComponentInstance = composedComponentInstance;
    if (composedComponentInstance) {
      this._hoisted = hoistMethods(this, composedComponentInstance);
    } else if (this._hoisted) {
      unhoistMethods(this, this._hoisted);
    }
  };
  return BaseDecorator2;
}(React6.Component);

export {
  IconType,
  ImageFit,
  ImageCoverStyle,
  ImageLoadState,
  ImageBase,
  Image,
  getIconContent,
  FontIcon,
  getFontIcon,
  IconBase,
  Icon,
  ImageIcon,
  FocusZoneTabbableElements,
  FocusZoneDirection,
  FocusZone,
  BaseDecorator
};
//# sourceMappingURL=chunk-RDTBTV7D.js.map
