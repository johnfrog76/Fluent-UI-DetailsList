define(["require", "exports", "react", "./dom/getWindow", "./keyboard", "./setFocusVisibility"], function (require, exports, React, getWindow_1, keyboard_1, setFocusVisibility_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FocusRects = exports.useFocusRects = exports.FocusRectsProvider = exports.FocusRectsContext = void 0;
    var mountCounters = new WeakMap();
    var callbackMap = new WeakMap();
    function setMountCounters(key, delta) {
        var newValue;
        var currValue = mountCounters.get(key);
        if (currValue) {
            newValue = currValue + delta;
        }
        else {
            newValue = 1;
        }
        mountCounters.set(key, newValue);
        return newValue;
    }
    function setCallbackMap(key) {
        var callbacks = callbackMap.get(key);
        if (callbacks) {
            return callbacks;
        }
        var onMouseDown = function (ev) { return _onMouseDown(ev, key); };
        var onPointerDown = function (ev) { return _onPointerDown(ev, key); };
        var onKeyDown = function (ev) { return _onKeyDown(ev, key); };
        var onKeyUp = function (ev) { return _onKeyUp(ev, key); };
        callbacks = { onMouseDown: onMouseDown, onPointerDown: onPointerDown, onKeyDown: onKeyDown, onKeyUp: onKeyUp };
        callbackMap.set(key, callbacks);
        return callbacks;
    }
    exports.FocusRectsContext = React.createContext({});
    exports.FocusRectsProvider = exports.FocusRectsContext.Provider;
    /**
     * Initializes the logic which:
     *
     * 1. Subscribes keydown, keyup, mousedown and pointerdown events. (It will only do it once for the current element of
     *    the FocusRectsContext providerRef or once per window if no such element is provided via context, so it's safe to
     *    call this method multiple times.)
     * 2. When the user presses triggers a keydown or keyup event via directional keyboard keys, adds the
     *    'ms-Fabric--isFocusVisible' classname to the current element of the FocusRectsContext providerRef or the document
     *    body if no such element is provided via context, and removes the 'ms-Fabric-isFocusHidden' classname.
     * 3. When the user triggers a mousedown or pointerdown event, adds the 'ms-Fabric-isFocusHidden' classname to the
     *    current element of the FocusRectsContext providerRef or the document body if no such element is provided via
     *    context, and removes the 'ms-Fabric--isFocusVisible' classname.
     *
     * This logic allows components on the page to conditionally render focus treatments based on
     * the existence of global classnames, which simplifies logic overall.
     *
     * @param rootRef - A Ref object. Focus rectangle can be applied on itself and all its children.
     */
    function useFocusRects(rootRef) {
        var providerRef = React.useContext(exports.FocusRectsContext).providerRef;
        React.useEffect(function () {
            var _a;
            var win = getWindow_1.getWindow(rootRef === null || rootRef === void 0 ? void 0 : rootRef.current);
            if (!win || ((_a = win.FabricConfig) === null || _a === void 0 ? void 0 : _a.disableFocusRects) === true) {
                return undefined;
            }
            var el = win;
            var onMouseDown;
            var onPointerDown;
            var onKeyDown;
            var onKeyUp;
            if (providerRef && providerRef.current) {
                el = providerRef.current;
                var callbacks = setCallbackMap(el);
                onMouseDown = callbacks.onMouseDown;
                onPointerDown = callbacks.onPointerDown;
                onKeyDown = callbacks.onKeyDown;
                onKeyUp = callbacks.onKeyUp;
            }
            else {
                onMouseDown = _onMouseDown;
                onPointerDown = _onPointerDown;
                onKeyDown = _onKeyDown;
                onKeyUp = _onKeyUp;
            }
            var count = setMountCounters(el, 1);
            if (count <= 1) {
                el.addEventListener('mousedown', onMouseDown, true);
                el.addEventListener('pointerdown', onPointerDown, true);
                el.addEventListener('keydown', onKeyDown, true);
                el.addEventListener('keyup', onKeyUp, true);
            }
            return function () {
                var _a;
                if (!win || ((_a = win.FabricConfig) === null || _a === void 0 ? void 0 : _a.disableFocusRects) === true) {
                    return;
                }
                count = setMountCounters(el, -1);
                if (count === 0) {
                    el.removeEventListener('mousedown', onMouseDown, true);
                    el.removeEventListener('pointerdown', onPointerDown, true);
                    el.removeEventListener('keydown', onKeyDown, true);
                    el.removeEventListener('keyup', onKeyUp, true);
                }
            };
        }, [providerRef, rootRef]);
    }
    exports.useFocusRects = useFocusRects;
    /**
     * Function Component wrapper which enables calling `useFocusRects` hook.
     * Renders nothing.
     */
    var FocusRects = function (props) {
        useFocusRects(props.rootRef);
        return null;
    };
    exports.FocusRects = FocusRects;
    function _onMouseDown(ev, providerElem) {
        setFocusVisibility_1.setFocusVisibility(false, ev.target, providerElem);
    }
    function _onPointerDown(ev, providerElem) {
        if (ev.pointerType !== 'mouse') {
            setFocusVisibility_1.setFocusVisibility(false, ev.target, providerElem);
        }
    }
    // You need both a keydown and a keyup listener that sets focus visibility to true to handle two distinct scenarios when
    // attaching the listeners and classnames to the provider instead of the document body.
    // If you only have a keydown listener, then the focus rectangles will not show when moving from outside of the provider
    // to inside it. That is why a keyup listener is needed, since it will always trigger after the focus event is fired.
    // If you only have a keyup listener, then the focus rectangles will not show moving between different tabbable elements
    // if the tab key is pressed without being released. That's is why we need a keydown listener, since it will trigger for
    // every element that is being tabbed into.
    // This works because `classList.add` is smart and will not duplicate a classname that already exists on the classList
    // when focus visibility is turned on.
    function _onKeyDown(ev, providerElem) {
        // eslint-disable-next-line deprecation/deprecation
        if (keyboard_1.isDirectionalKeyCode(ev.which)) {
            setFocusVisibility_1.setFocusVisibility(true, ev.target, providerElem);
        }
    }
    function _onKeyUp(ev, providerElem) {
        // eslint-disable-next-line deprecation/deprecation
        if (keyboard_1.isDirectionalKeyCode(ev.which)) {
            setFocusVisibility_1.setFocusVisibility(true, ev.target, providerElem);
        }
    }
});
//# sourceMappingURL=useFocusRects.js.map